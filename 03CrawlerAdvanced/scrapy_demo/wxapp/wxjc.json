{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pub_time": "2018-9-19 00:02", "article_content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "微信小程序之购物车和父子组件传值及calc的注意事项 ", "author": "Rolan", "pub_time": "2018-11-13 00:57", "article_content": "1.效果图2.子组件实现要实现图中删除的效果，使用组件的形式更好做点，我当时本想直接在pages里实现，不过结果就是，滑动时，所有的商品都显示了删除按钮，除非用数组将每个商品要移动的距离存储起来，不过这样的话就很麻烦，所以我也是用组件来实现的关于微信组件，可以直接点击链接访问官网查看自定义组件子组件index.wxml<view class=\"commodityItem\" bindtouchstart=\"handleTouchStart\" bindtouchmove=\"handleTouchMove\" style=\"transform:translateX({{-rightSpace}}px)\">\r\n  <view class=\"selectedBtn\" bindtap=\"handleSelect\" data-is-selected=\"{{commodity.isselected}}\">\r\n    <view class=\"noSelected\" wx:if=\"{{commodity.isselected==0}}\"></view>\r\n    <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n  </view>\r\n  <view class=\"commodityInfo\">\r\n    <view class=\"commodityImg\">\r\n      <image src=\"{{commodity.image}}\"></image>          \r\n    </view>\r\n    <view class=\"commodityTitle\">\r\n      <view class=\"title\">{{commodity.title}}</view>\r\n      <view class=\"standard\">规格：{{commodity.standard?commodity.standard:'无'}}</view>\r\n      <view class=\"count\">\r\n        <view class=\"price\">￥{{commodity.price}}</view>\r\n        <view class=\"commodityNum\">\r\n          <i-input-number value=\"{{selectedNum}}\" min=\"1\" max=\"{{commodity.stock}}\" bindchange=\"numChange\" />\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"deleteBtn\">\r\n    <image class=\"deleteImg\" src=\"/images/delete.png\"></image>\r\n    <text class=\"deleteText\">删除</text>\r\n  </view>\r\n</view>子组件index.wxss/* 商品 */\r\n.commodityItem{\r\n  display: flex;\r\n  position: relative;\r\n  padding: 10rpx 24rpx 20rpx 30rpx;\r\n  box-sizing: border-box;\r\n  background: #fff;\r\n  transition: all .5s;\r\n}\r\n/* 选择按钮 */\r\n.selectedBtn{\r\n  display: flex;\r\n  align-items: center;\r\n  width: 80rpx;\r\n}\r\n.noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectedBtn .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n/* 商品信息 */\r\n.commodityInfo{\r\n  display: flex;\r\n  width: calc(100% - 80rpx);\r\n}\r\n.commodityImg{\r\n  margin-right: 18rpx;\r\n  width: 220rpx;\r\n  height: 220rpx;\r\n}\r\n.commodityImg image{\r\n  width: 100%;\r\n  height: 100%;\r\n  vertical-align: middle;  \r\n}\r\n/* 商品title */\r\n.commodityTitle{\r\n  width: calc(100% - 220rpx);\r\n}\r\n.title{\r\n  display: -webkit-box;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  line-height:35rpx;\r\n  font-size: 24rpx;\r\n  font-weight:600;\r\n  overflow: hidden;\r\n  -webkit-line-clamp: 2;\r\n  -webkit-box-orient: vertical;\r\n}\r\n.standard{\r\n  padding-top: 16rpx;\r\n  width: 100%;\r\n  height: 90rpx;\r\n  box-sizing: border-box;\r\n}\r\n.count{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  width: 100%;\r\n  height: 60rpx;\r\n}\r\n\r\n/* 删除按钮 */\r\n.deleteBtn{\r\n  display: flex;\r\n  position: absolute;\r\n  width: 70px;\r\n  height: 100%;\r\n  top: 0rpx;\r\n  right: -70px;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: #ef5225;\r\n}\r\n.deleteImg{\r\n  margin-bottom: 10rpx;\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n  vertical-align: middle;\r\n}\r\n.deleteText{\r\n  color: #fff;\r\n}子组件index.json，这里用了iview中的数字输入框{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"i-input-number\": \"/component/iview/input-number/index\"\r\n  }\r\n}子组件index.jsComponent({\r\n\r\n  properties: {\r\n    commodity: Object,\r\n  },\r\n\r\n  data: {\r\n    touchStart: null,\r\n    rightSpace: 0,\r\n    selectedNum: 1,\r\n  },\r\n\r\n  methods: {\r\n    /* 商品是否选中 */\r\n    handleSelect() {\r\n            let selectedNum = this.data.selectedNum;\r\n      let commodity = this.data.commodity;\r\n      if(commodity.isselected == 0) {\r\n        commodity.isselected = 1;\r\n      } else {\r\n        commodity.isselected = 0;\r\n      }\r\n            this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    },\r\n    /* 处理触摸滑动开始 */\r\n    handleTouchStart(e) {\r\n      /* 记录触摸滑动初始位置 */\r\n      let touchStart = e.changedTouches[0].clientX;\r\n      this.setData({\r\n        touchStart\r\n      })\r\n    },\r\n    /* 处理触摸滑动 */\r\n    handleTouchMove(e) {\r\n      console.log(e)\r\n      let moveSpace = e.changedTouches[0].clientX;\r\n      let touchStart = this.data.touchStart;\r\n      if (touchStart != null) {\r\n        if (moveSpace - touchStart > 70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 0\r\n          })\r\n        }\r\n        else if (moveSpace - touchStart < -70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 70\r\n          })\r\n        }\r\n      }\r\n    },\r\n    numChange(e) {\r\n        let selectedNum = e.detail.value;\r\n        let commodity = this.data.commodity;\r\n        this.setData({\r\n            selectedNum\r\n        })\r\n        this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    }\r\n  }\r\n})3.父组件实现父组件index.wxml，这里用的是假数据，所以操作上会有一些是联调时不必要的操作<view class=\"cart\">\r\n  <view class=\"item\" wx:for=\"{{cartList}}\" wx:key=\"{{items.shopid}}\" wx:for-item=\"items\">\r\n    <view class=\"storeInfo\">\r\n      <image class=\"avatar\" src=\"{{items.logo}}\"></image>\r\n      <view class=\"storeName\">{{items.shopname}}</view>\r\n    </view>\r\n    <view class=\"discount\">满￥100包邮，满10件包邮</view>\r\n    <view class=\"commodity\" wx:for=\"{{items.commodity}}\" wx:key=\"{{item.id}}\">\r\n      <cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />\r\n    </view>\r\n  </view>\r\n    <view class=\"count\">\r\n        <view class=\"selectAll\" bindtap=\"handleSelectAll\">\r\n            <view class=\"noSelected\" wx:if=\"{{!isSelectedAll}}\"></view>\r\n        <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n            <text class=\"selectAllText\">全选</text>\r\n        </view>\r\n        <view class=\"countPrice\">\r\n      <text>合计:</text>\r\n      <text>￥{{countPrice}}</text>\r\n    </view>\r\n        <view class=\"account\">\r\n      <text>结算</text>\r\n      <text>({{countSelectedNum}})</text>\r\n    </view>\r\n    </view>\r\n</view>父组件index.wxsspage{\r\n  background: #f8f8f8;\r\n}\r\n.cart{\r\n    padding-bottom: 100rpx;\r\n  font-size: 26rpx;\r\n}\r\n.item{\r\n  border-bottom: 1px solid #eee;\r\n}\r\n/* 头部店铺信息 */\r\n.storeInfo{\r\n  display: flex;\r\n  padding: 18rpx 0rpx 18rpx 30rpx;\r\n  background: #fff;\r\n  box-sizing: border-box;\r\n}\r\n.storeInfo .avatar{\r\n  width: 56rpx;\r\n  height: 56rpx;\r\n  border-radius: 50%;\r\n  vertical-align: middle;\r\n}\r\n.storeInfo .storeName{\r\n  margin-left: 16rpx;\r\n  line-height: 56rpx;\r\n}\r\n/* 包邮信息 */\r\n.discount{\r\n  padding-left: 30rpx;\r\n  height:50rpx;\r\n  line-height: 50rpx;\r\n  font-size:20rpx;\r\n  color: #666;\r\n  box-sizing: border-box;\r\n}\r\n/* 底部操作 */\r\n.count{\r\n    display: flex;\r\n    position: fixed;\r\n    padding-left: 30rpx;\r\n    bottom: 0;\r\n  left: 0;\r\n    width: 100%;\r\n    height: 100rpx;\r\n    line-height: 100rpx;\r\n  box-sizing: border-box;\r\n  color: #232323;\r\n    background: #eee;\r\n}\r\n/* 全选 */\r\n.selectAll{\r\n    display: flex;\r\n  padding-right: 20rpx;\r\n    align-items: center;\r\n    width: 25%;\r\n  font-size: 30rpx;\r\n}\r\n.selectAll .noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectAll .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n.selectAllText{\r\n    margin-left: 18rpx;\r\n}\r\n\r\n.countPrice{\r\n    position: absolute;\r\n  top: 0;\r\n  right: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n}\r\n.countPrice text{\r\n  margin-right: 15rpx;\r\n}\r\n.account{\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n    width: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  background: #ef5225;\r\n  color: #fff;\r\n}父组件index.json，引用子组件{\r\n  \"usingComponents\": {\r\n    \"cart-item\": \"/component/cart/index\"\r\n  }\r\n}父组件index.jsPage({\r\n\r\n  data: {\r\n    cartList: [\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 11,\r\n        commodity: [\r\n          {\r\n            id: 1,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 2,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '10',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar5.jpg',\r\n        shopid: 450,\r\n        commodity: [\r\n          {\r\n            id: 3,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '90',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          },\r\n          {\r\n            id: 4,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '100',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 5,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 2,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 550,\r\n        commodity: [\r\n          {\r\n            id: 6,\r\n            image:'/images/avatar8.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 1,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n    ],\r\n        /* 商品是否全选中 */\r\n        isSelectedAll: false,\r\n        /* 已选中商品的价格 */\r\n        countPrice: 0,\r\n    /* 统计所有选中的商品数量 */\r\n    countSelectedNum: 0,\r\n  },\r\n  /* 处理商品选中 */\r\n  handleSelect(e) {\r\n        let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n    let cartList = this.data.cartList;\r\n    let length = cartList.length;\r\n\r\n        /* 因为是假数据，所以需要循环查找到对应的数据将其替换 */\r\n    for(let i = 0; i < length; i++) {\r\n      for(let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if (cartList[i].commodity[j].id == e.detail.commodity.id) {\r\n          cartList[i].commodity[j] = e.detail.commodity;\r\n          cartList[i].commodity[j].selectedNum = e.detail.selectedNum;\r\n        }\r\n        if (cartList[i].commodity[j].isselected == 1) {\r\n          /* 点击选中的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认的加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += cartList[i].commodity[j].price * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;\r\n            countSelectedNum += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n        /* 对是否全选中进行判断 */\r\n        let isSelectedAll = true;\r\n        for (let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                /* 若商品中的isselecetd有为0的就终止循环，直接设置为未全选 */\r\n                if (cartList[i].commodity[j].isselected == 0) {\r\n                    isSelectedAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n    this.setData({\r\n      cartList,\r\n            isSelectedAll,\r\n            countPrice,\r\n      countSelectedNum\r\n    })\r\n  },\r\n    /* 全选中商品 */\r\n    handleSelectAll() {\r\n        let isSelectedAll = !this.data.isSelectedAll;\r\n        let cartList = this.data.cartList;\r\n        let length = cartList.length;\r\n    let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n\r\n        /* 遍历数据中的isselected来进行全选的操作 */\r\n        for(let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if(isSelectedAll) {\r\n                    cartList[i].commodity[j].isselected = 1;\r\n          /* 全选的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += parseInt(cartList[i].commodity[j].price) * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum;\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;    \r\n            countSelectedNum += 1;        \r\n          }\r\n                } else {\r\n                    cartList[i].commodity[j].isselected = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setData({\r\n            isSelectedAll,\r\n            cartList,\r\n      countPrice,\r\n      countSelectedNum\r\n        })\r\n    },\r\n})4.父子组件传值较常用的都是父组件往子组件传值，所以子组件往父组件传值就会不是很熟悉我这里的话，是因为用的假数据，在点击商品选中或者不选中时，需要改变商品里的选中属性，所以用到了子组件往父组件传值，也包括传递选中的商品数量子组件往父组件传值的话，是通过在调用this.triggerEvent()来实现的/* 在父组件中定义方法：bind:handleselect或者也可以直接写成bindhandleselect*/\r\n<cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />在子组件中调用this.triggerEvent('handleselect', { commodity, selectedNum})这个this.triggerEvent('handleselect', { commodity, selectedNum })方法中，handleselect的名称要与父组件中引用子组件时绑定的方法名称一样，后面的对象就是传递的值，也可以直接是以直接量的形式传递，然后再父组件中通过e.detail来获取对应的值handleSelect(e) {\r\n    console.log(e.detail)\r\n    console.log(e.detail.commodity)\r\n    console.log(e.detail.selectedNum)\r\n}5.calc的注意事项我以前也遇到过，然后现在再用的时候，一时间把这点给忘了，在看到编译器样式的时候，才猛然想起.user-content{\r\n    padding: 10px 0 10px 50px;\r\n    width: calc(100% - 50px);  /* 计算宽度，'+'或'-'符号前后有空格 */\r\n    height: 18px;\r\n}css中使用calc可以进行简单的运算：单位可以是百分比，px，rem，em等单位使用\"+\",\"-\",\"*\",\"/\"运算符（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）在Firefox浏览器上使用要加上-moz前缀chrome浏览器上使用要加上-webkit前缀（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）6.部分想法其实在样式上还是挺快就完成了，就是在计算商品价格的时候，想了挺久在计算价格时，当时就有点蒙圈，总是想着要怎么判断他是增加数量还是减少数量，然后就陷入死循环的之中。其实不用想她是增加还是减少数量，因为你都是传的是商品的数量，而且在计算时，也是判断了商品是否选中，所以，直接点，计算价格乘以数量就可以了然后选中的商品数量的统计就和计算价格的思路是一样的了正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端css实现波浪线及立方体微信小程序中遇到的多规格问题(一)实现单行及多行文字省略号"}
{"title": "vue 项目快速输出微信、支付宝、百度小程序 ", "author": "Rolan", "pub_time": "2018-11-14 00:01", "article_content": "上周，Megalo@0.2.0 正式发布，优化了数据更新性能的同时，支持了百度智能小程序，着实激动了一把，这“可能”是目前社区里第一个同时支持三端小程序的 vue 小程序框架。下面我们就来试试他的效果。跟着文档走官方文档的第一部分就是快速入门，顺藤摸瓜，构建一个 megalo 项目。安装$ npm install -g @megalo/cli\r\n复制代码构建$ megalo megalo-yanxuan-demo\r\n复制代码打包以微信小程序为入口$ npm run dev:wechat\r\n复制代码至此一个完整的 megalo 项目就构建好了，接下来我们开始转移源码转移 weex 项目我从以前 weex 的 demo 项目， yanxuan-weex-demo ，为基础进行转移，转移过程中涉及到很多 weex 特有的 api 的移除和转换。网络请求以网络请求为例，weex 是使用的 streamlet stream = weex.requireModule('stream');\r\nexport default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            return stream.fetch({\r\n                method: 'GET',\r\n                type: 'json',\r\n                url: api\r\n            }, callback)\r\n        }\r\n    }\r\n}\r\n复制代码因为小程序都有提供网络请求的 API，所以此处对此进行改造，如下export default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            let { platform } = this.$mp || {},\r\n                request = ()=>{}\r\n            switch(platform) {\r\n                case 'wechat':\r\n                    request = wx && wx.request\r\n                break;\r\n                case 'alipay':\r\n                    request = my && my.httpRequest\r\n                break;\r\n                case 'swan':\r\n                    request = swan && swan.request\r\n                break;\r\n                default:\r\n                break;\r\n            }\r\n            request && request({\r\n                url: api,\r\n                success: callback\r\n            })\r\n        }\r\n    }\r\n}\r\n复制代码类似的还有 toast、message 等组件的改造。组件由于 weex 中的 <recycle-list> 、 <loading> 、 <refresh> 、 <scroller> 等组件在小程序组件内是不存在的，所以有三种解决方案自定义一个同名 vue 组件找小程序可用的组件替换实在不行就砍掉需求吧比如 weex 的 <slider> 组件，可以用小程序的 <swiper> 替换，好在微信、支付宝和百度小程序都有支持。cssWeex 容器默认的宽度 (viewport) 是 750px，小程序以 750rpx 为基。所以直接将需要的 px 转换成 rpx。另外自己实现了 1 像素的 wpx，替换成 px 即可。执行三端效果最后看下改造效果。同时执行三端效果比预想的要好，没有过多的适配出错demo 源码 抛给大家供大家把玩。哪些可以转只要现有工程没有做以下几件事，理论上，都是可以转移的，只需要稍微更新一下格式使用 megalo 暂不支持的 vue 特性涉及浏览器特有的 dom 操作，window、userAgent、location、getElementById 等使用第三方组件库且该组件库使用了 dom 操作使用了 vue-router，暂不支持全局使用 vuex不过，方案都是可以调整的，以上功能在社区均可以找到替代方案。换之即可。"}
{"title": "小程序云开发初体验 ", "author": "Rolan", "pub_time": "2018-11-14 00:25", "article_content": "云开发\r\n开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。\r\n云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。\r\n类似于Bmob后端云或知晓云\r\n云开发的出现，让小程序的开发变得更简单方便，开发人员可以不用去购买搭建服务器，不用操心服务端的稳定性和数据库的安装\r\n\r\n开通云开发\r\n在微信开发工具里，直接点击'云开发'，会引导你开通， 需要注意的是云开发能力从基础库 2.2.3 开始支持\r\n\r\n云开发开通后自动获得一套云开发环境，各个环境相互隔离，每个环境都包含独立的数据库实例、存储空间、云函数配置等资源。每个环境都有唯一的环境 ID 标识，初始创建的环境自动成为默认环境。\r\n有一个免费的基础版\r\n开通云开发后初始默认可拥有最多两个环境。在实际开发中，建议每一个正式环境都搭配一个测试环境\r\n数据库\r\n云开发提供了一个json数据库(可以理解为MongoDB 这类 NoSQL 数据库)，就是一个json格式的对象。 一个数据库有多个集合，相当于关系型数据库的表。 集合数组里有多个对象，每一个对象就是一个记录，相当于关系型数据库中的行。数据库的操作提供了很多API，后面结合例子简单示例说明\r\n[\r\n    {\r\n      \"id\": 342166,\r\n      \"haspromotionTag\": false,\r\n      \"img\": \"http://p1.meituan.net/128.180/movie/740bd990e4af29d537ce324ec2cd08d6300433.jpg\",\r\n      \"version\": \"v2d imax\",\r\n      \"nm\": \"无双\",\r\n      \"preShow\": false,\r\n      \"sc\": 8.9,\r\n      \"globalReleased\": true,\r\n      \"wish\": 125425,\r\n      \"star\": \"周润发,郭富城,张静初\",\r\n      \"rt\": \"2018-09-30\",\r\n      \"showInfo\": \"今天183家影院放映2258场\",\r\n      \"showst\": 3,\r\n      \"wishst\": 0\r\n    },\r\n    {\r\n      \"id\": 1209159,\r\n      \"haspromotionTag\": false,\r\n      \"img\": \"http://p0.meituan.net/128.180/movie/4d9bedd239f41eaf08cd1c4297e4ec7d858156.jpg\",\r\n      \"version\": \"\",\r\n      \"nm\": \"找到你\",\r\n      \"preShow\": false,\r\n      \"sc\": 9,\r\n      \"globalReleased\": true,\r\n      \"wish\": 66559,\r\n      \"star\": \"姚晨,马伊琍,袁文康\",\r\n      \"rt\": \"2018-10-05\",\r\n      \"showInfo\": \"今天182家影院放映1039场\",\r\n      \"showst\": 3,\r\n      \"wishst\": 0\r\n    }\r\n]\r\n复制代码存储\r\n基础版提供了5G的存储容量，可以把文件(图片、视频...)上传到存储空间，在云端管理。直接使用小程序提供的上传下载接口，处理起来非常方便。\r\n云函数\r\n云函数是写后端代码的，云函数里可以操作数据库，操作存储，根据自身的业务需求完成后端代码的实现。云函数，是部署在云端的，但是我们可以在开发工具里编写后端的云函数，完成后再部署到云端，可以说所有逻辑都在一套代码里。\r\n我的第一个云开发小程序\r\n创建云开发项目时，据官方描述，在微信开发工具里，有一个QuickStart选项，但我发现并没有，可能是开发工具版本或其他原因。\r\n\r\n给数据库添加数据\r\n我在猫眼电影拷贝了部分数据，准备倒入小程序云开发的数据库\r\n\r\n可以看到，在控制台，可以自行添加数据，也可以直接倒入一个json文件。我这里选择调用它的API去倒入猫眼json数据\r\n首先我创建了一个名为movies的集合，紧接着调用初始化的方法\r\n\r\napp.js\r\n\r\n...\r\nonLaunch: function () {\r\n    wx.cloud.init()\r\n}\r\n...\r\n复制代码要操作数据库，需要先获取到数据库引用,  同时，获取到我刚创建的movies集合的引用, 由于在其他页面也需要调用，我这里把它们都挂到app的属性上\r\nconst app = getApp()\r\n...\r\napp.$db = wx.cloud.database()\r\napp.$collect_movies = app.$db.collection('movies')\r\n...\r\n复制代码最后， 调用添加的方法\r\ndata.subjects.forEach(o => {\r\n  app.$collect_movies.add({\r\n    data: o\r\n  })\r\n})\r\n复制代码现在云开发控制台数据库里已经有添加的数据了\r\n显示所有电影\r\napp.$collect_movies.where({\r\n  _openid: 'ofgUd0Rb4w8E7Af40N46ExxozS5g'\r\n}).get({\r\n  success: function (res) {\r\n    console.log('res', res)\r\n    that.setData({\r\n      movies: res.data\r\n    })\r\n  }\r\n})\r\n复制代码根据ID查询指定电影\r\napp.$collect_movies.doc('W8Wf4t2AWotkhlzK').get({\r\n    success: function (res) {\r\n      console.log('res',res)\r\n      that.setData({\r\n        movie: res.data\r\n      })\r\n    }\r\n})\r\n复制代码查询9分以上的电影\r\nconst _ = app.$db.command\r\napp.$collect_movies.where({\r\n    sc: _.gte(9)\r\n}).get({\r\n    success: function (res) {\r\n      wx.hideLoading()\r\n      that.setData({\r\n        movies: res.data\r\n      })\r\n    }\r\n})\r\n复制代码获取9分以上或0分的电影\r\nconst _ = app.$db.command\r\napp.$collect_movies.where({\r\n    sc: _.eq(0).or(_.gte(9))\r\n}).get({\r\n    success: function (res) {\r\n      wx.hideLoading()\r\n      that.setData({\r\n        movies: res.data\r\n      })\r\n    }\r\n})\r\n复制代码修改主演名\r\n# 确认修改\r\nconst that = this\r\napp.$collect_movies.doc(this.currentMovieId).update({\r\n  data: {\r\n    star: this.data.actor\r\n  },\r\n  success: function (res) {\r\n    that.initUpdateData()\r\n  }\r\n})\r\n复制代码删除一部电影\r\n# 确定删除\r\ndelAction(e) {\r\n    const that = this\r\n    const id = e.currentTarget.dataset.id\r\n    app.$collect_movies.doc(id).remove({\r\n      success: function (res) {\r\n        that.initUpdateData()\r\n      }\r\n    })\r\n}\r\n复制代码\r\n文件管理\r\n上传图片到云存储\r\n试着把手机相册的图片上传到小程序云存储中，可以在小程序端直接使用提供的api\r\nwx.cloud.uploadFile({\r\n  cloudPath: 'example.png', // 上传至云端的路径\r\n  filePath: '', // 小程序临时文件路径\r\n  success: res => {\r\n    // 返回文件 ID\r\n    console.log(res.fileID)\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码如果单纯从代码量来看，比上传到腾讯自家腾讯云还简单，当然比上传到像阿里云、七牛云这样的平台操作更简单。\r\n上传成功之后，返回的不是图片url, 而是文件id。如果要显示图片或者播放视频，这个文件id，小程序的组件image/video也能识别\r\n <image class=\"movie\" mode=\"widthFix\" src=\"{{ fileId }}\" wx:if=\"{{ fileId }}\"> </image>\r\n复制代码upload() {\r\n    const that = this\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success(res) {\r\n        const tempFilePaths = res.tempFilePaths\r\n        console.log(tempFilePaths[0])\r\n        wx.cloud.uploadFile({\r\n          cloudPath: 'test/2.png', // 上传至云端的路径\r\n          filePath: tempFilePaths[0], // 小程序临时文件路径\r\n          success: res => {\r\n            // 返回文件 ID\r\n            console.log(res.fileID)\r\n            that.setData({\r\n              fileId: res.fileID\r\n            })\r\n          },\r\n          fail: console.error\r\n        })\r\n      }\r\n    })\r\n}\r\n复制代码\r\n\r\n根据文件id下载文件\r\ndownloadFile() {\r\n  wx.cloud.downloadFile({\r\n  fileID: 'cloud://ii-1853ca.6969-ii-1853ca/test/2.png',\r\n  success: res => {\r\n    // 返回临时文件路径\r\n    console.log('tempFilePath', res)\r\n    // cloud://ii-1853ca.6969-ii-1853ca/test/2.png\r\n    this.setData({\r\n      downloadFileResult: res\r\n    })\r\n  },\r\n  fail: err => {\r\n    // handle error\r\n  }\r\n})\r\n复制代码根据文件id换取临时网络链接\r\n可以根据文件 ID 换取临时文件网络链接，文件链接有有效期为两个小时\r\nconst that = this\r\nwx.cloud.getTempFileURL({\r\n    fileList: [this.data.fileId],\r\n    success: res => {\r\n      // https://6969-ii-1853ca-1253918415.tcb.qcloud.la/test/2.png\r\n      that.setData({\r\n        fileList: res.fileList\r\n      })\r\n    },\r\n    fail: err => {\r\n      // handle error\r\n    }\r\n})\r\n复制代码云函数\r\n怎么玩？\r\n云函数是运行在Node.js环境下的\r\n首先在小程序项目根目录找到配置文件project.config.json文件，加上一个配置, 指定本地已存在的目录作为云函数的本地根目录\r\n  \"cloudfunctionRoot\": \"./functions/\",\r\n复制代码指定之后神奇的一幕就是图标会变成 “云目录图标”\r\n\r\n子目录都是我通过右键菜单创建一个新的云函数，其中文件名就是云函数名\r\n每创建一个云函数，都会出现弹窗，询问你是否有node环境，确定后会自动打开终端，安装依赖, 所以每一个云函数里面都是这样的：\r\n\r\n在index.js中, 默认是这样的\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n\r\n}\r\n复制代码创建一个相加的云函数\r\n\r\nplus/\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\n// context 对象包含了此处调用的调用信息和运行状态\r\n// event 指的是触发云函数的事件\r\nexports.main = async (event, context) => {\r\n  return {\r\n    sum: event.a + event.b\r\n  }\r\n}\r\n复制代码在小程序端调用plus云函数, 参数名一眼就看明白，不用解释\r\nwx.cloud.callFunction({\r\n  name: 'plus',\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success: function (res) {\r\n    console.log('plus', res.result) // 3\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码调用后报错，是因为没有把创建的云函数上传部署到云端, 如何部署？看下图\r\n\r\n部署成功之后，我们来到云控制台， 发现云函数已经在上面\r\n\r\n回到小程序，再次调用云函数，发现已经可以了, 拿到了预期的值3\r\n获取小程序用户信息\r\n云开发的云函数的独特优势在于与微信登录鉴权的无缝整合。当小程序端调用云函数时，云函数的传入参数中会被注入小程序端用户的 openid，开发者无需校验 openid 的正确性，因为微信已经完成了这部分鉴权，开发者可以直接使用该 openid。与 openid 一起同时注入云函数的还有小程序的 appid\r\n定义云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码调用云函数\r\nwx.cloud.callFunction({\r\n    name: 'userInfo',\r\n    success: function (res) {\r\n      console.log('userInfo', res.result)\r\n        /*\r\n          {\r\n            appId:\"wx8dae61dd0ef5c510\",\r\n            openId:\"ofgUd0Rb4w8E7Af40N46ExxozS5g\"\r\n           }\r\n        */\r\n    },\r\n    fail: console.error\r\n})\r\n复制代码异步云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve(event.a + event.b)\r\n    }, 3000)\r\n  })\r\n}\r\n复制代码在云函数中我们可以引入第三方依赖来帮助我们更快的开发。云函数的运行环境是 Node.js，因此我们可以使用 npm 安装第三方依赖。比如除了使用 Node.js 提供的原生 http 接口在云函数中发起网络请求，我们还可以使用一个流行的 Node.js 网络请求库 request 来更便捷的发起网络请求。\r\n注意，现在上传云函数时不会在云端自动安装依赖，需要开发者在本地安装好依赖后一起打包上传。\r\n云函数操作数据库\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  // 获取电影集合数据\r\n  return db.collection('movies').get()\r\n}\r\n复制代码云函数调用其他云函数\r\n\r\n定义云函数\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return await cloud.callFunction({\r\n    name: 'plus',\r\n    data: {\r\n      a: 1,\r\n      b: 2,\r\n    }\r\n  })\r\n}\r\n复制代码\r\n调用云函数\r\n\r\nwx.cloud.callFunction({\r\n  name: 'cloudFuncCallColundFunc',\r\n  complete: res => {\r\n    console.log('cloudFuncCallColundFunc', res)\r\n  },\r\n})\r\n复制代码云函数日志、测试\r\n可以看到调用的云函数的调用日志\r\n可以直接测试编写好的云函数，传入参数, 点击运行调试按钮即可\r\n云开发初体验总结\r\n云开发大概在8月份公测，9月份发布出来的，现在已经快11月份了，据官方描述，有很多开发人员参与进去，是他们没有预料到的， 同时也被提出了很多吐槽点，小程序的云开发也可以说是在试水阶段，有不少坑，后面肯定会越来越完善。 逐渐成熟，会是一个非常不错的解决方案， 特别是针对那些初创公司。作者：stupidWall链接：https://juejin.im/post/5bea4569e51d455d981bf43e"}
{"title": "Quikapp快应用【小程序】开发入门教程 ", "author": "Rolan", "pub_time": "2018-11-14 00:44", "article_content": "最近华为牵头国内几大厂商出了小程序Quikapp快应用，这里给大家编写快应用入门教程 首先记住几个网站1、官网：https://www.quickapp.cn 2、文档：https://doc.quickapp.cn/ 3、工具： 使用Visual Studio Code开发 使用WebStorm开发 教程地址（https://doc.quickapp.cn/tutorial/getting-started/code-edit-conf.html） 4.环境： 需安装6.0以上版本的NodeJS，请从NodeJS官网下载5.依赖库 hap-toolkit、hap-tools第一步：安装npm install -g hap-toolkit 安装第二步：hap脚手架生成一个初始项目hap init test1 初始化项目目录 这一步大家别急着npm run server 否则报一下错误报错第三步：安装依赖npm install第四步：运行服务npm run server image.png 还是失败，新出的东西官网还不是很完善，后面应该不会出现，这里花了几分钟找到了原因，项目少了hap-tools库， 这里没看到官网有这个库的介绍，package.json里也没 ap-tools 这个库的引入。 大家输入npm install hap-tools 手动安装下这个库。 安装 然后npm run server 开发者可以通过命令行终端或者调试服务器主页看到提供* 扫描的二维码 开发者通过快应用调试器扫码安装按钮，扫码安装待调试的rpk文件 开发者点击快应用调试器中的开始调试按钮，开始调试成功 完美快应用入门教程 给大家解释下目录说明├── sign rpk包签名模块 │ └── debug 调试环境 │ ├── certificate.pem 证书文件 │ └── private.pem 私钥文件 ├── src │ ├── Common 公用的资源和组件文件 │ │ └── logo.png 应用图标 │ ├── Demo 页面目录 │ | └── index.ux 页面文件，可自定义页面名称 │ ├── app.ux APP文件，可引入公共脚本，暴露公共数据和方法等 │ └── manifest.json 项目配置文件，配置应用图标、页面路由等 └── package.json 定义项目需要的各种模块及配置信息 大家像小程序一样，在这上面开发就好了。Quikapp快应用基于Nodejs内建一个本地服务器运行代码、语言JavaScript，语法支持ES6，如果熟悉vue\\weex一类的MVVM框架，基本可以直接入手。这一章是Quikapp快应用开发入门，有空补上下一章编写第一个快应用。Quikapp快应用、如何接入Bmob后端云？ 既然语言是JavaScript， 直接下载Bmob的JavaScript SDk引入，就可以直接操作后端数据库，配合云函数可以实现Quikapp快应用的接口对接。很快Bmob也会推出快应用的针对性SDK，这样云函数也不需要写了，跟小程序一样无需写一行后端代码，愉快的对接Quikapp快应用了。作者：微信小程序开发 链接：https://www.jianshu.com/p/eacb61ba1ef4"}
{"title": "小程序类似抖音视频整屏切换 ", "author": "Rolan", "pub_time": "2018-11-15 00:15", "article_content": "最近在项目中需要加一个功能，在小程序中将已有的短视频功能，按照抖音的方式来浏览，整屏，可上下滑动切换视频，并添加上滑下滑的动画。思路1.在video标签上添加时间监听。 2.如果1无法成功，就在video上面罩一层 cover-view，在cover-view上添加时间监听。 3.如果上面两种方法都不行，用小程序的onPageScroll页面处理函数来监听页面的滚动。 4.上述三种方法都不行的话，用canvas在video上面罩一层，监听滚动事件。尝试现在video标签上添加了触摸事件的监听，但是无法成功监听到触摸事件。 因为video 是原生组件，层级较高，所以尝试在上面罩一层cover-view，并监听滚动事件，但是同样无法监听。前面两种方法不行，我就采用了onPageScroll来监听页面是否发生滚动。这个方法会拿到当前页面在垂直方向已滚动的距离。scrollindex用来控制滚动，totalNum是滚动的总数，部分代码如下在ios上可以满足需求，能上下滚动，也能加上动画，但是在安卓上却不能动，尝试着在页面json文件中配置滚动相关，但都没办法，所以这个方法也不行了。最后只有canvas这一个办法了，在video组件上面定位一个canvas，在上面添加时间监听，这是发现成功了，可以在控制台看到打印出来的监听 console。实现wxml：下面是wxml代码，主要思路就是让video宽高等于屏幕，点赞评论分享等功能，用cover-view定位到视频上方，在将canvas定位到video上面滚动时滚动的是封面图案，video标签只有一个，滚动更改video的src。wxss:都是一些定位相关的样式没有特殊的样式就不贴图了。不过做的时候这里有个坑，产品希望添加无限的向下滑动视频，可以无限加载，所以最开始我才用的是animation动画，对每一屏根据手指向上或者向下添加动画，这样做的话就无法做到，后来发现可以使用小程序的api，wx.createAnimation()在js中实现。js：onload的时候this.animation = wx.createAnimation();用于切换时创建动画。需要监听的滚动事件js主要做的是判断滚动方向，给wxml通过微信提供的animation方法来动态添加动画，这样就可以实现无限加载的需求了。scrollTop的作用是用来调整video标签位置，因为现在滚动的时候添加滚动的事视频的封面图不是视频本身，需要隐藏视频，假如用wx:if；哎控制的话，会导致视频隐藏在展现之后无法监听之前添加的事件。效果在真机上可以生效，在手机上录了视频不知道怎么传上来，转gif也没找到在mac怎么转。。。最后弄了好久弄出来的，真机和模拟器的效果差异很大，最好在真机测试。目前也不知道有没有更好的办法，菜鸟前端一个～"}
{"title": "青铜选手带你动手撸一个博客小程序给自己（第二期） ", "author": "Rolan", "pub_time": "2018-11-15 00:28", "article_content": "上一篇的的的链接 赖了一个星期了，let us 接着上一篇的搞。在上一篇里搞了一下基础设施建设，这一篇我们...稍微搞那么一丢丢上层建筑。这一篇里本菜鸡想分享的tip小程序登陆逻辑与登陆状态维持的两种姿势发送评论时的一个投机倒把的小“优化”小程序微信登陆与前端登陆状态保存小程序登陆小程序登陆其实是个比较简单的基本操作，但凡是看过微信开发文档的应该都能懂，不过本菜鸡还是想尝试性的分享一下。首先先明确一下 为啥要用微信登陆 ，在本菜鸡看来在这个项目里使用微信登陆主要有三个目的方便用户 ：相比于用户手动注册、填写各种信息、再手动输入账号密码登陆，利用微信登陆用户点一下，就可以完成上面的全部操作，注册、登陆全都由后台利用微信提供的相关的信息完成方便后台用户管理使用微信的相关能力 ：通过微信登陆，后台可以获得唯一标识用户的openid，而这个openid，是后台调用微信相关敏感接口的必填项（例如：微信支付）然后，明确一下微信登陆过程中的几个概念然后，结合本次项目的实际情况捋一下微信登陆的流程调用wx.login方法获取code ，顺手调用一下wx.getUserInfo获取一下用户的基本信息（头像，微信名啥的）调用后端接口，将code与获取的用户信息userInfo（非必需）传递给后端。后端接收到参数，将code拿出来与存在后端的appid、appsecrect拼接成微信登陆链接$url='https://api.weixin.qq.com/sns/jscode2session?appid='.$this->appId.'&secret='.$this->appSecret.'&js_code='.$code.'&grant_type=authorization_code';\r\n复制代码访问该链接获得返回结果（json格式的），验证下是否成功，如果OJBK，就从结果里掏出openid$wxResult=json_decode(curl_get($url),true);\r\n if(!$wxResult||!array_key_exists('openid',$wxResult)){\r\n      return ResultService::failure('获取openid不成功');\r\n }\r\n $openId=$wxResult['openid'];\r\n复制代码其实获得到openid微信登陆已经差不多了，剩下就是怎么用的问题了，下面的步骤是在本次项目的流程，供各位老哥参考根据openid查一下数据库，看看是否是存在， 若存在 ，则说明是老用户，不用新增用户，直接用在步骤3中获取到的由前端传来的userInfo更新一下后台的用户信息即可（头像，省份，微信名啥的）。 若不存在 ，则这是个新用户，把openid与userInfo存到用户表中经过步骤5，库里已经有了这个用户的数据，然后拿用户数据，按照一定规则，生成个token返回给小程序端，小程序端把token存到localStorage里，后端将token与用户信息以键值对的形式存到缓存里，以后小程序请求的时候带着token来，后端根据token查缓存来确定用户登陆状态。至此，本项目中微信登陆的流程搞完了。登陆完的结果就是，后台新增或更新了用户数据，小程序端有了token。小程序登陆状态保持本菜鸡个人觉得常用的保持登陆状态的方法有两种token（个人推荐）session先说第一种，也是本项目采用的方法，其实在上面的步骤5、6已经把这个方法将清楚了，登陆后服务端下发token给小程序端，同时服务端自己也存一份，存哪里就根据实际情况（cache、redis、session啥的都行），然后搞个有效期，过期了就消失得那种。小程序每次请求后端接口的时候把token放到header里后端在处理请求前先把token从header里取出来，拿这个token去查缓存，如果有，就说明用户还在登陆状态，继续往后走，如果没有，则说明用户离线了，就直接返回一下告诉小程序端需要重新登陆，小程序收到后跳转到登录页。第二种也在做网站用户登陆的时候是非常常见的操作，在撸网站的时候，用户登陆后把用户信息存到session里，用户在请求的时候能够从session中取到用户信息，之所以这样是因为，浏览器请求服务器，服务器响应时，会带一个sessionid回去给浏览器，浏览器下次请求时候会自动带着sessionid，服务器会根据sessionid来到相应的会话里，所以能取到session中的用户BUT在小程序中有所不同，这是因为小程序网络访问是用的微信封装的wx.request，而该方法并不会把sessionid存下来，因此，为了能和网站登陆搞成一个逻辑，我们手动存一下sessionid，在下次请求的时候带着sessionid去即可。部分代码如下服务端（PHP）//前面先搞登陆，登陆完了把用户存到session里然后\r\nreturn ResultService::success('',['sessionId'=>session_id()]);\r\n\r\n复制代码小程序端//登陆\r\ndataUtils.userLogin({ code: code, info: JSON.stringify(info) }).then(res => {\r\n        if (res.statusCode == '200') {\r\n          wx.setStorageSync('sessionId', res.data.data.sessionId);\r\n          $Message({\r\n            content: '登陆成功',\r\n            type: 'success'\r\n          });\r\n          this.checkUserLogin();\r\n        }\r\n        else {\r\n          $Message({\r\n            content: '登陆未成功',\r\n            type: 'error'\r\n          });\r\n        }\r\n//请求例子（不同后端header名不一样，比如php的后端就是 PHPSESSID=你的sessionId）\r\nfunction userJoinPromise(data,sessionId){\r\n  let url = 'travel/api/userJoin';\r\n  return getServerDataPromise(url, data, { 'Cookie': 'PHPSESSID=' + sessionId });\r\n}\r\n复制代码下班了下班了，先写到这明天继续撸"}
{"title": "微信小程序之canvas 文字断行和省略号显示 ", "author": "Rolan", "pub_time": "2018-11-15 00:42", "article_content": "文字的多行处理在dom元素中很好办。但是canvas中没有提供方法，只有通过截取指定字符串来达到目的。那么下面就介绍我自己处理的办法：wxml：<canvas canvas-id='word' id='test'></canvas>canvas肯定要一个画板容器啦，记得设置宽高哦，小程序中默认宽高是300px和150pxjs：在page中//处理文字多出省略号显示\r\n    dealWords: function (options) {\r\n        options.ctx.setFontSize(options.fontSize);//设置字体大小\r\n        var allRow = Math.ceil(options.ctx.measureText(options.word).width / options.maxWidth);//实际总共能分多少行\r\n        var count = allRow >= options.maxLine ? options.maxLine : allRow;//实际能分多少行与设置的最大显示行数比，谁小就用谁做循环次数\r\n            \r\n        var endPos = 0;//当前字符串的截断点\r\n        for (var j = 0; j < count; j++) {\r\n            var nowStr = options.word.slice(endPos);//当前剩余的字符串\r\n            var rowWid = 0;//每一行当前宽度    \r\n            if (options.ctx.measureText(nowStr).width > options.maxWidth) {//如果当前的字符串宽度大于最大宽度，然后开始截取\r\n                for (var m = 0; m < nowStr.length; m++) {\r\n                    rowWid += options.ctx.measureText(nowStr[m]).width;//当前字符串总宽度\r\n                    if (rowWid > options.maxWidth) {                        \r\n                        if (j === options.maxLine - 1) { //如果是最后一行\r\n                            options.ctx.fillText(nowStr.slice(0, m - 1) + '...', options.x, options.y + (j + 1) * 18);    //(j+1)*18这是每一行的高度        \r\n                        } else {\r\n                            options.ctx.fillText(nowStr.slice(0, m), options.x, options.y + (j + 1) * 18);\r\n                        }\r\n                        endPos += m;//下次截断点\r\n                        break;\r\n                    }\r\n                }\r\n            } else {//如果当前的字符串宽度小于最大宽度就直接输出\r\n                options.ctx.fillText(nowStr.slice(0), options.x, options.y + (j + 1) * 18);\r\n            }\r\n        }\r\n    },（1） measureText（）.width 这是小程序 测量文本尺寸信息的方法，目前仅返回文本宽度。这里是官方说明（2） (j + 1) * 18   中18表示每一行行高是18，这是我自己定义的行高如果这个数值小于定义的字体大小，多半会出现两行文字重叠的现象，前面的 j+1 表示当前是多少行。整体表示当前行与上一行相比需要加多少距离（3） 在 j===options.maxLine-1 这个表示最后一行的处理情况里面   有slice(0，endPos-1)，为什么这里要减一，是因为省略号也要占宽度，大概是11.5的样子，所以要减掉这个省略号的宽度。因为一般中文字符宽度都和设置的字体大小差不多。如果是英文就要小一点，这里就没有考虑这么精细了。反正减一就是精确度的意思。。。可以自行多减或者少减（4） endPos += m 表示下一次截断的时候是从哪里开始。因为每次去截字符串都是最初的字符串，并没有真正意义上的截断一次之后就是剩下的字符串了，所以要把每次截断的点和上一次截断的点加上，才是最新一次字符串截断的位置。（5） 循环和判断使用的有点多，不知道对性能有没有影响。。。。。。调用的时候：var ctx = wx.createCanvasContext('word');\r\nvar name='窗前明月光，疑是地上霜，举头望明月，低头思故乡。';\r\nthis.dealWords({\r\n    ctx: ctx,//画布上下文\r\n    fontSize: 16,//字体大小\r\n    word: name,//需要处理的文字\r\n    maxWidth: 100,//一行文字最大宽度\r\n    x: 0,//文字在x轴要显示的位置\r\n    y: 0,//文字在y轴要显示的位置\r\n    maxLine: 3//文字最多显示的行数\r\n})\r\nctx.draw(); （1） 这个方法能够处理一行或者多行的情况，就看maxLine设置的大小了。当然如果设置maxLine为0或者-1，就会不显示的。。。看一下效果：（1） canvas我设置的是200 * 200的大小，其它的设置就是上面调用的时候设置的（1） 这是当maxWidth设置为200px的时候的显示情况。 完成 (＾－＾)V"}
{"title": "论如何将 h5 页面快速转换成微信小程序 ", "author": "Rolan", "pub_time": "2018-11-16 00:32", "article_content": "微信小程序自开放出来到现在也有一段时间了，相信其底层架构也被琢磨得差不多了。微信小程序本身是双线程运行的结构，而 h5 页面是单线程的运行模式，因此两者无法直接互通。微信小程序的运行模式如下：微信小程序本身提供了 web-view 组件来支持在微信小程序中嵌入 h5 页面，但是 web-view 组件在使用上还是有一些限制：不支持个人类型与海外类型的小程序、不支持全屏、页面与小程序通信不方便、很多小程序接口无法直接调用等。如果无法使用 web-view，这里还有一条路可以走，利用 h5-to-miniprogram 工具来将 h5 页面转换成小程序。起步假设你已经有一个 h5 页面，包含四个文件：h5 页面\r\n   |---- index.html\r\n   |---- index.css\r\n   |---- index.js\r\n   |---- index.png\r\n复制代码这种结构我们再熟悉不过了，具体每个文件的内容可参考这里： github.com/wechat-mini…。页面渲染出来的效果如下：页面很简单，但是值得一提的时，这个页面引入了 jQuery 库，所以 index.html 和 index.js 是这样的：<!doctype html>\r\n<html lang=\"zh\">\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\">\r\n    <meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\r\n    <meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\r\n    <meta name=\"format-detection\" content=\"telephone=no, email=no\">\r\n    <title>demo</title>\r\n    <style type=\"text/css\">\r\n      html, body {\r\n        width: 100%;\r\n        height: 100%;\r\n      }\r\n    </style>\r\n    <link rel=\"stylesheet\" href=\"./index.css\">\r\n  </head>\r\n  <body>\r\n    <img class=\"logo\" src=\"./index.png\">\r\n    <div class=\"cnt\"></div>\r\n    <script src=\"https://juneandgreen.github.io/test/h5-to-miniprogram-demo/demo2/js/jquery-1.12.4.min.js\"></script>\r\n    <script src=\"./index.js\"></script>\r\n  </body>\r\n</html>\r\n复制代码$(document).ready(function() {\r\n  $('.cnt').text('h5 to miniprogram');\r\n});\r\n复制代码微信小程序里是不暴露 dom/bom 接口的，说想要使用 jQuery 是非常困难的。尽管难以置信，但是确实是有办法的，后面会简述一下原理，让我先继续看下要如何操作。配置因为运行环境的不同，为了在编译时和运行时对两者进行一些兼容操作，我们需要一份配置文件：module.exports = {\r\n  index: 'h5', // 首页\r\n  urlMap: { // 每个页面对应的初始 url\r\n    h5: 'https://weixin.qq.com/index?a=1&b=2#hash',\r\n  },\r\n  resFilter(src, pageKey) {\r\n    // 资源过滤，用于替换 h5 中使用到的资源路径\r\n    return pageKey === 'h5' && src === './index.png' ? 'https://raw.githubusercontent.com/wechat-miniprogram/h5-to-miniprogram-demo/master/h5/index.png' : src\r\n  },\r\n}\r\n复制代码配置文件很简单，就是一个 js 文件，里面包含各种配置项。例如 index 配置项用于配置首页； urlMap 用于配置每个页面的初始 url，这个 url 会被解析到 window.location 中，通常用于页面跳转或单页系统中； resFilter 配置项用于调整资源路径，这里是因为考虑到微信小程序包大小有限制，默认不会去处理图片等资源，所以需要提供一个方法来替换资源路径为网络路径。因为配置文件需要拷贝到微信小程序项目中执行，所以配置文件必须是一个纯净的没有额外依赖的文件（比如 require('fs') 在配置文件中是不允许的）。构建生成有了原始的 h5，有了配置文件，那就可以开始进行转换并生成微信小程序项目了。我们来编写一个构建脚本，起名为 build.js：const path = require('path')\r\nconst toMiniprogram = require('h5-to-miniprogram')\r\n\r\ntoMiniprogram({\r\n  entry: { // 入口 h5 页面路径\r\n    h5: path.join(__dirname, './h5/index.html'),\r\n  },\r\n  output: path.join(__dirname, './miniprogram'), // 输出目录\r\n  config: path.join(__dirname, './config.js'), // 配置文件路径\r\n}).then(res => {\r\n  console.log('done')\r\n}).catch(err => {\r\n  console.error(err)\r\n})\r\n复制代码构建脚本也很简单，引入 h5-to-miniprogram 工具，此工具直接暴露一个 async 方法，调用时将必须的参数传入即可。可以看到参数中的入口配置是一个 key-value 对象，这里的 value 不能理解，就是页面的路径，key 则是页面的名称。例子中这个页面的 key 就是 h5，我们回到上面的配置文件那里就会发现，很多个地方都需要用到这个 key，这个 key 可以作为页面的唯一标识。写完构建脚本后，后续就简单很多了，执行：node build.js\r\n复制代码然后就会看到构建脚本中指定的输出目录—— miniprogram 目录被生成出来。完整的 demo 在这里： github.com/wechat-mini…使用使用官方提供的开发者工具打开 miniprogram 目录，可以看到已经基本达到我们想要的效果了：原理原理其实很简单，h5 页面在浏览器运行的过程就是解析 html 到渲染 dom 树的过程，然后提供一些 dom/bom 接口给 js 调用。那么在小程序中我们把这一套给模拟一遍就行了，方法很暴力，但是却意外的有效：因为给 h5 页面提供了类似浏览器的环境，实现了最底层的适配，所以理论上来说那些通用的框架和库也能支持运行。上面的例子中就表明了 jQuery 是能够运行的，像 react、vue 也是可以做到支持的。微信小程序是双线程的运行模式，视图层专注于渲染，逻辑层专注于逻辑。逻辑层是在一个纯净的 js 线程中跑，那里没有 dom/bom 接口，只能运行页面逻辑层的代码。要模拟浏览器环境，最基本的就是要在逻辑层里模拟出一棵 dom 树，本质上和建立一棵虚拟树类似，因为它并不是真实的 dom 树。整个流程简单来说是这样的：不管是页面中的静态 html 内容还是使用 innerHTML 等接口动态插入的 html 内容都可以走上面的流程来进行 dom 树的创建。dom 树创建比较简单，只是细节比较多，此处的关键是将创建好的 dom 节点映射到微信小程序的自定义组件，利用自定义组件的特性可以轻易的将我们创建好的 dom 树给渲染出来。如果你还不清楚微信小程序的自定义组件是什么的话，可以戳官方文档了解一下。"}
{"title": "小程序云开发之踩到狗尾巴 ", "author": "Rolan", "pub_time": "2018-11-19 00:05", "article_content": "前段时间用了下快狗打车，感觉贼方便，师傅响应速度和服务态度都特别好，搬个家再也没有以前那么痛苦了，女票也是给了大大的赞。正好最近毕业设计选题跟这个类似，参考了云开发文档，真心感觉云函数，云数据库，快且好用，立马开写，快快搞定毕设，好好工作（欢迎hr小姐姐楼层回复撩我）。不料，快速云开发之快狗毕设项目，犹如踩上了狗尾巴，坑坑真多，给各位像我一样，要快速写毕设，快速听女票话搬家的同学，记录一下。先给你们看下运行效果：一、程序骨架的基本构建1.功能的完整实现做个东西首先就是要把它的基本功能实现了，这个是毋庸置疑的。如果你是自己准备做个自己的小 程序，那么你肯定要对自己的小程序应该实现怎样的功能了如指掌，在心里应该把实现功能的流程 预演个几百遍了。这里第一个坑就出现了，我做的那会可没有想这么多，毕竟作为一个愣头青，莽 就完事了，从想法出来到开始动手时间不到1个小时，事实证明这是非常非常不可取的，也充分暴露 了我经验的不足。如果你不想像我一样写到后面一步一坑的话，最好提前想好。2.页面的基本构建作为一个较大的项目，主页结构应该做到结构清晰，语义化良好，尽量使用BEM命名规范，当然你要 是想你的代码写完后自己都看不懂，你就瞎**命名当我没说。整个页面大概采用什么布局也要事先 想想清楚，当然手机端一般都是弹性布局比较好，让你的页面元素可大可小，完美适配不同尺寸的 手机。布局的时候千万不要舍不得用盒子，如果把布局比作是整理衣柜的话，当你的衣服足够 多的话，一两个衣柜显然是无法满足条件的，你的衣服将被堆在一起，凌乱不堪。但是如果你有足 够的衣柜来放置衣服的话，你的衣服将被分门别类放置的整整齐齐。在本小程序中，主页的弹性布 局是将地图部分设置为 flex:1 ，让地图高度随手机大小来变化，而其他部分保持不变来实现的。 但是在实际运行中，却总是出现各种问题，最终我的解决办法是再在页面中总出问题的部分加入了 一个盒子，又在弹性布局里嵌套了一个弹性布局，这样首页的适应性布局就完美实现了。3.数据库的设计云开发的发布，让后端对于数据的操作变的更简单了。微信小程序本质上是数据驱动页面，所以你 想在页面上展示什么，就设置一个对应的数据去关联。然后当我们想改变页面的时候，只需要改动 数据就可以了。由于我这个小程序数据比较简单，并没有把所有的数据都放在云端，我只建立一张 订单表orders。因为订单里展示的信息不多所以只有‘时间’‘发货地’‘收货地’‘价格’几个属性，‘isdone’是用来标 记订单是否完成的，表现在页面中就是订单状态会显示‘已完成’或者‘已取消’4. 选个好组件库这个不是必须的，但是有时候选择到一个适合的组件库用起来真的爽，可以让你的开发事半功倍 我选的是vant(这个我选的就不是很好)，希望你能选上一个让你用完发出一句真香感慨的。二、程序功能的基本实现如果你已经完成了上面的前三步，那你简直比我好太多了！剩下的只不过是将功能一个一个添加上 去罢了。由于本程序的实现使用了大量api，我不会去把这些api一个个详细讲解，这样纯粹是浪费 时间。但是我会把一些实现想法和一些我遇到的坑像大家说明，避免你们像我一样踩坑。1. 实时获取点的坐标并将地址显示在页面仔细看了演示图的同学会发现当我移动地图时，起点的地址是在实时发生变化的，当我停止拖动 地图时，起点的地址就会更新到最新点。那么这个功能是如何实现的呢？其实这里是有一点巧妙的。实际上我用cover-image在地图上标记了一个起点，这个点是一直垂直居中固定在地图的中心的 。这样我只需要获取这个中心点的坐标并使用逆地址解析就能得到这个点的位置描述啦，是不是有 点巧妙。而怎么获取中心点的坐标和完成逆地址解析呢，当然这一切都有腾讯爸爸提供给我们的ap i去完成了。这里有个注意的点就是我们应在用户松开时来显示更新后的地址，bindregionchang这 个可以做到，当 e.type = end 时再显示就可以了，细节虽然小，但是还是不能忽视了。2. 输入地址时要能有模糊搜索提示这个效果主要依赖于腾讯地图小程序jsSDK中的输入关键词提示，调用这个接口我们将可以在返回 值中拿到一个数组，里面包含着我们需要的各种信息。拿到数据是很简单的，但是如何处理它呢？ 这个数组的长度是不固定的，其实很简单我们只需要将拿到的数据setData给一个我们定义的空数 组searchresult，这样所有的数据就到了这个数组里，到时候再去页面上循环这个数组，这样我们 就可以将里面的数据都拿出来并让它们显示在它们该显示的地方，所以这部分的关键在wxml里，下 面是我写的：<view class=\"content\">\r\n  <scroll-view class=\"scrollcontent\" scroll-y style=\"height: {{scrollheight}}rpx;\">\r\n    <block wx:for=\"{{searchresult}}\" wx:key=\"index\">\r\n      <van-cell-group border=\"{{true}}\">\r\n        <van-cell class=\"resultlist\" title=\"{{item.title}}\" border=\"{{true}}\" data-title=\"{{item.title}}\"\r\n        data-location=\"{{item.location}}\" icon=\"location\" label=\"{{item.address}}\" bind:click=\"getlistvalue\"/>\r\n      </van-cell-group>\r\n    </block>\r\n  </scroll-view>\r\n</view>\r\n复制代码3.主页车型切换并带来价格的变化这个需求是让顾客可以自由选择车型，这个有点类似滴滴打车的‘快车’'拼车'‘优享’。刚开始做的 时候我以为这是一个scroll-view和scroll-into-view配合来实现的。等到我把一切基本都实现了的 时候，最后一个效果就是实现滑动切换时划过一定距离就自动进入下一页，不够据距离就回弹。我 想了很多方法来判断，各种js判断各种利用scroll-left都搞不定。直到我无意中在官方文档中看到 了swiper这个组件，这丝般顺滑的滑动切换，距离够了自动下一页，不够就回弹，这不就正是我所 需要的吗，于是我直接删了原来的代码，花了不到半个小时就撸完了这个小组件（核心在于判断cur renttab与index是否相等，注意这个index后面还有大用）。看到这完美效果的我不禁泪流满面。所 以这件事告诉我们当你一直搞不定某个效果时，你应该静下心来想想是不是你开始就弄错了方向， 避免做无用功，浪费时间。接下来奉上我完美实现的代码(wxml和js部分)：wxml:<view class=\"container\">\r\n    <view class=\"container-header\">\r\n    <view class=\"carLists {{currentTab === index ?'on': ''}}\" wx:for=\"{{carName}}\" wx:key=\"index\" data-id=\"{{item.id}}\" data-index=\"{{index}}\" bindtap=\"switchTab\">\r\n      {{item.name}}\r\n    </view>\r\n    </view>\r\n    <block wx:if=\"{{index>0}}\">\r\n        <van-icon name=\"arrow-left\" class=\"arrow-left\" bind:click=\"last\" />\r\n    </block>\r\n    <block wx:if=\"{{index<3}}\">\r\n        <van-icon name=\"arrow\" class=\"arrow\" bind:click=\"next\" />\r\n    </block>\r\n    <swiper class=\"carList\" current=\"{{currentTab}}\" bindchange=\"swiperChange\">\r\n      <block wx:for=\"{{cars}}\" wx:key=\"index\">\r\n        <swiper-item class=\"carview\">\r\n          <image class=\"carImg\" src=\"{{item.image}}\" mode=\"aspectFill\"/>\r\n        </swiper-item>\r\n      </block>\r\n    </swiper>\r\n  </view>\r\n复制代码js:switchTab:function(e){\r\n      if (this.data.currentTab === e.target.dataset.index) {\r\n        return;\r\n    } else {\r\n        this.setData({\r\n            currentTab: e.currentTarget.dataset.index,\r\n            index:e.currentTarget.dataset.index\r\n        })\r\n    }\r\n  },\r\n  \r\n  \r\n  swiperChange:function(e){\r\n    // console.log( e.detail)\r\n    if(e.detail.source == 'touch'){\r\n      this.setData({\r\n        currentTab: e.detail.current,\r\n        index:e.detail.current\r\n    })\r\n    }\r\n   \r\n  },\r\n    next:function(e){\r\n      // console.log(this.data.currentTab,this.data.currentTab)\r\n       if (this.data.currentTab === this.data.index && this.data.currentTab <3 ) {\r\n          this.setData({\r\n            currentTab:this.data.currentTab + 1,\r\n            index:this.data.index +1\r\n          })\r\n        }\r\n       \r\n    },\r\n  \r\n    last:function(e){\r\n      if (this.data.currentTab === this.data.index && this.data.currentTab > 0 ) {\r\n        this.setData({\r\n          currentTab:this.data.currentTab - 1,\r\n          index:this.data.index -1\r\n        })\r\n      }\r\n    }\r\n复制代码4.关于距离及价格的计算之前在输入起点和终点的时候我们可以通过腾讯地图的api拿到两者的具体坐标，这里我采用的距 距离计算没有采用腾讯地图所提供的api(因为有距离限制，仅限10km以内)，这个距离对于我们来说 无疑是太短了，于是我采取了一个通用公式，只要能有两地坐标，便可以算出两地间的距离，这样 一来我们的老司机们就不用再受到距离的限制了。//计算两坐标点之间的距离\r\n      distance: function (lat1, lng1, lat2, lng2) {\r\n        const rad1 = lat1 * Math.PI / 180.0;   \r\n        const rad2 = lat2 * Math.PI / 180.0;   \r\n        const a = rad1 - rad2;   \r\n        const b = lng1 * Math.PI / 180.0 - lng2 * Math.PI / 180.0;  \r\n        const r = 6378137;\r\n        const distance = (r * 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(rad1) * Math.cos(rad2) * Math.pow(Math.sin(b / 2), 2)))).toFixed(0)\r\n        return distance / 1000;//单位转化为公里\r\n      }\r\n复制代码现在我们拿到了距离，但是怎么能让价格根据所选车型来动态变化呢？还记得之前页面里给每个 滑块的index吗？这里我们恰好就可以用它来做一个switch判断，给getPrice函数传入一个index 参数判断不同值并给出不同的计价方式，这样一来价格变会随着车型的切换而变化了。最后我们 的效果就达到了。5.订单完成数据的上传及拉取有了云开发之后数据库的操作简直不要太简单了！取消订单时，在选择完取消订单理由后，们 将向云数据库添加一条数据，只需几条命令我们就可以将我们的数据真正的存在数据库里并保存起 来，听上去是不是很心动呢wx.cloud.init();//初始化\r\nconst db = wx.cloud.database();\r\nconst cancelOrder = db.collection('orders')//orders为手动在云数据库里添加的一张空表\r\n//三步操作后我们就连上了我们的数据库\r\n    cancelOrder.add({\r\n      data:{\r\n        time:globalData.time,\r\n        shipAddr:globalData.address,\r\n        receiveAdrr:globalData.receiveAdrr,\r\n        price:globalData.price,\r\n        isdone:false\r\n      }\r\n    })\r\n复制代码这样订单数据就被我们添加到了数据库里，可以被我们随时访问了。然后在通过一条简单的查 询语句就可以在我的订单里显示了。orders.where({\r\n      _openid:'xxxxxxxx'//用户的openid\r\n    }).get({\r\n      success: res=> {\r\n        this.setData({\r\n          orders:res.data\r\n        })\r\n        // console.log(res.data)\r\n        wx.hideLoading();//加载完成关闭加载框\r\n      }\r\n    })\r\n复制代码最后在页面上循环输出orders里的值就可以得到一堆订单了写在最后一个完整项目的实现确实不是那么简单的，即使是一个简单流程的实现，很多看似简单的东西 里经常藏着大坑，而不同页面之间的联系也是很让人头痛的，我们要从之前那种局部的眼光中跳脱 出来，从更大的层面来看待构建我们的项目骨架。使用组件化，函数化的编程思想可以很好的帮助 我们降低代码的耦合性，增加代码的复用性，使我们的代码结构更清晰。写本篇文章的目的是为了 方便自己以后重构项目的时候看，也是为了给有跟我一样想法，跃跃欲试想撸个完整项目的同学一 个参考，少踩一些坑。最后有什么建议或者文中有什么错误的地方欢迎在评论中指出，互相学习， 共同进步！这是我在掘金发的第一篇文章，看完觉得还不错的同学点个赞再走吧！完整项目点这： 项目地址主要参考:快狗打车拉货搬家微信小程序微信小程序官方文档： developers.weixin.qq.com/miniprogram…腾讯地图api文档： lbs.qq.com/qqmap_wx_js…vant Weapp小程序ui组件库： youzan.github.io/vant-weapp/…"}
{"title": "小程序生命周期分析与注册流程回调 ", "author": "Rolan", "pub_time": "2018-11-19 00:21", "article_content": "从小程序发布到现在，官方api 变动了好几个版本\r\n首先我们先看一下小程序的生命周期\r\napp.js 为小程序的启动入口文件\r\nonLauch: 小程序初始化回掉，生命周期内只执行一次\r\nonShow: 小程序打开或者从后台唤起时的回调\r\nonHide: 小程序从前台进入后台时\r\nonError: 小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息\r\n页面生命周期：\r\nonLoad:注册页面的时候执行，只执行一次\r\nonShow: 页面在前台展示时执行，显示一次执行一次\r\nonReady: 页面初次渲染完成时执行，冷启动时不执行\r\nonHide: 页面从前台进入后台\r\nonUnload: 页面注销时执行\r\n个人觉得 小程序app中应该增加一个onUnload周期，页面的销毁现实场景个人还没有使用到\r\n===========================================\r\n下面我们来看一下 小程序的注册流程\r\n\r\n针对小程序开发者看下图\r\n\r\n1. 检查是否是登陆接口\r\n2. 判断session\r\n3. wx.login--》获取token\r\n4. 执行原有回掉\r\n好处：让后续开发者 忽略登陆流程逻辑\r\nfunction doLogin(callback, obj) {\r\n    if (obj.isLogin) {\r\n        // 登录接口，直接放过\r\n        // 直接放过，让其走下去\r\n        typeof callback === \"function\" && callback();\r\n    } else if(session) {\r\n        // 缓存中有session\r\n        if(sessionExpireTime && new Date().getTime() > sessionExpire) {\r\n            // 如果有设置本地session缓存时间，且缓存时间已到\r\n            session = '';\r\n            doLogin(callback, obj);\r\n        } else {\r\n            typeof callback === \"function\" && callback();\r\n        }\r\n    } else if (logining) {\r\n        // 正在登录中，请求轮询稍后，避免重复调用登录接口\r\n        flow.wait('doLoginFinished', function () {\r\n            doLogin(callback, obj);\r\n        })\r\n    } else {\r\n        // 缓存中无session\r\n        logining = true;\r\n        obj.count++;\r\n        // 记录调用wx.login前的时间戳\r\n        // 执行login 获取code\r\n        obj._loginStartTime = new Date().getTime();\r\n        console.log('wx.login');\r\n        wx.login({\r\n            complete: function () {\r\n                obj.count--;\r\n                // 记录wx.login返回数据后的时间戳，用于上报\r\n                obj._loginEndTime = new Date().getTime();\r\n                if (typeof reportCGI === \"function\") {\r\n                    reportCGI('wx_login', obj._loginStartTime, obj._loginEndTime, request);\r\n                }\r\n                typeof obj.complete === \"function\" && obj.count == 0 && obj.complete();\r\n            },\r\n            success: function (res) {\r\n                if (res.code) {\r\n                    var data;\r\n                    // codeToSession.data支持函数\r\n                    // 上传服务器操作\r\n                    if (typeof codeToSession.data === \"function\") {\r\n                        data = codeToSession.data();\r\n                    } else {\r\n                        data = codeToSession.data || {};\r\n                    }\r\n                    data[codeToSession.codeName] = res.code;\r\n\r\n                    obj.count++;\r\n                    requestWrapper({\r\n                        url: codeToSession.url,\r\n                        data: data,\r\n                        method: codeToSession.method,\r\n                        isLogin: true,\r\n                        report: codeToSession.report || codeToSession.url,\r\n                        success: function (s) {\r\n                            session        = s;\r\n                            sessionIsFresh = true;\r\n                            // 如果有设置本地session过期时间\r\n                            if(sessionExpireTime) {\r\n                                sessionExpire = new Date().getTime() + sessionExpireTime;\r\n                                wx.setStorage({\r\n                                    key: sessionExpireKey,\r\n                                    data: sessionExpire\r\n                                })\r\n                            }\r\n                            // 执行回掉\r\n                            typeof callback === \"function\" && callback();\r\n                            wx.setStorage({\r\n                                key: sessionName,\r\n                                data: session\r\n                            })\r\n                        },\r\n                        complete: function () {\r\n                            obj.count--;\r\n                            typeof obj.complete === \"function\" && obj.count == 0 && obj.complete();\r\n                            logining = false;\r\n                            flow.emit('doLoginFinished');\r\n                        },\r\n                        fail: codeToSession.fail || null\r\n                    });\r\n                } else {\r\n                    fail(obj, res);\r\n                    console.error(res);\r\n                    // 登录失败，解除锁，防止死锁\r\n                    logining = false;\r\n                    flow.emit('doLoginFinished');\r\n                }\r\n            },\r\n            fail: function (res) {\r\n                fail(obj, res);\r\n                console.error(res);\r\n                // 登录失败，解除锁，防止死锁\r\n                logining = false;\r\n                flow.emit('doLoginFinished');\r\n            }\r\n        })\r\n    }\r\n}\r\n复制代码处理页面登陆交互的两种方式\r\n1. app.js 注册回掉函数，进入page 注册这个回掉函数，登陆完成执行app.logincallback\r\npage.js\r\nconst app = new getApp()\r\nonLoad(){\r\n    app.loginCallback = () => {\r\n        this.init()\r\n    }\r\n}\r\n\r\n复制代码这种方式可以，而且具有页面控制的灵活性，但灵活性带来的就是出错的几率会增大很多\r\n2. 在login页面获取登陆的前一个页面，然后登陆完成后刷新前一个页面状态\r\nlogin.js\r\n\r\nwerequest.login().then(function(){\r\n    let pages = getCurrentPages();\r\n    let Page = pages[pages.length - 1];//当前页\r\n    let prevPage = pages[pages.length - 2];  //上一个页面\r\n    prevPage.onLoad()\r\n})\r\n复制代码个人比较提交这种方式，因为其他页面只需要处理自己的页面逻辑就可以作者：liuzimu链接：https://juejin.im/post/5be53958e51d450b3647e7ae"}
{"title": "微信小程序之店铺评分组件及vue中用svg实现的评分显示组件 ", "author": "Rolan", "pub_time": "2018-11-19 00:32", "article_content": "1.效果图微信中的可以点击及显示，但是，显示的话，在4.2分，4点多分的时候，显示的是半颗星vue中用的是svg实现，所以用的是占比的形式,可以有一点点的星星星图片2.微信实现店铺评分显示及商品评价星星展示子组件index.wxml，可以动态的控制星星的大小<!-- (size * stars.length + (size/2) * 4 + 20 )这里的话，是在可以点击的时候，加上了好评的字体的长度 -->\r\n<view class='starsBox' style='width:{{isClick?(size * stars.length + (size/2) * 4 + 20 ):(size * stars.length)}}rpx;height:{{size}}rpx;'>\r\n  <view class='stars' style='width:{{size * stars.length}}rpx;height:{{size}}rpx;'>\r\n    <block wx:for=\"{{stars}}\" wx:key=\"{{index}}\">\r\n      <image src=\"/images/{{item == 0 ? 'grayStar':item}}.png\" style='width:{{size}}rpx;height:{{size}}rpx;' data-index=\"{{index}}\" catchtap=\"computeScore\"></image>\r\n    </block>\r\n  </view>\r\n  <view wx:if=\"{{isClick}}\" class='text' style='font-size:{{size/2}}rpx;'>\r\n    <text wx:if=\"{{value=='0'}}\" class='pointText'>暂无评分</text>\r\n    <text wx:elif=\"{{value=='1'}}\" class='pointText'>差评</text>\r\n    <text wx:elif=\"{{value<'4'}}\" class='pointText'>中评</text>\r\n    <text wx:else class='pointText'>好评</text>\r\n  </view>\r\n</view>子组件index.wxss.starsBox{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: flex-start;\r\n}\r\n.stars{\r\n  width: 150rpx;\r\n  height: 50rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: flex-start;\r\n}\r\n.stars image{\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n}\r\n.text{\r\n  color: #ccc;\r\n  margin-left: 20rpx;\r\n}子组件index.jsComponent({\r\n  properties: {\r\n    /* 显示有色星星的个数 */\r\n    value: {\r\n      type: Number,\r\n      value: 0,\r\n      /* 监听value值的变化 */\r\n      observer: function (newVal, oldVal, changedPath) {\r\n        this.init()\r\n      }\r\n    },\r\n    /* 设置星星大小 */\r\n    size: {\r\n      type: Number,\r\n      value: 30\r\n    },\r\n    /* 是否可点击，type为null表示值可以是任意类型 */\r\n    isClick: {\r\n      type: null,\r\n      value: false\r\n    }\r\n  },\r\n  attached() {\r\n    /* 组件生命周期函数，在组件实例进入页面节点树时执行 */\r\n    this.init();\r\n  },\r\n  data: {\r\n    stars: [0, 0, 0, 0, 0]\r\n  },\r\n  methods: {\r\n    init() {\r\n      let star = this.properties.value;\r\n      let stars = [0, 0, 0, 0, 0];\r\n      /* 图片名称，通过设置图片名称来动态的改变图片显示 */\r\n      for (let i = 0; i < Math.floor(star); i++) {\r\n        stars[i] = 'star';\r\n      }\r\n      if (star > Math.floor(star)) {\r\n        stars[Math.floor(star)] = 'halfStar';\r\n      }\r\n      for (let i = 0; i < stars.length; i++) {\r\n        if (stars[i] == 0) {\r\n          stars[i] = 'grayStar';\r\n        }\r\n      }\r\n      this.setData({\r\n        stars\r\n      })\r\n    },\r\n    /* 可点击时，用于计算分数 */\r\n    computeScore(e) {\r\n      let index = e.currentTarget.dataset.index;\r\n      let isClick = this.data.isClick;\r\n      if (isClick) {\r\n        let score = index + 1;\r\n        this.triggerEvent('compute', {\r\n          score\r\n        });\r\n      }\r\n    }\r\n  }\r\n})3.父组件中引用父组件index.wxml<view class=\"score\">\r\n    <view class=\"scoreItem\">\r\n        <score value=\"{{shopGrade}}\" size=\"46\" isClick=\"true\" bindcompute=\"computeGrade\" />\r\n    </view>\r\n    <view class=\"scoreItem\">\r\n        <score value=\"{{shopGrade1}}\" size=\"46\" />    \r\n    </view>\r\n</view>父组件index.json{\r\n    \"usingComponents\": {\r\n        \"score\": \"/component/score/index\"\r\n    }\r\n}父组件index.jsdata: {\r\n    shopGrade: 0,\r\n    shopGrade1: 4.6,\r\n},\r\n/* 评分处理事件 */\r\ncomputeGrade(e) {\r\n    let score = e.detail.score;\r\n    this.setData({\r\n        shopGrade: score\r\n    })\r\n},4.vue中使用svg实现评分首先在vue使用的index.html的模板文件中添加一个rem转换算法，因为我后面用的单位是rem/* 在头部添加 */\r\n<script type=\"text/javascript\">\r\n      document.getElementsByTagName(\"html\")[0].style.fontSize = 100 / 750 * window.screen.width + \"px\";\r\n    </script>然后添加svg.vue文件，这个svg文件可以自己找图片生成，并设置对应的id<template>\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"position:absolute;width:0;height:0;visibility:hidden\">\r\n        <defs>\r\n            <symbol id=\"star\" viewBox=\"0 0 32 32\">\r\n                <path class=\"path1\" d=\"M16 26.382l-8.16 4.992c-1.5 0.918-2.382 0.264-1.975-1.435l2.226-9.303-7.269-6.218c-1.337-1.143-0.987-2.184 0.755-2.322l9.536-0.758 3.667-8.835c0.674-1.624 1.772-1.613 2.442 0l3.667 8.835 9.536 0.758c1.753 0.139 2.082 1.187 0.755 2.322l-7.269 6.218 2.226 9.303c0.409 1.71-0.485 2.347-1.975 1.435l-8.16-4.992z\">\r\n                </path>\r\n            </symbol>\r\n        </defs>\r\n    </svg>\r\n</template>\r\n<script></script>\r\n<style></style>rating.vue文件引用svg.vue<template>\r\n    <div class=\"ratingstar\">\r\n        <section class=\"star_container\">\r\n            <svg class=\"grey_fill\" v-for=\"(num,index) in 5\" :key=\"index\">\r\n                <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#star\"></use>\r\n            </svg>\r\n        </section>\r\n        <div class=\"star_overflow\" :style=\"'width:'+rating*2/10+'rem'\">\r\n            <section class=\"star_container\">\r\n                <svg class=\"orange_fill\" v-for=\"(num,index) in 5\" :key=\"index\">\r\n                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#star\"></use>\r\n                </svg>\r\n            </section>\r\n        </div>\r\n        <svgIcon></svgIcon>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n  import svgIcon from '@/components/svg'\r\n  export default {\r\n    components: {\r\n      svgIcon\r\n    },\r\n    data() {\r\n        return {\r\n            rating: 4.2\r\n        }\r\n    },\r\n  }\r\n</script>\r\n<style lang=\"less\" rel=\"stylesheet/less\" scoped>\r\n    .ratingstar {\r\n        position: relative;\r\n        width: 100%;\r\n        .star_overflow {\r\n            overflow: hidden;\r\n            position: relative;\r\n            height: 0.65rem;\r\n        }\r\n        .star_container {\r\n            position: absolute;\r\n            top: 0.05rem;\r\n            width: 1rem;\r\n            display: flex;\r\n            justify-content: flex-start;\r\n            align-items: center;\r\n            .grey_fill {\r\n                width: 0.94rem;\r\n                height: 0.2rem;\r\n                fill: #d1d1d1;\r\n            }\r\n            .orange_fill {\r\n                width: 0.94rem;\r\n                height: 0.2rem;\r\n                fill: #ff9a0d;\r\n            }\r\n        }\r\n    }\r\n</style>都有用到组件，可以查看下方的推荐文章中的购物车中的父子组件传值正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端实现单行文字及多行文字的省略号微信小程序之购物车和父子组件传值及calc的注意事项纯css实现瀑布流（multi-column多列及flex布局）"}
{"title": "微信小程序多文件递归上传 ", "author": "Rolan", "pub_time": "2018-11-19 00:45", "article_content": "微信小程序官网社区有申明微信小程序无法多文件上传，所以要通过递归进行多文件上传。网上得上传例子都不满足我的要求，如下是我的代码，希望能给予参考。方法upload单文件上传 方法uploadFils多文件上传\r\n  export function uploadFils(url, filePathArr) {\r\n    return uploadFilsSync(url, filePathArr, 0, { success: [], fail: [] });\r\n  }\r\n\r\n  function uploadFilsSync(url, filePathArr, index, result) {\r\n    return upload(url, filePathArr[index++], {})\r\n      .then(res => {\r\n        result.success.push({ index: index, res: res });\r\n        if (index === filePathArr.length) {\r\n          return result;\r\n        } else {\r\n          return uploadFilsSync(url, filePathArr, index, result);\r\n        }\r\n      })\r\n      .catch(err => {\r\n        result.fail.push({ index: index, res: err });\r\n        if (index === filePathArr.length) {\r\n          return result;\r\n        } else {\r\n          return uploadFilsSync(url, filePathArr, index, result);\r\n        }\r\n      });\r\n  }\r\n  \r\n     export function upload(url, filePath, formData = {}) {\r\n    let header = { \"Content-Type\": \"multipart/form-data\" };\r\n    return new Promise((resolve, reject) => {\r\n      wx.uploadFile({\r\n        url: config.server + url,\r\n        header: header,\r\n        filePath: filePath,\r\n        name: \"file\",\r\n        formData: formData,\r\n        success(res) {\r\n          resolve(res.data);\r\n        },\r\n        fail: function(error) {\r\n          reject(error);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  返回结果：index:第几个上传文件,res做为上传结果\r\n\r\n{\r\n    \"success\":[\r\n        {\r\n            \"index\":1,\r\n            \"res\":{\r\n                \"data\":\"123\"\r\n            }\r\n        }\r\n    ],\r\n    \"fail\":[\r\n\r\n    ]\r\n}"}
{"title": "批量生成100万张小程序码？了解一下 ", "author": "Rolan", "pub_time": "2018-11-20 00:01", "article_content": "最近有一个生成很多小程序码的需求，生成的小程序码还要嵌入在指定的图片模板上，就去找轮子，没找到合适的轮子。。无奈之下就决定去撸一个。目前已经完成并发布npm。Github： github.com/Jon-Millent…需求如下图生成带参数的小程序二维码要指定尺寸和位置到模板图上要批量生成若干张开始干活生成带参数的小程序二维码通过官方文档，列出了生成小程序二维码的三种模式createWXAQRCode 获取 小程序二维码 ，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制。官方说明getWXACode 获取 小程序码 ，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制。官方说明getWXACodeUnlimit 获取 小程序码 ，适用于需要的码数量极多的业务场景。通过该接口生成的小程序码，永久有效，数量暂无限制。官方说明这些接口都要通过 access_token 来换取。让我们造个类let AngerWechat = require('anger-wechat') // 微信操作辅助库（自己写的）\r\n\r\nclass miniQrcode {\r\n\r\n   // 存放三种模式的接口\r\n   constructor(config) {\r\n        this.mode = {\r\n          'getWXACode': 'https://api.weixin.qq.com/wxa/getwxacode',\r\n          'getWXACodeUnlimit': 'https://api.weixin.qq.com/wxa/getwxacodeunlimit',\r\n          'createWXAQRCode': 'https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode',\r\n        }\r\n        \r\n        // 初始化微信辅助库\r\n        this.$wx = new AngerWechat({\r\n          appId: this.config.appId, // appId 必传\r\n          appSecret: this.config.appSecret, // appSecret 必传\r\n        })\r\n        \r\n        // 临时数据存放文件，用于存放access_token，因为access_token有2个小时的生存期，避免重复获取\r\n        this.databasePath = path.join(__dirname, '../', 'database.json')\r\n   }\r\n}\r\n复制代码实现核心方法// 生成核心方法\r\n    async getWxQrcodeInfo(concatConfig){\r\n        // 获取已经存放的文件里的access_token，如果有的话并且有效的话就不用再掉接口\r\n        let innerDatabase = this.getDatabase() \r\n        \r\n        // 如果本地的数据没有access_token 或者超过2个小时 就去请求获取\r\n        if(!innerDatabase.access_token ||  ((new Date().getTime() - innerDatabase.create_time) > 7200000) ) {\r\n            let accessInfo = await this.$wx.getGlobalAccessToken()\r\n            // 获取access_token然后写入文件\r\n            // 具体代码省略\r\n        }\r\n        \r\n        \r\n        // 获取到access_token去请求接口\r\n        \r\n        let qrcodeInfo  = await this.postMan(\r\n            this.getApiUrl(innerDatabase.access_token, concatConfig.mode), // 根据mode来区调用接口\r\n            concatConfig.config // 用户传的参数\r\n        )\r\n        \r\n        let returnData = {\r\n    \r\n        }\r\n    \r\n        if(qrcodeInfo.type.indexOf('image') !== -1) { //类型是图片的就是获取成功了\r\n          // 请求成功 保存图片\r\n          returnData = {\r\n            code: 200,\r\n            image: qrcodeInfo.data,\r\n            error: null\r\n          }\r\n        } else {\r\n          returnData = {\r\n            code: 500,\r\n            error: JSON.stringify(qrcodeInfo.data.toString()),\r\n            image: null\r\n          }\r\n        }\r\n    \r\n        return returnData\r\n    }\r\n复制代码写好后让我们测试一下let qrocode = new miniQrcode({\r\n      appId: 'xxx',\r\n      appSecret: 'xxx'\r\n    });\r\n    let info = await qrocode.getWxQrcodeInfo({\r\n\t  mode: 'getWXACode',\r\n\t  config: {\r\n\t    path: `pages/index/main?id=123456`\r\n\t  },\r\n\t})\r\n   fs.writeFileSync(`./output-juejin-test1.png`, info.image, 'utf8');\r\n复制代码效果：如何测试参数？我在这个已经发布的小程序里面加了个彩蛋，就是长按 红色圈出区域两次 即可调出控制台看参数将二维码合成到模板图片里面这个操作依赖于 sharp 库const sharp = require('sharp');\r\n\r\nclass miniSharp {\r\n\r\n  constructor(templateUrl){\r\n    this.templateUrl = templateUrl\r\n  }\r\n\r\n  // 重置图片大小\r\n  async resizeQrcode(imageBuffer, config){\r\n    return new Promise(resolve => {\r\n\r\n      sharp(imageBuffer).resize(config.width, config.width).toBuffer().then(function(outputBuffer) {\r\n        resolve(outputBuffer)\r\n      });\r\n\r\n    })\r\n  }\r\n  \r\n  // 合并图片\r\n  async concatImage(buffer, config){\r\n    return new Promise(resolve => {\r\n      sharp(this.templateUrl)\r\n        .overlayWith(buffer, {\r\n          top: config.top,\r\n          left: config.left\r\n        }).toBuffer().then(function(outputBuffer) {\r\n          resolve(outputBuffer)\r\n        });\r\n    })\r\n  }\r\n\r\n  // 主函数\r\n  async renderImage(qrcodeBuffer, config){\r\n\r\n    let resizeQrcodeBuffer = await this.resizeQrcode(qrcodeBuffer, config)\r\n    let concatQrocdeBuffer = await this.concatImage(resizeQrcodeBuffer, config)\r\n\r\n    return concatQrocdeBuffer\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = miniSharp\r\n\r\n复制代码测试一下let qrocode = new miniQrcode({\r\n      appId: 'xxxx',\r\n      appSecret: 'xxx'\r\n    });\r\n    \r\n    let mySharp = new miniSharp('./template.png');\r\n\r\n    let info = await qrocode.getWxQrcodeInfo({\r\n      mode: 'getWXACode',\r\n      config: {\r\n        path: `pages/index/main?id=123456`\r\n      },\r\n    })\r\n    \r\n    let renderBuffer = await mySharp.renderImage(info.image, // 二维码图片的 buffer 数组 \r\n    { \r\n      width: 200, // 重新设置二维码宽度\r\n      left: 362, // x轴偏移\r\n      top: 53 // y轴偏移\r\n    })\r\n    \r\n    fs.writeFileSync(`./output-juejin-test1.png`, renderBuffer, 'utf8');\r\n复制代码批量处理正常情况下，批量生成 100 张需要 62.556秒 ，平均每张需要 0.62556秒 ，1万张大概需要 1.73小时 。 批量示例代码关于调试使用微信开发者工具可以进行模拟参数调试测试接口这里我提供了一个测试接口，可以带参数生成线上的小程序码，用来调试[get] http://wx.toolos.cc 参数mode 必传 [createWXAQRCode | getWXACode | getWXACodeUnlimit] 之一注意其他参数对应上面的文档的 mode 对应的参数， path 或者 page 需要 encodeURIComponent一下目前小程序只有一个路径 pages/index/main线上服务器配置低示例http://wx.toolos.cc/?mode=createWXAQRCode&path=pages%2Findex%2Fmain\r\n复制代码关于参数模式createWXAQRCode & getWXACode这两种生成的参数，生成二维码数量有限，参数直接跟在path路径后面，例如：let info = await qrocode.getWxQrcodeInfo({\r\n  mode: 'createWXAQRCode',\r\n  config: {\r\n    page: `pages/index/main?sgr=521314&i=loveyou`\r\n  },\r\n})\r\n复制代码getWXACodeUnlimit这个可以生成无限个，但是只能携带有局限性的参数 scene ，在这里推荐一种解析方式 key:value-key:valuelet info = await qrocode.getWxQrcodeInfo({\r\n  mode: 'getWXACodeUnlimit',\r\n  config: {\r\n    page: `pages/index/main`,\r\n    scene: 'i:loveyou-sgr:521314'\r\n  },\r\n})\r\n复制代码解析示例onLoad (query) {\r\n  // scene 需要使用 decodeURIComponent 才能获取到生成二维码时传入的 scene\r\n  this.scene = decodeURIComponent(query.scene)\r\n  this.queryJson = JSON.stringify(query)\r\n\r\n  // 尝试解析  scene 格式: shop:1-id:2\r\n\r\n  try {\r\n    let oneArr = this.scene.split('-')\r\n    let twoJson = {}\r\n    for(let i=0; i<oneArr.length; i++) {\r\n      let target = oneArr[i].split(':')\r\n      twoJson[target[0]] = target[1]\r\n    }\r\n    this.twoJson = JSON.stringify(twoJson)\r\n\r\n  } catch(e) {\r\n    this.twoJson = e\r\n  }\r\n\r\n},\r\n复制代码在开发者工具中例如下面模拟"}
{"title": "微信小程序性能优化方案——让你的小程序如此丝滑 ", "author": "Rolan", "pub_time": "2018-11-4 23:42", "article_content": "首先，问一个问题，当用户点击小程序后发生了什么？上图中的三个状态，我们经常遇到，它们分别对应小程序的下面三个状态：有三个点的白屏（左侧）： 下载代码包的阶段没有三个点的白屏（中间）： 业务代码注入和渲染的阶段加载中（右边）： 业务代码中异步请求数据总的来说，小程序呈现到用户面前，实际上经历了下面两个阶段：运行环境的加载下载代码包下面具体介绍这两个阶段：运行环境预加载这步是微信做的。微信会在用户打开小程序之前就已经准备好环境，用户点击小程序入口后，直接下载小程序的代码包即可。下载代码包启动小程序小程序代码包里面的代码，不是小程序的源代码，而是编译、压缩、打包之后的代码包。下图中，左侧的“ 预加载 ”对应的是运行环境的预加载，右侧的“小程序启动” 对应的是下载代码包启动小程序。小程序提供的运行环境，分为逻辑层（AppService）和 视图层（webView），逻辑层是执行javascript的地方，视图层是渲染页面的地方。当小程序的代码包下载完毕后，业务代码分别注入逻辑层和渲染层。提升加载性能的最最最关键性一点是，控制包的大小，这个也是微信官方的说法。控制包的大小提升体验最直接的方法是 控制小程序包的大小 ，基本上可以说，1M的代码包，下载耗时1秒左右。控制包的大小的措施压缩代码，清理无用的代码图片放在cdn采用分包策略分包预加载独立分包（版本要求有点高）除了上面讲的控制包的大小，对异步请求的优化也很重要。对异步请求的优化onLoad 阶段就可以发起请求，不用等ready请求结果放在缓存中, 下次接着用请求中可以先展示骨架图先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再 发起异步请求。提升渲染性能setData 干了啥每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。渲染层收到通讯后，还需要重新渲染出来，所以，emmm, 一次setData带来两次开销：通信的开销 + webview更新的开销。在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。减少setData的数据量如果一个数据不能会影响渲染层，则不用放在setData里面合并setData的请求，减少通讯的次数这个很好理解吧列表的局部更新在一个列表中，有 n 条数据，采用上拉加载更多的方式，假如这个时候想对其中某一个数据进行点赞操作，还能及时看到点赞的效果此时，可以采用setData全局刷新，点赞完成之后，重新获取数据，再次进行全局重新渲染，这样做的优点是：方便，快捷！缺点是：用户体验极其不好，当用户刷量100多条数据后，重新渲染量大会出现空白期（没有渲染过来）如果采用布局刷新，将点赞的 id 传过去，知道点的是那一条数据, 将点赞的 id 传过去，知道点的是那一条数据。重新获取数据，查找相对应id的那条数据的下标（ index 是不会改变的），用setData进行局部刷新this.setData({\r\n    list[index] = newList[index]\r\n})\r\n复制代码小心后台页面的js小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview(渲染层)， 但是却共享同一个js运行环境。也就是说，当你跳到了另外一个页面（假设是B页面），本页面（假设是A页面）的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中，还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。小心onPageScrollpageScroll 事件，也是一次通讯，是webview层向js逻辑层的通讯。这次通讯也是开销较大，如果考虑到这个事件被频繁的调用，回调函数如果有复杂的setData的话，emmmmm， 性能就会很差了。​小心获取节点位置在h5 中的环境中，为了实现懒加载、下拉加载，我们 不得不 去获取节点的位置。为啥说 不得不 ，是因为我们本可以用新的api ——intersectionObject去轻松实现（google等主流浏览器都已经支持了），但是微信的内置X5浏览器很遗憾的不支持。没想到，在小程序的环境中，微信竟然良心发现，支持intersectionObject api, 因此获取节点的信息，尽量还是用这api 吧。尽可能使用小程序组件自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用优化心得相比于上面的优化策略，最重要的是找出小程序中的性能瓶颈。在自己的优化实践中，遇到了下面的问题：下拉加载更多，特别特别卡，通过列表局部更新的技巧，发现性能改善不大。 后来发现，是因为首页需要监听scroll事件，导致scroll事件被频繁的触发，回调函数中有耗时操作，导致onreachBottom事件被阻塞了，也就是说，要等大概1~2秒才会去发起下一页的请求。 取消掉scroll事件的监听，原本>4s的加载时间，控制在1s之内。"}
{"title": "微信小程序里自动获得当前手机所在的经纬度并转换成地址 ", "author": "Rolan", "pub_time": "2018-11-4 23:50", "article_content": "效果：我在手机上打开微信小程序，自动显示出我当前所在的地理位置：具体步骤：1. 使用微信jssdk提供的getLocation API拿到经纬度；2. 调用高德地图的api使用经纬度去换取地址的文字描述。\r\nwx.ready(() => {\r\n\r\nwx.getLocation({\r\n\r\ntype: \"gcj02\",\r\n\r\nsuccess: function(res) {\r\n\r\nvar location =\r\n\r\n\"&location=\" + res.longitude + \",\" + res.latitude;\r\n\r\nReservationService.getGeocode(location).then(response => {\r\n\r\nif (\r\n\r\nresponse.data.status === \"1\" &&\r\n\r\nresponse.data.info === \"OK\"\r\n\r\n) {\r\n\r\nself.country =\r\n\r\nresponse.data.regeocode.addressComponent.country;\r\n\r\nself.city = response.data.regeocode.addressComponent.city;\r\n\r\nvar express =\r\n\r\n\"/\" +\r\n\r\nself.country +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.province +\r\n\r\n\"|\" +\r\n\r\nself.city +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.district +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.township +\r\n\r\n\"/g\";\r\n\r\nself.address = response.data.regeocode.formatted_address.replace(\r\n\r\neval(express),\r\n\r\n\"\"\r\n\r\n);\r\n\r\n} else {\r\n\r\n// get location error, plz input address\r\n\r\nalert(\"无法获取地址信息,请稍后再试\");\r\n\r\n}\r\n\r\n});\r\n\r\n}\r\n\r\n});\r\nReservationService.getGeocode的实现：getGeocode(location) {const key = '此处填入您高德地图app的key';return axios.post('https://restapi.amap.com/v3/g...' + key + location);}看下面一个使用高德地图API将经纬度转换成文字描述的地址的例子，使用postman发送请求：API响应：\r\n{\r\n\r\n\"status\": \"1\",\r\n\r\n\"regeocode\": {\r\n\r\n\"addressComponent\": {\r\n\r\n\"city\": [],\r\n\r\n\"province\": \"北京市\",\r\n\r\n\"adcode\": \"110101\",\r\n\r\n\"district\": \"东城区\",\r\n\r\n\"towncode\": \"110101001000\",\r\n\r\n\"streetNumber\": {\r\n\r\n\"number\": \"44号\",\r\n\r\n\"location\": \"116.39795,39.9097239\",\r\n\r\n\"direction\": \"东北\",\r\n\r\n\"distance\": \"117.874\",\r\n\r\n\"street\": \"广场东侧路\"\r\n\r\n},\r\n\r\n\"country\": \"中国\",\r\n\r\n\"township\": \"东华门街道\",\r\n\r\n\"businessAreas\": [\r\n\r\n{\r\n\r\n\"location\": \"116.3998109423077,39.90717459615385\",\r\n\r\n\"name\": \"天安门\",\r\n\r\n\"id\": \"110101\"\r\n\r\n},\r\n\r\n{\r\n\r\n\"location\": \"116.39981058278138,39.92383706953642\",\r\n\r\n\"name\": \"景山\",\r\n\r\n\"id\": \"110101\"\r\n\r\n},\r\n\r\n{\r\n\r\n\"location\": \"116.4118112683418,39.91461494422115\",\r\n\r\n\"name\": \"王府井\",\r\n\r\n\"id\": \"110101\"\r\n\r\n}\r\n\r\n],\r\n\r\n\"building\": {\r\n\r\n\"name\": \"天安门\",\r\n\r\n\"type\": \"风景名胜;风景名胜相关;旅游景点\"\r\n\r\n},\r\n\r\n\"neighborhood\": {\r\n\r\n\"name\": [],\r\n\r\n\"type\": []\r\n\r\n},\r\n\r\n\"citycode\": \"010\"\r\n\r\n},\r\n\r\n\"formatted_address\": \"北京市东城区东华门街道天安门\"\r\n\r\n},\r\n\r\n\"info\": \"OK\",\r\n\r\n\"infocode\": \"10000\"\r\n\r\n}\r\n要获取更多Jerry的原创文章，请关注公众号\"汪子熙\""}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "article_content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "小程序绘图工具painter-json文件绘制保存分享图-可点击任意元素触发函数 ... ... ", "author": "Rolan", "pub_time": "2018-8-27 00:25", "article_content": "Painter是由酷家乐移动前端团队打造的一款小程序绘图组件。\r\n原项目地址：github.com/Kujiale-Mob…\r\n新版地址：github.com/shesw/Paint…\r\n这款交互版原来是为了针对业务中的新需求而由我自己开发的，后来需求改动，所以并没有用上。组里大佬考虑种种原因（主要是项目没用上，=0=～～），让我先在自己的github上开源。这版painter与原版的区别在于：\r\n\r\n添加了交互事件。Painter本质是以canvas为基础的，小程序的canvas有许多限制。允许canvas上元素的交互点击事件，可以实现更为便捷的功能，比如原来需要在canvas上添加功能按钮，现在可以直接画在canvas上\r\n添加拖拽元素的功能。目前这个功能没有完善好，因为它的滑动动作会与小程序的全屏滑动事件冲突，因此，拖拽功能在固定的页面上效果才好，如在拖拽时设置overflow: hidden等。\r\n\r\n这里将新版的Painter称为dancing-painter。引入方式请参考readme和demo。\r\n演示：\r\n\r\n主要功能：\r\n指原版的painter的功能。这些功能依然是本项目的主(实)要(用)功能。\r\n简介：\r\n原版的使用简介请参见 juejin.im/post/5b40b1…\r\n简单来讲，使用过程如下图所示，可以结合demo来看：\r\n距离首次开源Painter库已经有一段时间了，这期间获益于各路道友的帮助和提点，Painter进行了几波更新（原项目地址)：\r\n新增特性：\r\n\r\n增加align属性，可以使任意元素可以实现左中右对齐。\r\n加入文字换行的能力。对一段文字设置width或者maxLines，都有可能触发文字的换行。\r\n添加文字的一些属性：fontWeight, textDecoration, textStyel(fill, stroke), maxLines, lineHeight\r\n图片mode属性，实现图片裁剪、缩放，默认为aspectFill\r\n图片不设置width, heighti属性，使用默认宽高\r\nleft, right, top, bottom对负数的支持\r\n\r\n修复问题：\r\n\r\n某些机型上切边会出现黑线。\r\n安卓机型上圆角无法显示\r\n使用文件前检查文件是否正常\r\n二维码大小显示异常\r\n\r\n交互功能：\r\n这一版的特色主要是具备元素的点击事件实现以及拖拽功能，做出来以后因为项目上暂时用不上，所以感觉功能上可能比较鸡肋。不过还蛮好玩的"}
{"title": "微信支付服务商接入指引 ", "author": "Rolan", "pub_time": "2018-8-27 00:33", "article_content": "微信支付服务商接入指引本文主要针对服务商下特约商户的小程序支付进行讲解。（扫码支付， h5支付大致流程都差不多，了解了小程序支付能够很快接入其他支付类型）说明：本文中的支付都是指在服务商模式下支付主体服务商:拥有支付开发能力的第三方提供商普通商户: 拥有开发能力的商户特约商户:服务商下的商户一个商家主体可以在不同服务商下申请特约商户，每个服务商都会给商家主体在此服务商下一个特约商户号。普通商户申请需要花费大约300RMB，服务商申请特约商户不需要费用。一个商家主体可以申请 普通商户，特约商户。同一个商户主体申请的普通商户与在服务商下申请的特约商户号是独立的。服务商服务商下的特约商户的资金流转不会直接经过服务商的支付账户，最终消费者的资金直接和服务商下的特约商户进行来往，但是服务商可以查看自己下的特约商户资金流水。服务商小程序开发文档开发支付开发之前申请注册服务商，通过之后登录微信商户平台,进入菜单: 服务商功能 --> 特约商户管理 -->新增商户（也就是申请服务商下的特约商户）申请如果没有问题会在三到五天通过，之后可以在特约商户管理下看到服务商自己的特约商户，我们在开发中需要 服务商商户号及这里的商户号（特约商户号）支付需要接口:微信统一下单，及提供给微信的回调接口微信官方给的业务流程图：可以很清晰的理解业务流程走向。统一下单接口微信统一下单请求参数统一下单请求参数封装为我们可以处理的对象：此处我的命名是： WechatUnifiedorderRequest以下是我开发中遇到一些坑，主要是由于微信官方的文档给的参数很模糊，特别是小程序支付。在填充好了WechatUnifiedorderRequest对象后对我们填充的值按照字典排序，连接key进行签名，以xml格式字符向微信发起请求我们需要对对象按照字典序排序第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。字典排序后的字符连接key（需要在微信商户平台进行配置建议使用UUID生成32位）MD5加密签名，得到sign填充WechatUnifiedorderRequest对象WechatUnifiedorderRequest转换为微信需要的xml类型发起请求得到微信统一下单的响应（是xml字符格式),解析为对象（对返回的响应封装对象进行处理WechatUnifiedorderResponse），对返回的对象进行验证，通过验证返回给小程序 需要的参数及签名 小程序调起支付API小程序支付成功，微信开始回调在统一下单传给微信的回调地址获取下单用户的真实IP /**\r\n     * 获取用户真实IP\r\n     * 如果有代理，获取真实客户端IP\r\n     * @param request\r\n     * @return\r\n     */\r\n    public  static  String getRealId(HttpServletRequest request){\r\n\r\n        String xForwardedForHeader= request.getHeader(\"X-Forwarded-For\");\r\n        if(xForwardedForHeader == null){\r\n            return  request.getRemoteAddr();\r\n\r\n        }else {\r\n            return  new StringTokenizer(xForwardedForHeader, \",\").nextToken().trim();\r\n        }\r\n\r\n    }按照字典序排序 /**\r\n     * 使用java反射机制，动态获取对象的属性和参数值，排除值为null的情况，并按字典序排序\r\n     * @param object\r\n     * @return\r\n     */\r\n    public static   String getSortMap(Object object) throws  Exception{\r\n        //1.得到属性的名称及值 如果为null不存入map\r\n        Field [] fields = object.getClass().getDeclaredFields();\r\n        Map<String,String> map = new HashMap<>();\r\n        for(Field field : fields){\r\n            String name = field.getName();\r\n            /*String methodName = \"get\"+name.replaceFirst(name.substring(0, 1), name.substring(0, 1)\r\n                    .toUpperCase());*/\r\n            //通过get方法直接获取属性值\r\n            field.setAccessible(true);\r\n            Object value = field.get(object);\r\n            if (value != null){\r\n                map.put(name, value.toString());\r\n            }\r\n\r\n\r\n        }\r\n        //排序\r\n        Map<String, String> sortMap = new TreeMap<String,String>(\r\n                new Comparator<String>() {\r\n\r\n                    @Override\r\n                    public int compare(String arg0, String arg1) {\r\n\r\n                        return arg0.compareTo(arg1);\r\n                    }\r\n                });\r\n        sortMap.putAll(map);\r\n\r\n\r\n        StringBuilder sortFeil = new StringBuilder();\r\n        //得到键值对的格式（即key1=value1&key2=value2…\r\n        sortMap.forEach((k,v)-> {\r\n            sortFeil.append(k+\"=\"+v+\"&\");\r\n        });\r\n        //移除最后一个 &\r\n        sortFeil.deleteCharAt(sortFeil.length()-1);\r\n        return sortFeil.toString();\r\n\r\n    }\r\n使用字典序返回的字符连接key，使用MD5进行加密，得到signWechatUnifiedorderRequest转换为微信需要的xml类型在WechatUnifiedorderRequest对象上使用注解@xmlAccessorType @xmlAccessorType(XmlAccessType.FIELD)@xmlRootElement @xmlRootElement(name =\"xml\") ( name = \"xml : \"WechatUnifiedorderReques对象转换为xml的根名称)/**\r\n * 微信统一下单请求对象\r\n *\r\n * @Author xuelongjiang\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlRootElement(name = \"xml\")//xml的根元素\r\npublic class WechatUnifiedorderRequest  implements Serializable{\r\n}\r\n对象转换为xml字符引入包：import javax.xml.bind.JAXBContext /**\r\n     * 对象转换为xml\r\n     * @param object\r\n     * @return\r\n     */\r\n    public static  String objectToXml(Object object){\r\n\r\n        StringWriter sw = new StringWriter();\r\n        try {\r\n\r\n            JAXBContext context = JAXBContext.newInstance(object.getClass());\r\n            Marshaller marshaller =  context.createMarshaller();\r\n            marshaller.marshal(object,sw);\r\n\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n            logger.error(\"对象解析xml出现异常，对象为\"+object.toString());\r\n        }\r\n\r\n        return sw.toString();\r\n    }得到微信统一下单的响应（是xml字符格式),解析为对象封装对象：WechatUnifiedorderResponse 表示微信统一下单响应的对象。请求微信统一下单返回示例：<xml>\r\n   <return_code><![CDATA[SUCCESS]]></return_code>\r\n   <return_msg><![CDATA[OK]]></return_msg>\r\n   <appid><![CDATA[wx2421b1c4370ec43b]]></appid>\r\n   <sub_appid><![CDATA[wx2421b1c4370ec11b]]></sub_appid>\r\n   <mch_id><![CDATA[10000100]]></mch_id>\r\n   <sub_mch_id>![CDATA[10000101]]></appid>\r\n   <nonce_str><![CDATA[IITRi8Iabbblz1Jc]]></nonce_str>\r\n   <sign><![CDATA[7921E432F65EB8ED0CE9755F0E86D72F]]></sign>\r\n   <result_code><![CDATA[SUCCESS]]></result_code>\r\n   <prepay_id><![CDATA[wx201411101639507cbf6ffd8b0779950874]]></prepay_id>\r\n   <trade_type><![CDATA[JSAPI]]></trade_type>\r\n</xml>参数值用XML转义即可，CDATA标签用于说明数据不被XML解析器解析，在转为对象的时候我们需要解析<![CDATA[]]>WechatUnifiedorderResponse对象使用注解@XmlAccessorType(XmlAccessType.FIELD)@XmlRootElement(name = \"xml\")//解析xml的根元素以上的和WechatUnifiedorderRequest是一样，但是由于需要解析<![CDATA[]]>，我们创建CDataAdapter继承XmlAdapter ，使用注解@XmlJavaTypeAdapter来处理，在WechatUnifiedorderResponse需要处理<![CDATA[]]>的域上使用注解如下： @XmlJavaTypeAdapter(CDataAdapter.class)// 解析<![CDATA[]]>\r\n    private String return_code; //返回状态码CDataAdapter解析<![CDATA[]]>\r\n/**\r\n *\r\n * 注解使用， 对象与xml转换的字段需要有 <![CDATA[]]>\r\n *\r\n * @Author xuelongjiang\r\n */\r\npublic class CDataAdapter extends XmlAdapter<String,String> {\r\n\r\n    private static Logger logger = LoggerFactory.getLogger(CDataAdapter.class);\r\n\r\n    /**\r\n     * Do-nothing constructor for the derived classes.\r\n     */\r\n    protected CDataAdapter() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Convert a value type to a bound type.\r\n     *\r\n     * @param v The value to be converted. Can be null.\r\n     * @throws Exception if there's an error during the conversion. The caller is responsible for\r\n     *                   reporting the error to the user through {@link ValidationEventHandler}.\r\n     */\r\n    @Override\r\n    public String unmarshal(String v) throws Exception {\r\n\r\n      if(\"<![CDATA[]]>\".equals(v)){\r\n          return \"\";\r\n      }\r\n      String v1 = null;\r\n      String v2 = null;\r\n\r\n      String subStart = \"<![CDATA[\";\r\n      int a = v.indexOf(subStart);\r\n      if(a>= 0){\r\n          v1 = v.substring(subStart.length(),v.length());\r\n\r\n      }else {\r\n          return v;\r\n      }\r\n      String subEnd = \"]]>\";\r\n      int b = v1.indexOf(subEnd);\r\n      if(b>= 0){\r\n          v2 = v1.substring(0,b);\r\n      }\r\n      return v2;\r\n\r\n    }\r\n\r\n    /**\r\n     * Convert a bound type to a value type.\r\n     *\r\n     * @param v The value to be convereted. Can be null.\r\n     * @throws Exception if there's an error during the conversion. The caller is responsible for\r\n     *                   reporting the error to the user through {@link ValidationEventHandler}.\r\n     */\r\n    @Override\r\n    public String marshal(String v) throws Exception {\r\n\r\n        logger.info(\"对象转换xml:\"+\"<![CDATA[\"+ v +\"]]>\");\r\n        return \"<![CDATA[\"+ v +\"]]>\";\r\n    }\r\n}\r\n\r\n到此为止，我们已经得到微信统一下单的响应值了，后续的处理不是很复杂。按照文档不会有很大的坑。在做微信支付的时候，难点是以上的：请求参数说明模糊，在经历几次的传参试验及百度谷歌之后，才明白了参数的具体的使用，其实后续在做扫码支付的时候，发现扫码支付解释的比较清楚，小程序的文档确实比较坑。参考文档：https://developers.weixin.qq....https://segmentfault.com/a/11...https://developers.weixin.qq...."}
{"title": "轻松生成小程序分享海报 ", "author": "Rolan", "pub_time": "2018-8-29 00:15", "article_content": "作者：jasondu原文：https://segmentfault.com/a/1190000016121303小程序海报组件https://github.com/jasondu/wx...需求小程序分享到朋友圈只能使用小程序码海报来实现，生成小程序码的方式有两种，一种是使用后端方式，一种是使用小程序自带的canvas生成；后端的方式开发难度大，由于生成图片耗用内存比较大对服务端也是不小的压力；所以使用小程序的canvas是一个不错的选择，但由于canvas水比较深，坑比较多，还有不同海报需要重现写渲染流程，导致代码冗余难以维护，加上不同设备版本的情况不一样，因此小程序海报生成组件的需求十分迫切。在实际开发中，我发现海报中的元素无非一下几种，只要实现这几种，就可以通过一份配置文件生成各种各样的海报了。海报中的元素分类要解决的问题单位问题canvas隐藏问题圆角矩形、圆角图片多段文字超长文字和多行文字缩略问题矩形包含文字多个元素间的层级问题图片尺寸和渲染尺寸不一致问题canvas转图片IOS 6.6.7 clip问题关于获取canvas实例单位问题canvas绘制使用的是px单位，但不同设备的px是需要换算的，所以在组件中统一使用rpx单位，这里就涉及到单位怎么换算问题。通过wx.getSystemInfoSync获取设备屏幕尺寸，从而得到比例，进而做转换，代码如下：const sysInfo = wx.getSystemInfoSync();\r\nconst screenWidth = sysInfo.screenWidth;\r\nthis.factor = screenWidth / 750;    // 获取比例\r\nfunction toPx(rpx) {    // rpx转px\r\n    return rpx * this.factor;\r\n}\r\nfunction toRpx(px) {    // px转rpx\r\n    return px / this.factor;\r\n},canvas隐藏问题在绘制海报过程时，我们不想让用户看到canvas，所以我们必须把canvas隐藏起来，一开始想到的是使用display:none; 但这样在转化成图片时会空白，所以这个是行不通的，所以只能控制canvas的绝对定位，将其移出可视界面，代码如下：.canvas.pro {\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: -9999rpx;\r\n}圆角矩形、圆角图片由于canvas没有提供现成的圆角api，所以我们只能手工画啦，实际上圆角矩形就是由4条线（黄色）和4个圆弧（红色）组成的，如下：圆弧可以使用canvasContext.arcTo这个api实现，这个api的入参由两个控制点一个半径组成，对应上图的示例canvasContext.arcTo(x1, y1, x2, y2, r)接下来我们就可以非常轻松的写出生成圆角矩形的函数啦/**\r\n * 画圆角矩形\r\n */\r\n_drawRadiusRect(x, y, w, h, r) {\r\n    const br = r / 2;\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(this.toPx(x + br), this.toPx(y));            // 移动到左上角的点\r\n    this.ctx.lineTo(this.toPx(x + w - br), this.toPx(y));        // 画上边的线\r\n    this.ctx.arcTo(this.toPx(x + w), this.toPx(y), this.toPx(x + w), this.toPx(y + br), this.toPx(br));                                                    // 画右上角的弧        \r\n    this.ctx.lineTo(this.toPx(x + w), this.toPx(y + h - br));    // 画右边的线\r\n    this.ctx.arcTo(this.toPx(x + w), this.toPx(y + h), this.toPx(x + w - br), this.toPx(y + h), this.toPx(br));                                              // 画右下角的弧\r\n    this.ctx.lineTo(this.toPx(x + br), this.toPx(y + h));        // 画下边的线\r\n    this.ctx.arcTo(this.toPx(x), this.toPx(y + h), this.toPx(x), this.toPx(y + h - br), this.toPx(br));                                                    // 画左下角的弧\r\n    this.ctx.lineTo(this.toPx(x), this.toPx(y + br));            // 画左边的线\r\n    this.ctx.arcTo(this.toPx(x), this.toPx(y), this.toPx(x + br), this.toPx(y), this.toPx(br));                                                    // 画左上角的弧\r\n}如果是 画线框 就使用 this.ctx.stroke();如果是 画色块 就使用 this.ctx.fill();如果是 圆角图片 就使用this.ctx.clip();\r\nthis.ctx.drawImage(***);clip() 方法从原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）。多段文字如果是连续多段不同格式的文字，如果让用户每段文字都指定坐标是不现实的，因为上一段文字的长度是不固定的，这里的解决方案是使用 ctx.measureText （基础库 1.9.90 开始支持）Api来计算一段文字的宽度，记住这里返回宽度的单位是px（ 坑 ），从而知道下一段文字的坐标。超长文字和多行文字缩略问题设置文字的宽度，通过 ctx.measureText 知道文字的宽度，如果超出设定的宽度，超出部分使用“...”代替；对于多行文字，经测试发现字体的高度大约等于字体大小，并提供lineHeight参数让用户可以自定义行高，这样我们就可以知道下一行的y轴坐标了。矩形包含文字这个同样使用 ctx.measureText 接口，从而控制矩形的宽度，当然这里用户还可以设置paddingLeft和paddingRight字段；文字的垂直居中问题可以设置文字的基线对齐方式为middle（ this.ctx.setTextBaseline('middle'); ），设置文字的坐标为矩形的中线就可以了；水平居中 this.ctx.setTextAlign('center'); ;多个元素间的层级问题由于canvas没有Api可以设置绘制元素的层级，只能是根据后绘制层级高于前面绘制的方式，所以需要用户传入zIndex字段，利用数组排序（Array.prototype.sort）后再根据顺序绘制。图片尺寸和渲染尺寸不一致问题绘制图片我们使用 ctx.drawImage() API；如果使用 drawImage(dx, dy, dWidth, dHeight) ，图片会压缩尺寸以适应绘制的尺寸，图片会变形，如下图：在基础库1.9.0起支持 drawImage(sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)  ，sx和sy是源图像的矩形选择框左上角的坐标，sWidth和sHeight是源图像的矩形选择框的宽度和高度，如下图：如果绘制尺寸比源图尺寸宽，那么绘制尺寸的宽度就等于源图宽度；反之，绘制尺寸比源图尺寸高，那么绘制尺寸的高度等于源图高度；我们可以通过 wx.getImageInfo Api获取源图的尺寸；canvas转图片在canvas绘制完成后调用 wx.canvasToTempFilePath Api将canvas转为图片输出，这样需要注意， wx.canvasToTempFilePath 需要写在 this.ctx.draw 的回调中，并且在组件中使用这个接口需要在第二个入参传入this（ 坑 ），如下this.ctx.draw(false, () => {\r\n    wx.canvasToTempFilePath({\r\n        canvasId: 'canvasid',\r\n        success: (res) => {\r\n            wx.hideLoading();\r\n            this.triggerEvent('success', res.tempFilePath);\r\n        },\r\n        fail: (err) => {\r\n            wx.hideLoading();\r\n            this.triggerEvent('fail', err);\r\n        }\r\n    }, this);\r\n});IOS 6.6.7 clip问题在IOS 6.6.7版本中clip方法连续裁剪图片时,只有第一张有效，这是微信的bug，官方也证实了（ https://developers.weixin.qq.... ）关于获取canvas实例我们可以使用 wx.createCanvasContext 获取小程序实例，但在组件中使用切记第二个参数需要带上this，如下this.ctx = wx.createCanvasContext('canvasid', this);如何使用组件https://github.com/jasondu/wx..."}
{"title": "小程序 | 注释级微信小程序demo，助你快速切入开发 ", "author": "Rolan", "pub_time": "2018-8-29 00:21", "article_content": "写在前面\r\n小程序开发渐进红利期，更多开发者慕名而来，网上的学习资料也层出不穷，有点眼花缭乱的意思了。在经过一个多月的摸索式学习后，我也终于写了不算精美的一个小程序。\r\n那为什么写这篇文章：\r\n\r\n总结经验 - 写文章能带来更多的思考，为后续开发做准备\r\n分享经验 - 网上的资料真的太多了，希望我这篇文章能有所用\r\n\r\n几个问题\r\n\r\n适合哪些读者？\r\n本文适合对小程序有兴趣，且已阅读过官网：微信小程序开发教程，体验过官方demo，想进一步学习开发的读者\r\n包含哪些技术点？\r\n主要包括：微信小程序常见语法、跨页面传参、缓存使用、本地数据模拟、第三方UI库的使用、富文本转义、数据结构设计、后端数据请求、nodejs服务代理转发\r\n有何特点？\r\n思路、注释、源代码\r\n\r\n正文\r\n简介\r\n取了一个很low的名字“全民精进阅读”，意为沉浸式阅读体验，是一款rss源阅读小程序，主要功能包括：已关注源、源列表、源文章详情、源中心。可直接阅读知乎每日精选、the week等优质中英文源。\r\n使用起来效果是这样的：\r\n\r\n也可以直接微信扫码体验：\r\n\r\n灵感来源\r\n信息大爆炸时代，每天可看的实在太多，头条、公众号、知乎、各垂直平台、大佬博客......只想找一个“安静”的地方，便捷地阅读一些精选的东西。于是乎就想起了RSS，想着将其与小程序结合，抱着试一试的心态写了一下，顺便当做练习。\r\n模块分析（这个部分是废话，干货请直接查阅“代码实现”部分或者下载源码体验）\r\n有了目标，接下来就是具体构思了。\r\n最终需求为实现对RSS源的关注、展示。拆解为如下原子功能：\r\n\r\nRSS源关注\r\nRSS源已关注展示\r\nRSS源内容列表展示\r\nRSS源文章详细内容展示\r\nRSS源取消关注\r\n\r\n同时，为了能够选择到想关注的RSS源以及能有一个有效的反馈渠道和声明，还需两个个功能：\r\n\r\nRSS源推荐列表\r\nRSS源简介\r\nRSS源反馈渠道、声明展示\r\n\r\n针对上述功能，进行模块设计，这里推荐使用UE在线编辑应用墨刀来尝试完成。\r\n根据《Do not make me think》的原则，可以设计为如下5模块（页面）：\r\n\r\n已关注源展示\r\n\r\nRSS源已关注展示\r\nRSS源取消关注\r\n\r\n\r\n源中心\r\n\r\nRSS源推荐列表\r\nRSS源简介\r\nRSS源关注\r\n\r\n\r\n源内容展示\r\n\r\nRSS源内容列表展示\r\n\r\n\r\n源文章详细展示\r\n\r\nRSS源文章详细内容展示\r\n\r\n\r\n更多\r\n\r\nRSS源简介\r\nRSS源反馈渠道、声明展示\r\n\r\n\r\n\r\n各模块间的交互如下图（省略返回）：\r\n\r\n关于UI设计，作为前端开发首先能想到的就是宫格--简明扼要，很符合预期。所以就没有做专门的UI设计，在开发过程中“随机应变”。\r\n说了辣么多，该亮代码了。。。\r\n代码实现\r\n技术准备\r\n根据以上部分的分析，已经把小程序的所有功能点罗列出来了，现在做技术分析：\r\n\r\n\r\n整体而言，需要第三方UI库。经过搜索，发现两款不错的：一个是有赞的zanui，一个是美丽说的minui。因为我对该小程序的预期样式和zanui更接近，且zanui可以只引入部分模块，我选择了zanui。\r\n\r\n\r\n针对各功能点\r\n\r\n\r\n\r\nRSS源关注：带参数页面跳转、弹框（微信弹框展示信息太少，需用zanui）\r\nRSS源已关注展示：宫格布局、数据结构设计\r\nRSS源内容列表展示：RSS数据结构分析、布局\r\nRSS源文章详细内容展示：跨页面传参、富文本展示（微信没有标签，需第三方库来实现）\r\nRSS源取消关注：长按取消、数据缓存刷新\r\nRSS源推荐列表：宫格布局、数据结构设计\r\nRSS源简介：文本展示（注意微信中标签中的才能被选中复制）\r\nRSS源反馈渠道、声明展示：简单文本展示\r\n\r\n具体实现\r\n做好准备之后，就可以在微信开发者工具内开发了。\r\n首先，初始化项目后，修改创建出如下目录：\r\n├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── data 本地数据\r\n|  └── rss.js\r\n├── pages 页面\r\n|  ├── detail 源文章详细展示\r\n|  |  ├── detail.js\r\n|  |  ├── detail.json\r\n|  |  ├── detail.wxml\r\n|  |  └── detail.wxss\r\n|  ├── index 源内容展示\r\n|  |  ├── index.js\r\n|  |  ├── index.json\r\n|  |  ├── index.wxml\r\n|  |  └── index.wxss\r\n|  ├── more 更多\r\n|  |  ├── more.js\r\n|  |  ├── more.json\r\n|  |  ├── more.wxml\r\n|  |  └── more.wxss\r\n|  ├── rsscenter 源中心\r\n|  |  ├── rsscenter.js\r\n|  |  ├── rsscenter.json\r\n|  |  ├── rsscenter.wxml\r\n|  |  └── rsscenter.wxss\r\n|  └── rssed 已关注源展示\r\n|     ├── rssed.js\r\n|     ├── rssed.json\r\n|     ├── rssed.wxml\r\n|     └── rssed.wxss\r\n├── project.config.json\r\n├── utils 通用资源\r\n|  └── util.js\r\n└── wxParse 富文本转义库\r\n复制代码页面一：rssed 已关注源展示\r\n考虑到用户实际操作流，进入小程序后首先进入的就应该是已关注的源展示，新用户访问到的是空页面。用户可在页面操作触发添加关注、删除已关注。\r\n\r\n宫格布局与第三方UI库的使用\r\n\r\n对于已关注的源，关键信息是源名称、源logo。因此，基于清爽设计，采用宫格布局，这里使用的是zanui的栅格系统。从zanui的源码（本文使用的是v1.9.91版本）中找到栅格系统组件dist/col/index.wxss，将内容复制到项目的app.wxss中，当作通用样式，wxml参照zanui源码中的/pages/layout/index.wxml。\r\n栅格系统中对高度没有做控制，需要自行实现正方形方块，添加如下wxss代码：\r\n.zan-col {\r\n  background-color: #39a9ed;\r\n  height: 25vw;\r\n  text-align: center;\r\n  padding-top: 60rpx;\r\n  color: #fff;\r\n  position: relative;\r\n}\r\n\r\n.zan-col:nth-child(odd) {\r\n  background-color: #66c6f2;\r\n}\r\n复制代码值得一提的是，第三方UI库的引入方式除了这种部分引入外，还可以整体引入，方法为：已zanui为例，将其资源文件通过@import直接引入到app.wxss中。\r\n@import \"dist/index.wxss\";\r\n复制代码\r\n数据结构设计\r\n对于这个已关注源的集合，我们将需要的元数据放入数组，用于宫格渲染。\r\n\r\n    const rssedData = [\r\n      {\r\n        title: '知乎每日精选', // 源名称\r\n        favicon: 'https://www.zhihu.com/favicon.ico', // 源logo\r\n        rssUrl: 'https://www.zhihu.com/rss', // 源链接\r\n      },\r\n      {\r\n        title: 'the weak',\r\n        favicon: 'https://theweek.com/favicon.ico',\r\n        rssUrl: 'https://theweek.com/rss.xml',\r\n      },\r\n    ];\r\n复制代码此数据，加载该页面后从Storage中的取值rssedData，rssedData 在已关注是写入缓存。\r\n3. 渲染与取消关注\r\n根据数据结构和UI设计，使用wx:for循环渲染出宫格。\r\n由于需要查看、取消关注某个源，因此就需要在元素上添加data-rss-id等值，用于事件绑定与跨页面传参。\r\n删除采用常见的长按出现删除按钮，点击按钮就删除的方案。\r\n4. 其他页的关联设计\r\n作为主页面，需要有访问其他功能也的入口，这里将工业入口放入宫格最后，作为关联。\r\n\r\n页面二：rsscenter 源中心\r\n对于新用户而言，访问过已关注页面后，紧接着需要访问的就是源中心了。需要完成下面的功能：\r\n\r\nRSS源推荐列表展示与数据结构设计\r\n采用和已关注页相同的布局方式--宫格，样式复用，数据格式类似但需扩充。\r\n\r\n  {\r\n    title: '知乎每日精选', // 源名称\r\n    link: 'https://www.zhihu.com', // 源官网链接\r\n    description: '中文互联网最大的知识平台，帮助人们便捷地分享彼此的知识、经验和见解。', // 源简介\r\n    favicon: 'https://www.zhihu.com/favicon.ico', // 源logo\r\n    rssUrl: 'https://www.zhihu.com/rss', // 源链接\r\n  }\r\n复制代码另外，对于关注的源应该有特殊标识，所以需要对数据做处理，通过对比Storage中rssedData和rss.js文件中的数据，给页面数据添加rssed（type：boolean）字段。\r\n这里的数据来源于网络收集，暂时固定写死在小程序中，因此我提出来放到了项目的/data/rss.js文件中。后续版本，这个放到服务端管理，可以做到动态增删改。\r\n2. RSS源简介\r\n采用弹出框的形式，展示基本信息，提供关注按钮。这里使用了zanui的popup组件，引入方式同栅格系统。\r\n\r\n3. RSS源关注\r\n更新Storage，使用wx.reLaunch跳转至已关注页。\r\nwx.reLaunch({\r\n  url: `../rssed/rssed`,\r\n});\r\n复制代码页面三：源内容展示\r\n采用经典设计，如下图。\r\n\r\n\r\n源数据处理与node服务\r\nrss是基于XML标准的数据，在小程序中无法直接解析，且小程序的合法requests域名有限，这里可以采用服务器代理的形式来处理。\r\n我这里使用的是基于nodejs的thinkjs框架，在框架内引入专门将rss数据转为json数据的插件。这个服务后续可以专门写一篇文章，这里就不展开了，思路就是这样的。另外rss数据格式有多种，需要做兼容处理。\r\n响应格式为：\r\n\r\n{\r\n\t\"errno\": 0,\r\n\t\"errmsg\": \"\",\r\n\t\"data\": {\r\n\t\t\"rss\": {\r\n\t\t\t\"$\": {\r\n\t\t\t\t\"version\": \"2.0\",\r\n\t\t\t\t\"xmlns:atom\": \"http://www.w3.org/2005/Atom\"\r\n\t\t\t},\r\n\t\t\t\"channel\": {\r\n\t\t\t\t\"title\": \"知乎每日精选\",\r\n\t\t\t\t\"link\": \"http://www.zhihu.com\",\r\n\t\t\t\t\"description\": \"中文互联网最大的知识平台，帮助人们便捷地分享彼此的知识、经验和见解。\",\r\n\t\t\t\t\"atom:link\": {\r\n\t\t\t\t\t\"$\": {\r\n\t\t\t\t\t\t\"href\": \"http://www.zhihu.com/rss\",\r\n\t\t\t\t\t\t\"rel\": \"self\"\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t\"language\": \"zh-cn\",\r\n\t\t\t\t\"copyright\": \"© 2018 知乎(http://www.zhihu.com)\",\r\n\t\t\t\t\"lastBuildDate\": \"Fri, 03 Aug 2018 16:30:25 +0800\",\r\n\t\t\t\t\"ttl\": \"180\",\r\n\t\t\t\t\"item\": [{\r\n\t\t\t\t\t\"title\": \"如何评价 2018 年菲尔兹奖（fields medal 2018）结果与四位得主的工作？\",\r\n\t\t\t\t\t\"link\": \"http://www.zhihu.com/question/287977241/answer/458776271?utm_campaign=rss&utm_medium=rss&utm_source=rss&utm_content=title\",\r\n\t\t\t\t\t\"description\": \"<p></p><br>\\n \",\r\n\t\t\t\t\t\"dc:creator\": {\r\n\t\t\t\t\t\t\"_\": \"知识分子\",\r\n\t\t\t\t\t\t\"$\": {\r\n\t\t\t\t\t\t\t\"xmlns:dc\": \"http://purl.org/dc/elements/1.1/\"\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\t\"pubDate\": \"Fri, 03 Aug 2018 16:30:25 +0800\",\r\n\t\t\t\t\t\"guid\": \"http://www.zhihu.com/question/287977241/answer/458776271\"\r\n\t\t\t\t},]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n复制代码其中的description字段为该文章简介内容的hmtl文档，部分源将全部内容放到其中，所以加载的时候可能比较慢。\r\n2. 列表渲染与带参数跳转\r\n拿到上述数据之后，对数据进行缓存放入Storage中。然后使用wx:for渲染列表。\r\n页面跳转至详情页时带上文章的数组index值：\r\n    wx.navigateTo({\r\n      url: `../detail/detail?id=${rssItemData}&favicon=${favicon}`,\r\n    });\r\n复制代码在detail.js中取值\r\n  onLoad: function (options) {\r\n    this.showDetail(options.id, options.favicon);\r\n  },\r\n复制代码\r\n为什么一次性缓存？\r\n\r\n\r\nrss源数据返回的就是全部返回\r\n利于用户体验，不至于加载列表页等待之后，切换详情页还需要等待。\r\n\r\n页面四：源文章详细展示\r\n核心就是读取Storage中的数据，将html富文本转为wxml。\r\n这里采用的是wxParse库。将wxParse源码下载后，拷贝至项目根目录，然后在/pages/detail/detail.js中引入、调用。\r\nconst WxParse = require('../../wxParse/wxParse.js');\r\n...\r\nWxParse.wxParse('article', 'html', rssDataItem.description, that, 5);\r\n...\r\n复制代码ps：单独引入三方库的好处在于，可以自定义部分标签的展示，这个根据实际需求而定。\r\n页面五：更多\r\n从已关注页面跳转而来，展示一些额外信息。简单的文字排版，不赘述。\r\n最后\r\n小程序开发本身并不复杂，但是要做好做优还需要多学习和练习。这款小程序目前也只是停留在能用的阶段，还有很多需要完善和优化的地方，希望对大家学习有用。另外，有更好的建议请私我，谢谢大家。作者：保山链接：https://juejin.im/post/5b7f5ef46fb9a019d67c0f30"}
{"title": "防踩坑指南：对接支付渠道二三事 ", "author": "Rolan", "pub_time": "2018-8-30 00:08", "article_content": "今天要分享的内容，会以商家的视角去分析对接渠道过程中需要关注的问题。一. 支付渠道业务规则这部分内容主要介绍常见支付渠道的业务规则以及选择渠道过程中需要关注哪些重点，主要面向商家的业务部门，方便根据自身业务模式匹配最合适的支付渠道。1. 产品概述和应用场景要想了解支付渠道的业务规则，首先需要知道目前主要的支付渠道、支付产品有哪些，是什么模式，然后商家根据自身产品及业务模式去匹配最优的支付方式。一般情况下对接的支付渠道有两类：银行：招行、建行、农行等支付机构：微信、支付宝、京东等每个渠道有自己的收款产品，对应在不同的支付终端上使用。这里讲一下，「支付终端」换成「支付场景」也是合适的，不同公司团队个人叫法可能有所不同，总之方便理解来看就是电脑网站、手机网站以及手机应用等等。这里将各个渠道的收付款产品放到了对应的支付终端下，不同支付终端下支持的渠道支付产品也有所区别，且需要独立申请开通权限。微信在移动应用、手机网页、pc 网页、公众号内、线下扫码、微信小程序中的支付产品分别是：APP 支付、H5 支付、扫码支付、公众号支付（仅能在微信浏览器内支付）、刷卡支付（也包含扫码支付 ）、小程序支付（ 其中小程序内不能使用其他渠道的支付产品）。扫码支付和刷卡支付的区别是，前者是用户扫商家码，后者是用户的支付码被商家扫。其中需要注意的是，APP 支付和公众号支付需要分别在开放平台和公众平台进行申请开通。开通公众号支付后，默认会开通扫码支付和刷卡支付的产品权限。H5  支付功能是在微信商户平台上开通的支付产品权限，前提是至少开通APP支付、小程序支付、公众号支付的其中一种支付权限。分期产品：目前比较常见的花呗分期和京东白条，这两家的分期产品早期都是放在收银台的一种支付方式，C 端用户在选择支付宝或者京东支付之前并不能直观的了解到该商家是否支持分期，所以后期两家也推出了分期前置的模式，即支持分期支付方式直接在商家收银台进行展示（对于 C 端用户来讲，更加直观，体验更好，能够有效降低消费者心里门槛），与支付宝、微信、QQ 钱包支付可做平级展示。简单介绍了商家收款，我们也来看看商家付款的产品功能：代付： 代付，我们通常称「代付」主要指的是商家充值到在支付机构开通的备付金账户，然后直接调用代付接口下发给 C 端用户或者 B 端商家银行账户。转代付（这个叫法可能不同公司有所不同，转代付比较容易理解）： 转代付，这里指的是先通过支付渠道的支付产品收款至企业账户，然后直接通过出款接口进行下发。现在的微信新资金流的企业付款就是转代付的模式。分账（严格意义来讲不能称之为商家出款行为）： 指的是商家在发起收款订单时即指定了相关的分账信息，用户支付成功时，直接将资金分账到对应的 B 端商家企业账户。下面一张图看看 转代付 和 分账 的区别：B 商家发起收款 100 元，后续可以给 C 端商家或者 B 端商家进行打款。这里需要注明的是，给商家或者用户打款的 X 和 Y 元，跟 100元没有必然联系，只要确保出款账户内资金足够用于 B 商家打款即可。这里需要提及下，微信的企业付款只能针对 C 端用户，不能给 B 端商家打款。支付宝的单笔转账可以给 C 端用户和 B 端商家的支付宝账户转账。因为微信现在区分新旧资金流，所以现在企业付款到零钱资金根据商户号的账户开通情况，实际出款账户有做区别：默认情况下，企业付款到零钱使用商户号基本户（或余额账户）余额。如商户号已开通运营账户，则企业付款到零钱使用运营账户内的资金。基本户（或上述其他出款账户）的资金来源，可能是交易结算款项（仅基本户），或给账户充值的资金。当出款账户余额不足时，付款将因余额不足而付款失败。B 商家发起 100 元收款，含分账指令给 C 商户 20 元，那么最终用户完成这笔订单支付的时候，则商家 B 收款 80 元，商家 C 收款 20 元。分账模式比较适用于平台类型的商家或者集团类型的商家，目前所接触到的微信分账并没有对外开放申请，最多关联的分账账户有 5 个的限制。支付宝的分账目前看到的是在跨境上有用到，最多支持在 10 个以内。两个分账功能均需要单独联系 BD 进行申请。2. 行业准入和区别（1）商家收款类别1）这里简单列了下大的分类，主要有实物类、虚拟类和政府/事业单位（主要指的公立医院和学校）走微信和支付宝的渠道申请所对应的费率和结算周期的区别。特殊行业对应所需要的资质也有所区别。实物类： 医疗类的会有资质文件才可以申请，比如医疗器械、身体康复用品的需要持有《医疗器械经营企业许可证》、经营内容包含美瞳或者隐形眼镜，则需要提供《第三类医疗器械销售资质》等等；虚拟类： 比如游戏道具购买，需要具备《网络文化经营许可证》。2）商家的行业可以直接参照腾讯或者支付宝的的商家类目、费率、资质的文档，简单粗暴，可以到官网上了解一下。3）这里提及一下，前面的花呗分期和京东白条产品：使用的前提都是至少拥有支付宝或者京东对应的基础支付功能，才能进一步申请分期的产品权限，目前两家的分期产品的权限都是需要单独联系 BD ，走线下申请的流程，周期较长。（2）商家付款类别Tips：微信新资金流开通企业付款功能要求商户号开通 90 天且持续 30 天以上有交易流水，才可以申请开通「企业付款」权限，且目前服务商模式不支持企业付款。目前银行卡代付的申请，看各家机构的要求，目前尚且没有比较固定的行业分类。基本上 case by case 的去看。所以我们主要看看在使用商家付款产品的时候，需要关注哪些内容。① 费用看代付的费用从两种情况来看，一个是付款到银行卡，一个是付款到钱包账户。前者的费用一般是按照单笔手续费计算，比如 1-2 元/笔。后者代付到钱包一般是免费，这个手续费商家不承担，主要在用户发起提现的时候会需要支付提现手续费。② 限额各家支付机构不一样，但是主要需要与支付机构沟通的是单笔、单日、单月、以及每天的调用频次等是否有限制，限制是多少。避免业务部门已经申请完成了渠道，后面产品对接发现根本不能满足业务应用场景，那就后使用起来就 GG 了。③ 到账时间选择商家付款渠道的时候也需要关注付款到账时间，因为有些应用场景对于实时性要求比较高。④ 支持的银行支持银行列表也需要多加关注，尤其是 B2B 转账或者对于有特殊银行需求的商家。前面在商家付款中提到的代付和转代付，对于微信的 企业付款 产品区分新旧资金流。微信现在区分新旧资金流企业付款到零钱资金根据商户号的账户开通情况，实际出款账户有做区别：默认情况下，企业付款到零钱使用商户号基本户（ 或余额账户 ）余额。如商户号已开通运营账户，则企业付款到零钱使用运营账户内的资金。基本户（或上述其他出款账户）的资金来源，可能是交易结算款项（仅基本户），或给账户充值的资金。当出款账户余额不足时，付款将因余额不足而付款失败。3. 渠道合作模式和优惠政策早期商家跟渠道的合作比较单一，但是近 2 年渠道也推出来比较多的合作模式来吸引商家以及合作伙伴。简单介绍下各种合作模式：直连直连（ 入驻 ）普通服务商银行服务商目前服务商模式做的比较好的是微信和支付宝，微信的营销活动做的比较好，之前的智慧餐厅推广叠加活动、随机立减活动，以及最近的朋友圈广告功能投放功能等等活动，无论是从商家成本还是用户体验上，都极大的调动符合条件客户参与活动的积极性。各种合作模式的优缺点4. 退款处理规则接下来我们讲讲退款，原先「退款」这一块的逻辑是放在后面渠道开发对接部分的。但是因为近期日常渠道运营中遇见了一个关于手续费的问题，退款是否退回手续费的问题一定程度上决定了某些特定场景的商户对于支付渠道的选择，因此把它提到业务规则中来聊一聊。为什么在业务对接的时候就需要关注上图这三点呢？某些特定行业对于退款的周期有特殊要求 ，比如共享单车的押金、家具公司的较长退货期等等，这一类允许较长周期退款的行业都需要关注各个渠道的退款周期。如果退款周期不满足需求，最好在入网阶段就能提出延长订单可退款周期的需求，按照渠道要求提交业务说明并变更退款周期。避免到了后期渠道不好调整而导致用户与商家的纠纷投诉。关于退款是否退回手续费的规则需要提前与渠道确认好 ，正常情况下当用户产生退款，商家是会被渠道退回支付时收取的交易手续费的。但少部分支付渠道存在以下几种情况：退款不退回手续费、部分退款不退回手续费、退款只退部分手续费（退动态手续费，不退固定手续费部分）因此需要提前捋顺几个问题：退款功能是否需要提前额外申请退款周期是否需要延长退款资金是否需要额外充值：待结算账户、余额充值账户退款或者撤销是否退回原订单的支付手续费以下是一张关于各渠道的退款周期，是否退回手续费以及退回手续费的逻辑说明：5. 支付渠道对接及管理（1）资金结算方式手动提现还是自动结算，自动结算是否有资金门槛（因为在跨境微信支付宝的渠道资金结算，直连会有 5000 usd 结算资金门槛）（2）获取对账单方式业务需要提前确认获取对账单方式，是只能通过商户平台下载还是也能通过接口下载。如果通过接口下载是否需要提前走申请流程，因为我们有遇见过一些支付渠道下载对账单也需要提前走线下公司盖章的申请流程，周期略长。前期若没有确认好，会都后期项目开发周期造成影响。（3）清分时间这个跟获取对账单方式时候可以一并确认，一般渠道的清分时间都是 00-24 点之间的交易。（4）区分不同交易对账单微信新资金流，因为没有待结算和余额充值账户的概念，退款都是从基本户中出去的，所以退款的订单都会在 ALL 类型的对账单中；微信旧资金流，区分待结算账户和充值余额账户，即使针对 ALL 类型的对账单，也不包含余额充值的退款对账单。二. 支付渠道对接及管理这部分内容着重介绍在开发对接渠道过程中需要关注哪些问题，主要面向商家的产品部门。第一部分主要讲了商家的业务部门在前期申请渠道时候，场景适配以及需要提前跟渠道沟通了解的注意事项。第二部分就涉及到产品技术对接阶段的一些细节处理。1. 渠道对接步骤和内容公司内各个部门不同的产品，线上线下产品适用场景不同，费率会有所区分，注意事项在第一部分已经阐述。切记不要申请错了权限，这个对于微信是比较常见的问题（ 服务号、订阅号、APP ）配置并获取参数，这一个步骤建议是产品与业务部门能一起操作、确认。另外如果有线下版本的协议，建议产品也可以看下，因为我们曾经遇见过一些渠道有业务处理时间的限制，但是没有写在线下开发文档中，是单独列在了协议中。在获取参数时，部分渠道是一定要通过测试案例提交才能获取正式参数，此处也需要留足项目时间。对接支付相关的 API ，按照自己内部支付模块以及支付渠道的对接开发文档对接开发即可。上线结果通知：这一步列在这里的原因是因为对外的技术服务商在日常工作中需要留足足够的时间给协同模块。关联模块功能更新：可以完成一笔成功的交易并不代表整个交易功能已经完善。比如对于交易明细的展示和管理、报表展示。后期商家内部渠道参数的更新、维护等配套模块也需要做更新。① 是否需要添加出口IP部分渠道需要添加 IP 白名单才可以进行开发、测试调试，有些渠道较快的能添加完成，但是有些银行类的可能要走比较漫长的线下申请。② 对接的接口版本不同支付渠道的接口版本对应的支付渠道的参数也不一样，所以在商务确定产品合作后需要确认对应的业务申请参数和渠道开发的接口版本是否一致。③ 订单号长度和组合支付机构遇到此类问题比较多。每个渠道的订单规则其实略有不同，例如招行早期的订单号只允许数字形式，不允许其他任何符号；微信、支付宝和银联对订单号的长度要求不同，因此建议订单号长度为 8~20 位，目前来看基本可以适配要求。④ 交易金额单位一般情况下单位都是以「分」为单位，但也遇到过以「元」为单位的情况。⑤ 商品描述特殊字符，是否展示在用户可见的渠道支付页部分渠道会因为在商品描述中加入了特殊字符而导致交易失败，然后因为报错提示信息不明显，会导致开发定位较长时间，另外需要确认该信息是否会展示在用户所见的渠道支付页上，避免字段设置的信息给用户产生疑惑。⑥ 收款公司名称展示常规情况下，大部分支付渠道是可以在后台进行设置或者在入网时有很清晰的提示，但是有些渠道是通过某个字段来进行填写并上传的，比如建行龙支付。⑦ 订单过期时间的模式确认绝对时间（ 某个固定的时间 ）相对时间（ 例如用户在支付页面密码输错了扣款失败，才开始计时 ）二维码有效期过期时间单位⑧分期支付是否支持前置展示主要是用户体验的问题，假设不做前置展示可能会在最后一步支付时流失掉这个订单。⑨ 是否支持禁用信用卡有些商家不希望用户支付使用信用卡，部分渠道可以通过请求参数字段进行设置，也有渠道通过入网签订协议后台配置。⑩ 前端带回的参数信息大部分商家比较在意前端带回的结果参数信息，例如订单号、支付结果等等① 可退款订单周期、权限开通之前在对接线下扫码支付，走服务商模式，退款权限并不默认开通，需要走线下申请的流程后才可以开通。可退款订单周期如之前提及，需要提前申请确认。② 单笔订单退款次数、频率限制例如微信是有单笔订单对多 50 次退款限制的，虽然实际场景中遇见单笔退款几十次概率很小，但一旦出现这类情况就需要做好线下给用户退款的准备。③ 是否支持原单重试这种场景微信比较多，微信现在文档上备注的已经十分详细了，尤其对于商家转账红包这种类型的出款，一定需要提前确认是否支持原单重试，避免重复出款。④ 是否支持部分退款& 是否退还手续费以及计算逻辑对接的渠道大部分都支持部分退款，但是有些个别的渠道是支持退款不退手续费。因此商家遇到用户退款的情况，就会在退款时损失手续费。同时对计算逻辑也要进一步确认，有些渠道的手续费分两部分，一部分是固定手续费，一部分是动态手续费。在退款时也会有全退、只退动态手续费不退固定手续费以及手续费全部不退的情况。⑤ 多选一单号请求，需要确认优先级这个在退款时微信、QQ 钱包都有过类似的问题，例如早期 QQ 钱包超过 30 天的订单如果不使用交易单号就会报错。因此如果渠道的文档表示两个字段二选一都行，就要提前确认好优先级。⑥ 退款描述特殊支付，是否展现在用户可见的地方这部分和前面是一样的，就不细说了。⑦ 是否支持退款的异步通知最早期的时候微信退款无异步通知，我们自己做了个自动查询模块，定时（5s、10s、20s、1min 等等递增）去调用退款查询接口来获取退款状态，现在微信也支持了退款成功的异步通知，主要的支付渠道也都支持了该功能。⑧ 是否区分退款资金来源这块主要是需要清楚地明白和业务的关联点在哪里，一般在退款接口上会有区分字段提示。⑨ 同步返回的状态，是否可以作为最终结果该种情况除了接口文档上的描述外，建议与渠道再做二次确认。通常是根据异步通知或者查询的退款结果进行更新，但是存在部分渠道建议直接根据创建退款同步返回结果直接判断的情况，比如支付宝国际的退款，并不提供退款查询接口。① 支付和退款的查询是否区分接口有的渠道不作区分，但有的渠道例如单号是区分支付成功单号以及退款单号两种不同的字段。② 确认查询接口展示的状态参数比如退款、用户被扫等模式可能存在多个状态，需要考虑多状态之间的关系和更新逻辑。③ 多选一单号查询，需要确认优先级与前文相同，不做赘述。④ 区分通信结果、业务结果、交易结果查询一个交易结果之前需要判断通信结果以及业务结果，最终展示的交易状态要根据交交易结果来判断。⑤ 结算金额、优惠金额、退款渠道等信息是否返回常规情况下渠道会通过支付成功之后的异步通知或者查询返回对应的信息，但是也存在部分渠道是通过后台配置的优惠信息，仅在支付成功页面、对账单中才有体现，并不会体现在交易返回参数中。⑥ 查询和异步通知返回的交易相关信息一致例如支付宝国际支付，查询与异步通知返回的信息不一致，是由于币种的转换造成的。存在部分返回信息需要提前邮件申请进行配置，虽然对外并没有文档指引和说明。⑦ 查询频率是否限制，是否有建议的查询间隔机制不同的渠道略有不同，有的渠道对频率有限制、间隔有限制。因此在前期需要确认。① 各种交易是否有异步通知产品与技术对接过程当中，需要稍微注意一下，因为渠道的文档都放一起，按照惯例是都有的，但是背不住要踩坑，比如线下支付的用户被扫模式。② 异步通知地址是请求上送还是后台固定配置不同渠道不一样，大部分是通过接口请求上送；小部分渠道通过后台固定地址配置。③ 何种状态会触发异步通知需要校验异步通知的状态类型，比如支付成功、订单支付中、订单关闭等等，避免未区分异步通知类型导致错误更新订单状态。④ 交易成功时间字段有些渠道交易成功时间这个字段不正确，可能会导致对账会出现一些问题，需要人工去处理。⑤ 是否带回交易请求上送的附加信息在渠道提供的交易请求信息并不足以区分商家内部的业务订单时，商家往往还会上送额外的字段信息，有些渠道有去无回，即异步通知不带回该额外信息，导致商家业务更新异常。⑥ 重试机制以及恢复信息重试机制需要提前确认，如果渠道间隔时间比较长，就需要提前在订单过期前之前加一些查询机制，避免用户体验糟糕。⑦ 签名验证或IP 白名单异步通知的验证真伪性一般可以通过签名或者 IP 白名单，如果是 IP 白名单的话提现与渠道确认好出口 IP 。2. 常见对接问题和解决方案一般情况下上图中的情况会导致交易异常，因此建议商家除了对接渠道异步通知也要对接查询接口，可以设置查询任务；同时不建议商家以业务查询结果为参考，查询服务端的订单状态，一旦不一致就调用接口去查询一下，更保险。还有不要查询频率太高，可能造成渠道结果返回不了。例如支付宝和微信使用线下渠道会有风控（ 一般线上套线下才会有 ），因此匹配自身场景去申请渠道是最安全的。渠道系统异常的情况，最好是多对接几个渠道，万一挂掉了一个另一个也不影响使用。渠道更新接口/ 规则没有及时同步的情况，这就需要经常爬一下各渠道的公告平台了。渠道数据状态不同步的情况只能去咨询渠道，根据渠道的建议去修改查询模块。本文由 @支付学院 原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "微信小程序实现类3D轮播图 ", "author": "Rolan", "pub_time": "2018-8-30 00:21", "article_content": "效果图如下：1.swiper的相关属性indicator-dots 是否显示小圆点，也可以自己重新设置小圆点circular 是否衔接滑动，就是实现无限滚动previous-margin 与上一张图片的间距next-margin 与下一张图片的间距autoplay 实现自动滚动这里主要利用了circular实现无限滚动，然后再加上前后间距，再设置图片的层级和透明度就可以实现了,将图片及容器的高度设置好就差不多可以实现了wxml文件<!--carousel/index.wxml-->\r\n<swiper class=\"imageContainer\" bindchange=\"handleChange\" previous-margin=\"50rpx\" next-margin=\"50rpx\" circular autoplay>\r\n  <block wx:for=\"{{3}}\" wx:key=\"{{index}}\">\r\n    <swiper-item class=\"item\">\r\n      <image class=\"itemImg {{currentIndex == index ? 'active': ''}}\" src=\"../../../image/3.jpg\"></image>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>wxss文件/* carousel/index.wxss */\r\npage{\r\n  background: #f7f7f7f7;\r\n}\r\n.imageContainer{\r\n  width: 100%;\r\n  height: 500rpx;\r\n  background: #000;\r\n}\r\n.item{\r\n  height: 500rpx;\r\n}\r\n.itemImg{\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 380rpx;\r\n  border-radius: 15rpx;\r\n  z-index: 5;\r\n  opacity: 0.7;\r\n  top: 13%;\r\n}\r\n.active{\r\n  opacity: 1;\r\n  z-index: 10;\r\n  height: 430rpx;\r\n  top: 7%;\r\n  transition:all .2s ease-in 0s;\r\n}JS文件// carousel/index.js\r\nPage({\r\n\r\n  data: {\r\n    currentIndex: 0\r\n  },\r\n\r\n  onLoad: function (options) {\r\n  \r\n  },\r\n  /* 这里实现控制中间凸显图片的样式 */\r\n  handleChange: function(e) {\r\n    this.setData({\r\n      currentIndex: e.detail.current\r\n    })\r\n  },\r\n})正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：画三角形webpack打包（有面试题）setInterval与setTimeout"}
{"title": "富文本解析-微信小程序 rich-text 组件 ", "author": "Rolan", "pub_time": "2018-8-30 00:23", "article_content": "微信小程序富文本解析器微信小程序在rich-text组件后开始支持富文本解析，但需要对照一套自定义规则的 JOSN 数据格式，API 返回的富文本需要前端做数据转换。这个主要是用于某些需要 API 直接输出富文本的地方。比如后端输出title字段, 但 title 字段中有加重提示的几个文字是需要标红的。这种情况下后端如果不返回富文本，前端去在小程序去处理是比较麻烦的，还得定个规则，前端再写好样式拼接起来。如果后端直接给你返回富文本，用这个去解析可以直接搞定。如官网给的例子：=如何才能将 HTML 转为微信小程序组件支持的数据格式呢？html2json 是一个将 HTML 解析为对应的 json 格式但 html2json 库转换出来的 JSON 与微信小程序要求不一致，且不支持解析 style，故在此库的基础上做的了扩展与调整。使用方法：import html2json from 'wxapp-rich-text';\r\n// 或者下载该仓库\r\nimport html2json from './your/path/index.js';\r\n\r\nconst html =\r\n  '<div id=\"this-id\" class=\"this-class\">sample<br/>text<h2 style=\"color: red;font-size:48rpx;\">sample text</h2></div>';\r\n\r\nconst json = html2json(html);\r\n\r\nthis.setData({\r\n    nodes: json,\r\n});\r\n源码见Github: https://github.com/treadpit/w...目前只测试了一些简单的例子，如下图："}
{"title": "微信小程序可实时改变转速的css3旋转动画 ", "author": "Rolan", "pub_time": "2018-8-30 00:38", "article_content": "先上效果图 最上面那一行就是个简单的换颜色效果，极其简答就不多说了，直接上代码。<view class='box' style='background-color:{{backgroundcolor}}'></view><view class='viewBox'>  <button bindtap='changeColor' data-color='black' class='box'>黑</button>  <button bindtap='changeColor' data-color='violet' class='box'>紫</button>  <button bindtap='changeColor' data-color='orange' class='box'>橙</button>  <button bindtap='changeColor' data-color='blue' class='box'>蓝</button>  <button bindtap='changeColor' data-color='green' class='box'>绿</button></view>JS  data: {    backgroundcolor:'red'  },  changeColor:function(e){    this.setData({      backgroundcolor: e.currentTarget.dataset.color    })  }那么下面咱们说一说这个旋转的动画。小程序里呢，有自己的动画api，但是用起来感觉极其麻烦，而且容易产生倒转，对设备的性能消耗也多，动画多了以后就会极其卡顿，所以还是css3的动画比较好。 首先来写这个css3动画 css3旋转动画<view class='animationSlow'></view>.animationSlow {   width: 100rpx;  height: 100rpx;  background-color: orange;  animation-name: myfirst; /*动画的名称 */  animation-duration: 2000ms; /*动画从开始到结束的时间*/  animation-timing-function: linear; /*动画执行快慢的参数*/  animation-iteration-count: infinite; /*动画执行多少次的参数*//*以下是兼容ios所需，参数意义与上相同*/  -webkit-animation-name: myfirst;  -webkit-animation-duration: 2000ms;  -webkit-animation-timing-function: linear;  -webkit-animation-iteration-count: infinite;}@keyframes myfirst {  /*开始转的角度*/  from {    transform: rotate(0deg);  }/*结束的角度*/  to {    transform: rotate(360deg);  }}/*兼容ios*/@-webkit-keyframes myfirst {  from {    transform: rotate(0deg);  }  to {    transform: rotate(360deg);  }}效果图 如果只是一个一次性的动画效果，现在这些代码就OK了。 如果想要实时可以改变旋转的转速，我们还得再加点东西。实现可以实时修改转速 微信小程序里涉及到实时数据就避免不了Page.data这个东西。 1.我们需要将控制动画时间的css属性放到内联样式中去<view class='animationSlow' style='animation-duration: 2000ms;-webkit-animation-duration: 2000ms;'></view>2.在页面对应的js中，设置掌控时间的Page.data属性，将wxml里内联属性的时间改为Page.data的属性。  data: {    animationTime:'2000ms'  },<view class='animationSlow' style='animation-duration: {{animationTime}};-webkit-animation-duration: {{animationTime}};'></view>3.接下来我们写几个按钮，绑定上修改这个时间的方法，进而来改变转速。这一步都是基本代码，我就不贴代码了。放个效果图吧。效果图那么接下来重点来了：其实这里有个bug，这个效果呢在安卓机上是一点点问题都没有的。但是在苹果机上，动画一旦开始，再通过这个方法去修改转速，就不能生效了。解决IOS系统的BUG 上面说了，IOS系统上呢，动画一旦开始，这个方法就不能用了。那么咱是不是可以先把这个动画停下来，然后再改转速呢？这个办法可不可以呢？答案是肯定的，但是不是去把动画时间改为0，而是采用了css3动画的一个属性。CSS3 动画教程animation-play-state: paused|running;简而言之就是先用这个属性把动画暂停，修改转速，然后再让它跑起来。这一切都得再js里进行。 1.需要在标签的内联样式里加上这个属性，在Page.data里再定义一个属性控制开始暂停。<view class='animationSlow' style='animation-duration: {{animationTime}};-webkit-animation-duration: {{animationTime}};animation-play-state:{{status}};-webkit-animation-play-state:{{status}};'></view> data: {    animationTime:'2000ms',    status: 'running'//paused  },2.然后我们去修改改变转速的方法。暂停>(修改>跑起来)，效果上稍微有些延迟。 changeTime:function(e){    this.setData({      status: 'paused'    })    this.setData({      timeAnimation: e.currentTarget.dataset.time,      status: 'running'    })  },3.来上效果图了。效果图可能动图上感觉不出来，不过你们可以去真机试一下，就可以展现出来了。本次分享结束(@LcFireRabbit)作者：LcFireRabbit 链接：https://www.jianshu.com/p/4c1928534c4f"}
{"title": "微信小程序抽奖-翻牌 ", "author": "Rolan", "pub_time": "2018-8-31 00:21", "article_content": "背景ps：本次开发基于wepy框架 由于最近接到一个需求--抽奖活动； 翻牌打乱活动抽奖活动，大概需求是这样的，九宫格卡牌，先正面展示所有奖品，然后卡牌翻转，打乱排序，点击卡牌，然后抽奖。这个需求本身其实不难，主要是分为三步；展示所有卡牌，然后翻转。打乱所有卡牌点击其中一张卡牌，抽奖第一步：卡牌翻转我们先在dom中渲染9个卡牌。<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}}>    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>在数据中生成模拟卡牌数据cardData: [    {      animationData: {},      front: '正面1',      back: '反面1'    },    ...    ...    {      animationData: {},      front: '正面9',      back: '反面9'    }  ],  showClass: false,在样式中把卡牌的基本样式渲染出来.card-module{  padding: 45rpx;  display: flex;  flex-direction: row;  flex-wrap: wrap;  transform:translate3d(0,0,0);  .card{    width: 200rpx;    height: 200rpx;    line-height: 200rpx;    text-align: center;    color: #fff;    margin: 10rpx;    position:relative;    overflow:hidden;    .card-item{      position:absolute;      left:0;      top:0;      width:100%;      height:100%;      transition:all .5s ease-in-out;      transform-style:preserve-3d;      backface-visibility:hidden;      box-sizing:border-box;    }    .front{      background-color: red;      transform: rotateY(0deg);      z-index:2;    }    .back{      background-color: #009fff;      transform: rotateY(180deg);      z-index:1;    }  }  .card.change{    .front{      z-index:1;      transform: rotateY(180deg);    }    .back{      z-index:2;        transform: rotateY(0deg);    }  }}效果如下这里有些css属性可能需要大部补充学习一下css3 backface-visibility 属性定义和用法 backface-visibility 属性定义当元素不面向屏幕时是否可见。 如果在旋转元素不希望看到其背面时，该属性很有用。CSS3 perspective 属性perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。第二步：卡牌打乱由于业务上是抽奖使用的，所以选择的方案是：翻转后，卡牌收回到中间的卡牌中间，然后再让卡牌回到原来的位置。 关于小程序的原生框架有支持的动画接口，若不了解的请前往： developers.weixin.qq.com/miniprogram… 在对动画有基本了解之后，我们可以开始在翻转的基础上加上打乱的动画了 微信小程序的动画接口使用方式是在dom对象上面加上animation对象。 dom<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}} animation=\"{{cardItem.animationData}}\" >    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>scriptallMove () {    // 110 是卡牌宽度加边距    this.methods.shuffle.call(this, 110)    let timer = setTimeout(() => {      clearTimeout(timer)      this.methods.shuffle.call(this, 0)      this.$apply()    }, 1000)},// 洗牌shuffle (translateUnit) {    let curCardData = this.cardData    curCardData.map((item, index) => {      let animation = wepy.createAnimation({        duration: 500,        timingFunction: 'ease'      })      animation.export()      switch (index) {        case 0:          animation.translate(translateUnit, translateUnit).step()          break        case 1:          animation.translate(0, translateUnit).step()          break        case 2:          animation.translate(-translateUnit, translateUnit).step()          break        case 3:          animation.translate(translateUnit, 0).step()          break        case 4:          animation.translate(0, 0).step()          break        case 5:          animation.translate(-translateUnit, 0).step()          break        case 6:          animation.translate(translateUnit, -translateUnit).step()          break        case 7:          animation.translate(0, -translateUnit).step()          break        case 8:          animation.translate(-translateUnit, -translateUnit).step()          break      }      item.animationData = animation.export()    })    this.cardData = curCardData    this.$apply()},算法后面需要优化，我们先完成功能效果， 效果如下第三步：卡牌翻转dom代码<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}}  {{curIndex === index ? 'getprize' : ''}}\" @tap=\"itemChage({{cardItem}}, {{index}})\" animation=\"{{cardItem.animationData}}\" >    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>script代码data中定义一个curIndex = -1的对象data = {      curOpen: -1,      }methods = {    // 抽奖      itemChage (item, curIndex) {        this.cardData[curIndex].front = 'iphone x'        console.log(item, curIndex)        this.curOpen = curIndex      }}less.card.getprize{    .front{      z-index:2;      transform: rotateY(0deg);    }    .back{      z-index:1;        transform: rotateY(180deg);    }  }效果如下现在我们就已经完成了基本的需求；但是在位移动画时候代码写的太丑陋了。 我们来想想怎么优化算法； 我们现在就九宫格布局，我们可以看成是二维布局那我们是不是可以在卡牌中也使用二维数组布局属性resetData () {    const total = 9 // 总数    const lineTotal = 3 // 单行数    curCardData.map((item, index) => {      let curCardData = this.cardData      let x = index % lineTotal      let y = parseInt(index / lineTotal)      item.twoArry = {x, y}    })}在位移动画中使用二维布局的差值进行位移// 洗牌shuffle (translateUnit) {    let curCardData = this.cardData    curCardData.map((item, index) => {      let animation = wepy.createAnimation({        duration: 500,        timingFunction: 'ease'      })      animation.export()      const translateUnitX = translateUnit * (1 - item.twoArry.x)      const translateUnitY = translateUnit * (1 - item.twoArry.y)      animation.translate(translateUnitX, translateUnitY).step()      item.animationData = animation.export()    })    this.cardData = curCardData    this.$apply()},这样整个动画就算完成了，demo请前往githubgithub.com/fishmankkk/…作者：fishman 链接：https://juejin.im/post/5b867460f265da435743a8de 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "微信小程序之判断页面滚动方向 ", "author": "Rolan", "pub_time": "2018-8-31 00:25", "article_content": "需求微信小程序中如果判断页面滚动方向？解决方案1.用到微信小程序API获取页面实际高度 nodesRef.boundingClientRect([callback])监听用户滑动页面事件onPageScroll。2.获取页面实际高度<!--WXML-->\r\n<view id=\"box\">\r\n   <view class=\"list\" wx:for=\"{{List}}\" wx:key=\"List{{index}}\">\r\n        <image mode='aspectFill' class='list_img'  src=\"{{item.imgUrl}}\"  ></image>\r\n   </view>\r\n</view>    /* JS */\r\n  // 封装函数获取ID为box的元素实际高度 \r\n  getScrollHeight: function() {\r\n    wx.createSelectorQuery().select('#box').boundingClientRect((rect) => {\r\n      this.setData({\r\n        scrollHeight: rect.height\r\n      })\r\n      console.log(this.data.scrollHeight)\r\n    }).exec()\r\n  },\r\n  // 假设数据请求\r\n  getDataList: function() {\r\n    wx.request({\r\n      url: 'test.php', //仅为示例，并非真实的接口地址\r\n      success: function(res) {\r\n      // 如果该元素下面的数据是动态获取的，此方法在wx.request请求成功的回调函数中调用\r\n        this.getScrollHeight()\r\n      }\r\n    })\r\n  },\r\n3.监听用户滑动页面事件    //监听用户滑动页面事件\r\n  onPageScroll: function(e) {\r\n   \r\n    if (e.scrollTop <= 0) {\r\n     // 滚动到最顶部\r\n      e.scrollTop = 0;\r\n    } else if (e.scrollTop > this.data.scrollHeight) {\r\n      // 滚动到最底部\r\n      e.scrollTop = this.data.scrollHeight;\r\n    }\r\n    if (e.scrollTop > this.data.scrollTop || e.scrollTop >= this.data.scrollHeight) {\r\n      //向下滚动 \r\n      console.log('向下 ', this.data.scrollHeight)\r\n    } else {\r\n      //向上滚动 \r\n      console.log('向上滚动 ', this.data.scrollHeight)\r\n    }\r\n    //给scrollTop重新赋值 \r\n    this.setData({\r\n      scrollTop: e.scrollTop\r\n    })\r\n  },参考：微信小程序如何判断页面上下滚动"}
{"title": "微信小程序UI规范 ", "author": "Rolan", "pub_time": "2018-9-1 00:12", "article_content": "微信小程序设计的基本原则是微信设计中心针对在微信类上线的小程序页面总结的设计指南及建议。以下设计原则都是基于对用户的尊重的基础上的，旨在微信生态类建立有号、高效、一致的用户体验的同时，最大程度顺应和支持各业务需求设计，实现用户与程序的共赢。一、有好礼貌为了避免用户在微信中使用小程序服务时，注意力被周围复杂环境干扰，小程序哎设计时应该注意减少无关的设计元素对用户目标干扰，礼貌地向用户展示程序侧提供的服务，友好地引导用户进行操作。1. 重点突出每个页面都应有明确的重点，以便于用户每进入一个新页面的时候都能快速地理解页面内容，在确定了重点的前提下，应尽量避免页面上出现其他干扰项影响用户的决策和操作。反例示意此页面的主题是查询，却添加了诸多与查询不相关的业务入口，与用户的预期不符，易造成用户的迷失。纠正示意去掉任何与用户目标不相关的内容，明确页面主题，在技术和页面控件允许的前提下提供有助于用户目标的帮助内容，比如最近搜索词，常用搜索词等。反例示意操作没有注册，让用户无从选择纠正示意首先要避免并列过多操作让用户选择，在不得不并列多个操作时，需区分操作主次，减轻用户的选择难度。2. 流程明确为了让用户顺畅地使用页面，在用户进行某一个操作流程时，应避免出现用户目标流程之外的内容而打断用户。反例示意用户本打算进行搜索，在进入页面时却被突如其来的抽奖弹窗所打断；对于抽奖没有兴趣的用户是非常不友好的干扰，平添一份对开发团队的恼怒；而即使有部分用户确实被“诱人”的抽奖活动所吸引，离开主流程去抽奖之后可能就遗忘了原本的目标，进而失去了对产品真正价值的利用和认识。二、清晰明确作为一个负责任的开发者，一旦用户进入我们的小程序页面，就有责任和义务清晰明确告知用户身在何处、又可以往何处去，确保用户在页面中游刃有余地穿梭而不迷路，这样才能为用户提供安全的愉悦的使用体验。1. 导航明确，来去自如导航是确保用户在网页中浏览跳转时不迷路的最关键因素。导航需要告诉用户，我在哪，我可以去哪，如何回去等问题。首先在微信系统内的所有小程序的全部页面，均会自带微信提供的导航栏，统一统一解决我在哪，如何回去的问题。在微信层级导航保持体验一致，有益用户在微信内形成较为统一的体验和交互认知，无需在各小程序和微信切换中新增学习成本或使用习惯。微信导航栏微信导航栏，直接继承于客户端，除导航栏颜色之外，开发者无需亦不可以对其中的内容进行自定义。但开发者需要规定小程序各个页面的跳转关系，让导航系统能够以合理的方式工作。微信导航栏分为导航区域、标题区域以及操作区域。其中导航区控制程序页面进程。目前导航栏分深浅两种基本配色，在iOS和Android展示有所不同，如下图所示：导航区（iOS）导航区通常只有一个操作，即返回上一级界面。开发者可定义其内容，不可对样式进行修改。导航区（Android）通常情况下，系统导航左侧唯一的操作为“离开小程序，回到微信，程序后台运行”。当用户进入小程序次级页面后，我们建议小程序自身可以设计返回操作，同事用户也可以通过安卓系统自带的硬件返回按钮返回上一级。微信导航栏自定义颜色规则（iOS和Android）小程序导航栏支持基本的背景颜色自定义功能，选择的颜色需要在满足可用性前提下，和谐搭配微信提供的两套主导航栏图标。建议参考以下选色效果：选色方案示例：页面内导航开发者可根据自身功能合计需要在页面内添加自有导航。并保持不同页面间导航一致。但是受限于手机屏幕尺寸的限制，小程序页面的导航应尽量简单，若仅为一般线性浏览的页面建议仅使用微信导航栏即可。微信控件库提供tab导航供开发者选择。tab栏可固定在页面顶部或者底部，便于用户在不同的tab页面间作切换。为确保点击区域，tab项不得超过4项。一个页面也不应出现一组以上的tab栏。2. 减少等待，反馈及时页面的过长时间的等待会引起用户的不良情绪，使用微信小程序项目提供的技术已能很大程度缩短等待时间。即便如此，当不可避免的出现了加载和等待的时候，需要予以及时的反馈以舒缓用户等待的不良情绪。启动页设计小程序启动也是小程序在微信内容一定程度上展现品牌特征的页面之一。本页面将突出展示小程序品牌特征和加载状态。启动页除LOGO品牌展示外，页面上的其他所有元素如加载进度指示，由微信统一提供且不能更改。无需开发者开发。下拉标示区微信类所有小程序页面，都会再下拉时出现微信为其统一设计的标示区。品牌展示区由品牌名称和微信小程序提示组成。目的是强化品牌和用户对小程序的产品感知。下拉标示（iOS深浅两色方案）微信提供深浅两套配色方案，如此处标示所示，文字颜色不可自定义，开发者在自定义背景色时，应注意保证下拉标示的辨识度。下拉标示（Android深浅两色方案）微信下拉提示用于给用户明确的小程序归属者，防止造假与作弊。此处标示提供深浅两套方案，文字颜色不可自定义，开发者在自定义背景色时，应注意保证下拉标示的辨识度。页面刷新交互（iOS）开发者可自定义需要通过下拉交互完成刷新的页面，此类交互微信将提供标准能力和样式。在样式上，刷新图标与下拉标示配色已捆绑，分为深浅两套方案，开发者在使用时，应注意头部文字、下拉标示与刷新图标的和谐统一。但用户在该类页面做出下拉交互时，出现微信小程序页面标准加载动画。开发者无需自行开发样式。在开发者没有在页面顶部设计tab的情况下，若定义该页面可通过下拉动作刷新，则刷新后加载状态提示语小程序品牌展示区出现在标题栏之下，页面顶部。开发者暂无法执行定义此加载效果。在开发者定义了页面顶部tab并定义该Tab下的内容页面可通过下拉动作刷新，则刷新后加载状态提示语小程序品牌展示区出现在顶部Tab之下，且仅刷新当前页面内容。开发者暂无法自行定义此加载效果。页面刷新交互（Android）与iOS相同，在样式上，Android下刷新图标与下拉标示配色已捆绑，分为深浅两套方案，开发者在使用时，应注意头部文字、下拉标识与刷新图标的和谐统一。微信下拉标示错误使用案例请避免以下错误使用情况，确保信息的可见性和页面的可用性。页面内导航微信控件库提供深浅tab导航方案供开发者选择。tab栏需固定在页面顶部，便于用户在不同的tab页面间作切换。为确保点击区域，tab项不得超过4项。一个页面也不应出现一组以上的tab栏。Tab栏选中态默认为100%实色，未选中态带有60%，其中选中态颜色可自定义。在自定义颜色选择中，务必保持Tab的可用性、可视性和可操作性。页面内加载反馈开发者可在小程序里自定义页面内容的加载样式。建议不管是使用在局部还是全体，自定义加载样式都应该尽可能简洁，并使用简单动画告知用户加载过程。开发者也可以使用微信提供的，统一的页面加载样式，如图中例所示。模态加载模态的加载样式将覆盖整个页面的，由于无法明确告知具体加载的位置或内哦让那个将可能引起用户的焦虑感，因此应谨慎使用。除了在某些全局性操作下不要使用模态的菊花。局部加载反馈即旨在触发加载的页面局部进行反馈，这样的反馈机制更加有针对性，页面改动小，是微信推荐的反馈方式。例如：加载反馈注意事项若加载时间较长，应提供取消操作，并使用进度条显示载入的进度。载入过程中，应保持动画效果；无动画效果的加载很容易让人产生该界面已经卡死的错觉。不要再同一个页面使用超过1个加载动画。结果反馈除了在用户等待的过程中需予以及时反馈外，对操作的结果也需要予以明确反馈。根据实际情况看，可选择不同的结果反馈样式。对于页面局部的操作，可在操作区域予以直接反馈，对于页面级操作结果，可使用toast、弹窗或结果页面展示。页面局部操作结果反馈对于页面局部的操作，可在操作区域予以直接反馈，例如点击多选控件前后如下图。对于常用控件，微信设计中心已提供控件库及WeUI控件库，其中的控件都已设计有完整的操作反馈。页面全局操作结果——toast其中toast适用于轻量级的成功提示，1.5秒后自动消失，并不打断流程，对用户影响较小，适用于不需要强调成功专题的操作提醒。特别注意toast形式不适用于任何错误提醒。页面全局操作结果——弹框对于需要用户明确知晓的操作结果状态可通过弹框来提示，并可附带下一步操作指引。页面全局操作结果——结果页对于操作结果已经是当前流程的终结的情况，可使用操作结果页来反馈。这种方式最为强烈和明确的告知用户操作已经完成，并可根据实际情况给出下一步操作的指引。3. 异常可控，有路可退在设计任何的任务和流程时，异常状态和流程往往容易被忽略，而这些异常场景往往是用户最为沮丧和需要帮助的时候，因此需要格外注意异常状态的设计，在出现异常时予以用户必要的状态提示，并告知解决方案，使其有路可退。要杜绝异常状态下，用户莫名其妙又无处可去，卡在某一个页面的情况。2.2中所提到的弹窗和结果页面都可作为异常状态的提醒方式。除此之外，在表单页面中尤其是表单项较多的页面中，还应明确指出出错项目，以便用户修改。异常状态——表单出错表单报错，在表单顶部告知错误原因，并标识出错误字段提示用户修改。三、便捷优雅从PC时代的物理键盘鼠标到移动端时代手指，虽然输入设备极大精简，但是手指操作的准确性却大大不如键盘鼠标精确。为了适应这个变化，需要开发者在设计过程中充分利用手机特性，让用户便捷优雅的操控界面。1. 减少输入由于手机键盘区域小且密集，输入困难的同时还易引起输入错误，因此在设计小程序页面时因尽量减少用户输入，理由现有接口或其他一些易于操作的选择控件来改善用户输入的体验。减少输入，巧用接口例如下图中，在添加银行卡时，采用摄像头识别SDK接口来帮助用户输入。除此之外微信团队还对外开放例如地理位置接口等多种SDK接口（详见微信JS-SDK），充分利用这些接口将大大提高用户输入的效率和准确性，进而优化体验。除了利用接口外，在不得不让用户进行手动输入时，应尽量让用户做选择而不是键盘输入。一方面，回忆易于记忆，让用户在有限的选项中做选择通常来说是容易于完全靠记忆输入；另一方面，仍然是考虑到手机键盘密集的单键输入极易造成输入错误。例如图中，在用户搜索时提供搜索历史快捷选项将帮助用户快速进行搜索，而减少或避免不必要的键盘输入。2. 避免误操作一位内在手机上我们通过手指触摸屏幕来操控界面，手指的点击精确度远不如鼠标，因此在设计页面上需点击的控件时，需要充分考虑到其热区面积，避免由于可点击区域过小或过于密集而造成误操作。当简单的将原本在电脑屏幕上使用的界面不做任何适配直接移植到手机上时，往往就容易出现这样的问题。由于手机屏幕分辨率各不相同，因此最适宜点击像素尺寸也不完全一致，但换算成物理尺寸后大致是在7mm-9mm之间。在微信提供的标准控件库中，各种控件均已考虑到了页面点击效果以及不同屏幕的适配，因此再次推荐使用或模仿标准控件尺寸进行设计。3. 利用接口提升性能微信设计中心已推出了一套网页标准控件库，包括sketch设计控件库和WeUI重构代码库，这些控件都已充分考虑了移动端页面的特点，能够保证其在移动端页面上的可用性和操作性能；同事微信web开发团队也在不断完善和扩充微信JS-SDK接口，并提供微信公共库，利用这些资源不但能够为用户提供更加快捷的服务，而且对页面性能的提高有极大作用，无形之中提升了用户体验。四、统一稳定除了以上所提到的种种原则，建议接入微信的小程序还应该时刻注意不同页面间的统一性和延续性，在不同的页面尽量使用一致的控件和交互方式。统一的页面体验和有延续性的界面元素都将帮助用最少的学习成本达成使用目标，减轻页面跳动所造成的不适感。正因如此，小程序可根据需要使用微信提供的标准控件，以达到统一稳定的目的。五、视觉规范为方便设计师进行设计，微信提供一套可供Web设计和小程序使用的基础控件库；同时方便开发者调用。1. 字体规范常用字号为20，18，17，16，14，13，11（pt），使用场景具体如下：微信类字体的使用与所运行的系统字体保持一致，以导航为例，iOS与Android对应字体如下：导航（iOS和Android）字体颜色主内容Black黑色，次要内容Grey灰色；时间戳与表单缺省值Light灰色；大段的说明内容而且属于主要内容用Semi黑；蓝色为链接用色，绿色为完成字样颜色，红色为出错用色Press与Disable状态分别降低透明度为20%与10%；2. 列表视觉规范3. 表单输入视觉规范4. 按钮使用原则列表外按钮上文字标准按钮高度为44px下使用：颜色#000000 / #353535 字号18pt可点状态下文字调整透明度为60%不可点状态下文字调整透明度为30%列表外按钮上文字标准按钮高度为25px下使用：颜色#000000 / #353535 字号14pt页面线性按钮上文字标准按钮高度为35px下使用：颜色#09BB07 / #353535 字号16pt5. 图标使用原则"}
{"title": "微信小程序 canvas区间滑动选取 ", "author": "Rolan", "pub_time": "2018-9-1 00:21", "article_content": "目标js文件使用 import 引入; 然后在onLoad(){}里面要一下写入例如: this.selectInterval = new selectInterval({属性});        this.selectInterval = new SelectInterval({        canvasId:'canvas',             值必须是canvas组件的canvas-id属性的值        canvasHeight:100,              值必须是当前画布的高度        Xaxis:{left:30,right:345},     { left:30, 横条的左端 right:345, 横条的右端 }(right必须大于left,如果不传有默认值)        scale:[10,20,30],              刻度值Array类型,取值以一个不变数为常量不断递增,数组任何两个前后值相减要恒等于这个常量,如果数组第一个值不是0,                                      会默认在数组前面添加一个0,但是0这个值不会在canvas上显示,(当数组长度是2的时候,                                 可以设置任意大于零的数值,但第二个值必须大于第一个值);        Yaxis:[125,5],                 刻度值Array类型,第一个值是绘制的横条的起始高度,第二个值是横条本身的高度(如果不传默认[125,5])        manner:true,                   切换选择滑动点的上方在滑动的时候是否有跟随圆球，如果值为false那么明确显示区间滑动所得的最小值与最大值        bothEndsNear:310,              可以设置刻度值和尺度点距离横条的开头与终点的距离,不传默认居中        // decimalPoint:10,            刻度值/decimalPoint,可以使刻度值变小数,必须是10的倍数,可以不传        // rightSliderStop:2,          值为一个Boolean或者在manner的值为true的时候可填number,可以不传;而number的值就是最大值与最小值的差，设置后两个滑动点是不会滑动到小于这个number的距离        showTitle:{            name:'km',                   String类型,用作设置单位            size:15,                     标签字体大小,Number类型            title:'#1384e0',             头部标签的字体颜色或者圆球里面的字体颜色,String类型            positionX:100,               标签字体在canvas横向的位置,Number类型，只有manner为false或者不传的时候生效            positionY:80,                标签字体或者圆球在canvas纵向的位置,Number类型            isfollow:{                   跟随圆球大小与颜色的设置,manner的值为false或不传的时候,这个属性可以不给                view:true,           manner的值为true时，view的值必须为true                roundSize:12,        圆球大小                roundColor:'rgba(10, 113, 238, 0.8)' 圆球的颜色            }        },(如果不传不会显示头部标签)        scaleIn:{            name:'km',                   String类型,用作设置单位            size:10,                     控制刻度值字体的大小,Number类型            valueY:108,                  刻度值在canvas纵坐标的位置,Number类型            pointY:113                   尺度点在canvas纵坐标的位置,Number类型        },(如果不传不会显示刻度值)        colour:{            colorBar:['#e5e5e5','#1384e0'],     横条的颜色,Array类型,第一个是横条的底色,第二个是取值范围的颜色            roundColor:['#ffffff','#e5e5e5'],   圆圈颜色,Array类型,第一个是圆的颜色,第二个是圆的边框颜色            scale:['#000000','#999999']         刻度数值的字体颜色        },(如果不传会显示上面的默认参数)        selectedInterval:{            min:15,            max:23         },(min不能大区等于max,如果不传只会显示在横条的两端)        round:{            radius:10,            edgeLine:2        },(如果不传会默认圆的半径为10,边框为2)        // image:{        //  url:'../../assets/image/spot-a.png',   图片的本地路径值为String类型；值可以为数组，但是如果是数组时数组的长度必须是2        //  width:20,                              设置图片的宽度        //  height:24                              设置图片的高度        // },(如果不传不会显示图片)        followValue:{            name:'',                               String类型,用作设置单位            color:'#f8835f',            size:10,                               设置字体大小            leftY:151,                             随数值在canvas纵向的位置            rightY:151        }(如果不传不会显示跟随数值)    });/**Page({})里面创建如下属性 必须自定义(e){ bindtouchstart    this.selectInterval.move(e.changedTouches[0].x,e.changedTouches[0].y);},自定义(e){ bindtouchmove    this.selectInterval.meter(e.changedTouches[0].x);},自定义(e){ bindtouchend    this.selectInterval.texthints((min,max)=>{        参数min/max返回的值是最小/大价格,超过最大值max返回null        console.log(min,max);    },true);初始化时传入manner属性的值为true时候,这个函数的第二个参数的true就要传,不传也没什么问题，只是结果会有不同;},<canvas canvas-id=\"canvas\" bindtouchstart=\"自定义\" bindtouchmove=\"自定义\" bindtouchend=\"自定义\"></canvas>画布css样式width:100%;box-sizing: border-box;height: 自定义rpx;"}
{"title": "【微信小程序】Text2Image ", "author": "Rolan", "pub_time": "2018-9-3 00:13", "article_content": "今天给大家分享如何制作一个Text2Image微信小程序。视频地址【内含源码下载链接】BiliBiliYoutube【微信小程序】text2imagehttp://v.youku.com/v_show/id_XMzgwNzEyNDM0NA==.html参考微信小程序 绘图 API接口使用canvas生成朋友圈分享图片并保存到手机相册主要功能添加文字选择背景选择字体大小生成图片保存图片到相册步骤创建项目导入weui for 小程序样式库添加text2image页面添加布局添加逻辑完成 & 测试创建项目导入weui for 小程序样式库下载weui for 小程序样式文件https://github.com/Tencent/we...将weui.wxss添加到项目中引入全局样式// app.wxss\r\n@import '/src/wxss/weui.wxss';添加text2image页面// app.json\r\npages: [\r\n  'pages/text2image/text2image',\r\n  ...\r\n]添加以上代码，注意新页面放在pages数组第一个，确保小程序的首页为text2image，修改完之后并保存，添加新页面为下图时就成功了！添加布局<!--pages/text2image/text2image.wxml-->\r\n\r\n<view class=\"page\">\r\n  <view class=\"page__bd\">\r\n    <view class=\"weui-cells__title\">内容</view>\r\n    <view class=\"weui-cells weui-cells_after-title\">\r\n      <view class=\"weui-cell\">\r\n          <view class=\"weui-cell__bd\">\r\n            <textarea class=\"weui-textarea\" bindinput='typeNewContent' value=\"{{content}}\" placeholder=\"请输入文本\"/>\r\n          </view>\r\n      </view>\r\n    </view>\r\n\r\n    <view class=\"weui-cells__title\">生成图片</view>\r\n    <view class=\"weui-cells weui-cells_after-title\">\r\n      <canvas style=\"width:{{windowWidth}}px;height:{{contentHeight}}px\" canvas-id=\"myCanvas\"></canvas>\r\n    </view>\r\n\r\n    <view class=\"weui-cells__title\">设置</view>\r\n    <view class=\"weui-cells weui-cells_after-title weui-btn-area\">\r\n      <button type=\"primary\" bindtap=\"chooseBackgroundImage\">选择背景图片</button>\r\n\r\n      <view class=\"section\">\r\n        <view class=\"section__title\">选择文字颜色</view>\r\n        <picker bindchange=\"bindPickerChange\" value=\"{{fontColorIndex}}\" range=\"{{fontColors}}\">\r\n          <view class=\"picker\">\r\n            当前选择：{{fontColors[fontColorIndex]}}\r\n          </view>\r\n        </picker>\r\n      </view>\r\n    </view>\r\n    \r\n    <view class=\"weui-btn-area\">\r\n      <button type=\"primary\" bindtap=\"savePic\" wx:if=\"{{hasGenerate}}\">保存图片</button>\r\n    </view>\r\n  </view>\r\n</view>// pages/text2image/text2image.wxss\r\n\r\npage {\r\n  background-color: #F8F8F8;\r\n}添加逻辑设置data// pages/text2image/text2image.js\r\n\r\ndata: {\r\n    windowWidth: 0, // 窗口宽度\r\n    contentHeight: 0, // 内容高度\r\n    content: '', // 内容\r\n    lineHeight: 30, // 行高 \r\n    fontColorIndex: 0, // 当前字体颜色\r\n    fontColors: [\r\n      'black',\r\n      'red',\r\n      'white',\r\n      'green'\r\n    ], // 字体颜色列表\r\n    backgroundImage: '../../src/images/leaves.png', // 背景图片\r\n    hasGenerate: false, // 是否已经生成图片\r\n},导入背景图片获取窗口宽度// pages/text2image/text2image.js\r\nonLoad: function (options) {\r\n    let that = this;\r\n\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        that.setData({\r\n          windowWidth: res.windowWidth\r\n        })\r\n      }\r\n    });\r\n},解析文字内容// pages/text2image/text2image.js\r\n\r\nparseContent: function () {\r\n    let that = this;\r\n\r\n    let i = 0;\r\n    let lineNum = 1;\r\n    let thinkStr = '';\r\n    let thinkList = [];\r\n    for (let item of that.data.content) {\r\n      if (item === '\\n') {\r\n        thinkList.push(thinkStr);\r\n        thinkList.push('a');\r\n        i = 0;\r\n        thinkStr = '';\r\n        lineNum += 1;\r\n      } else if (i === 19) {\r\n        thinkList.push(thinkStr);\r\n        i = 1;\r\n        thinkStr = item;\r\n        lineNum += 1;\r\n      } else {\r\n        thinkStr += item;\r\n        i += 1;\r\n      }\r\n    }\r\n\r\n    thinkList.push(thinkStr);\r\n\r\n    return thinkList;\r\n  }绘制背景// pages/text2image/text2image.js\r\n\r\ndrawBackground: function (ctx) {\r\n    ctx.drawImage(this.data.backgroundImage);\r\n}绘制文字// pages/text2image/text2image.js\r\n\r\ndrawFont: function (ctx, content, height) {\r\n    ctx.setFontSize(16);\r\n    ctx.setFillStyle(this.data.fontColors[this.data.fontColorIndex]);\r\n    ctx.setTextAlign('center');\r\n    ctx.fillText(content, this.data.windowWidth / 2, height);\r\n}清空画布// pages/text2image/text2image.js\r\n\r\nclearCanvas: function (ctx, width, height) {\r\n    ctx.clearRect(0, 0, width, height);\r\n}创建图片// pages/text2image/text2image.js\r\n\r\ncreateNewImg: function (thinkList) {\r\n    let that = this;\r\n\r\n    let lineNum = thinkList.length;\r\n\r\n    let ctx = wx.createCanvasContext('myCanvas');\r\n\r\n    this.clearCanvas(ctx, that.data.windowWidth, that.data.contentHeight);\r\n\r\n    let height = 60;\r\n\r\n    let contentHeight = (lineNum - 1) * that.data.lineHeight + 2 * height;\r\n\r\n    that.setData({\r\n      contentHeight: contentHeight\r\n    });\r\n\r\n    that.drawBackground(ctx, contentHeight);\r\n\r\n    for (let item of thinkList) {\r\n      if (item !== 'a') {\r\n        that.drawFont(ctx, item, height);\r\n        height += that.data.lineHeight;\r\n      }\r\n    }\r\n    ctx.draw();\r\n}生成图片// pages/text2image/text2image.js\r\n\r\ngenerateImage: function() {\r\n    let thinkList = this.parseContent();\r\n\r\n    this.createNewImg(thinkList);\r\n\r\n    this.setData({\r\n      hasGenerate: true\r\n    });\r\n}设置页面显示时生成图片// pages/text2image/text2image.js\r\nonShow: function(options) {\r\n    this.generateImage();\r\n}这一步的目的是页面初始化页面数据。绑定输入新内容事件// pages/text2image/text2image.js\r\n\r\ntypeNewContent: function(e) {\r\n    this.setData({\r\n      content: e.detail.value.trim()\r\n    });\r\n\r\n    this.generateImage();\r\n}现在尝试在内容文本框中输入文字，文字会实时显示在下面的图片区域。选择背景图片// pages/text2image/textimage.js\r\n\r\nchooseBackgroundImage: function () {\r\n    let that = this;\r\n\r\n    wx.chooseImage({\r\n      success: function (res) {\r\n        that.setData({\r\n          backgroundImage: res.tempFilePaths[0]\r\n        });\r\n\r\n        that.generateImage();\r\n      }\r\n    })\r\n},从本地相册选择背景图片或使用照相机拍照，选择成功之后重新生成图片。绑定选择字体颜色事件// pages/text2image/text2image.js\r\n\r\nbindPickerChange: function(e) {\r\n    let that = this;\r\n\r\n    that.setData({\r\n      fontColorIndex: e.detail.value\r\n    });\r\n\r\n    that.generateImage();\r\n},点击选择文字颜色区域，即可进行颜色选择，可以在fontColors数组中添加 【更多预定义颜色】。保存图片// pages/text2image/text2image.js\r\n\r\nsavePic: function () {\r\n    let that = this;\r\n    wx.canvasToTempFilePath({\r\n      x: 0,\r\n      y: 0,\r\n      width: that.data.windowWidth,\r\n      height: that.data.contentHeight,\r\n      canvasId: 'myCanvas',\r\n      success: function (res) {\r\n        that.savePicToAlbum(res.tempFilePath);\r\n      }\r\n    }, this)\r\n  },\r\n\r\n  savePicToAlbum: function (tempFilePath) {\r\n    let that = this;\r\n    wx.getSetting({\r\n      success(res) {\r\n        if (!res.authSetting['scope.writePhotosAlbum']) {\r\n          wx.authorize({\r\n            scope: 'scope.writePhotosAlbum',\r\n            success() {\r\n              wx.saveImageToPhotosAlbum({\r\n                filePath: tempFilePath,\r\n                success(res) {\r\n                  wx.showToast({\r\n                    title: '保存成功'\r\n                  });\r\n                },\r\n                fail(res) {\r\n                  console.log(res);\r\n                }\r\n              })\r\n            },\r\n            fail() {\r\n              // 用户拒绝授权,打开设置页面\r\n              wx.openSetting({\r\n                success: function (data) {\r\n                  console.log(\"openSetting: success\");\r\n                },\r\n                fail: function (data) {\r\n                  console.log(\"openSetting: fail\");\r\n                }\r\n              });\r\n            }\r\n          })\r\n        } else {\r\n          wx.saveImageToPhotosAlbum({\r\n            filePath: tempFilePath,\r\n            success(res) {\r\n              wx.showToast({\r\n                title: '保存成功',\r\n              });\r\n            },\r\n            fail(res) {\r\n              console.log(res);\r\n            }\r\n          })\r\n        }\r\n      },\r\n      fail(res) {\r\n        console.log(res);\r\n      }\r\n    })\r\n  }点击保存图片按钮即可保存生成的图片。"}
{"title": "微信小程序 - 多地点标识(map) ", "author": "Rolan", "pub_time": "2018-9-3 00:21", "article_content": "演示如下：wxml1 <map id=\"map\"  scale=\"{{scale}}\" controls=\"{{controls}}\" bindcontroltap=\"controltap\" markers=\"{{markers}}\" bindmarkertap=\"markertap\" bindregionchange=\"regionchange\" show-location style=\"width: 100%; height: 580px;\"></map>js  1 let hospitalData = require('hospitalData')  2 Page({  3   data: {  4     centerX: 0.0,  5     centerY: 0.0,  6     //可能我标识的地点和你所在区域比较远，缩放比例建议5;  7     scale:15,  8     markers: [],  9     controls: [{ 10       id: 1, 11       iconPath: '/image/location-control.png', 12       position: { 13         left: 0, 14         top: 10, 15         width: 40, 16         height: 40 17       }, 18       clickable: true 19     }] 20   }, 21   onReady: function(e) { 22     // 使用 wx.createMapContext 获取 map 上下文  23     this.mapCtx = wx.createMapContext('myMap') 24   }, 25  26   onLoad: function() { 27     console.log('地图定位！') 28     let that = this 29     wx.getLocation({ 30       type: 'gcj02', //返回可以用于wx.openLocation的经纬度 31       success: (res) => { 32         let latitude = res.latitude; 33         let longitude = res.longitude; 34         let marker = this.createMarker(res); 35         this.setData({ 36           centerX: longitude, 37           centerY: latitude, 38           markers: this.getHospitalMarkers() 39         }) 40       } 41     }); 42   }, 43  44   /** 45    * 标示点移动触发 46    */ 47   regionchange(e) { 48     console.log(e.type) 49   }, 50  51   /** 52    * 点击标识点触发 53    */ 54   markertap(e) { 55     console.log(e) 56   }, 57  58   /** 59    * control控件点击时间 60    */ 61   controltap(e) { 62     console.log(e.controlId) 63     this.moveToLocation() 64   }, 65  66  67   /** 68    * 获取医院标识 69    */ 70   getHospitalMarkers() { 71     let markers = []; 72     for (let item of hospitalData) { 73       let marker = this.createMarker(item); 74       markers.push(marker) 75     } 76     return markers; 77   }, 78  79   /** 80    * 移动到自己位置 81    */ 82   moveToLocation: function() { 83     let mpCtx = wx.createMapContext(\"map\"); 84     mpCtx.moveToLocation(); 85   }, 86  87  88   /** 89    * 还有地图标识，可以在name上面动手 90    */ 91   createMarker(point) { 92     let latitude = point.latitude; 93     let longitude = point.longitude; 94     let marker = { 95       iconPath: \"/image/location.png\", 96       id: point.id || 0, 97       name: point.name || '', 98       latitude: latitude, 99       longitude: longitude,100       width: 25,101       height: 48102     };103     return marker;104   }105 })hospitalData.js （模拟数据） 1 module.exports = [{ 2     \"id\": 1, 3     \"name\": \"永州市中心医院\", 4     \"longitude\": \"111.62852107566833\", 5     \"latitude\": \"26.42142999357519\" 6   }, 7   { 8     \"id\": 2, 9     \"name\": \"永州市中医院\",10     \"longitude\": \"111.5972679762268\",11     \"latitude\": \"26.44470581245983\"12   }13 ]运行示例时，建议放在同一目录下."}
{"title": "小程序之canvas图片及文本适配 ", "author": "Rolan", "pub_time": "2018-9-3 00:32", "article_content": "场景需求小程序目前不支持直接分享到朋友圈，所以对于有分享到朋友圈的需求，一般是生成一张图片，例如，生成一张带有小程序码的图片，用户可以将这张图片保存到手机本地，然后将这张图片分享到朋友圈。这张图片需要使用canvas画出来。今天我们不讲怎么生成码，这个一般是后端封装一个API，前端通过调用API得到一个小程序码的url，通过image去画到canvas上，跟在canvas上画一个image是一样的逻辑。这篇文章主要是讲怎么在canvas上适配图片和文字，也就是怎么将图片和文本画到canvas上的正确的位置，能在不同的手机上都能正确的展示。效果图展示（以下图片是在微信开发者工具中显示的） 这里演示的Demo是： “选择图片”button选择一张图片，可以居中显示在以下图中的黄色区域，即canvas中，并在canvas的顶部居中展示文本“你若盛开，蝴蝶自来”。以下是两个不同尺寸的图片画在canvas上，分别在iphone5、iphone6、iphone6 plus上的展示效果图。这里的猫图片的原始尺寸：658*658这里的girl图片的原始尺寸是：700*699代码说明小程序尺寸单位小程序尺寸单位2. wxml<button bindtap=\"chooseImg\">选择图片</button><view class=\"canvas-box\">    <canvas class=\"canvas\" canvas-id=\"shareCanvas\" bindlongtap=\"saveShareImage\"></canvas></view>$3. scss（wxss） 这里我用的是scss去写样式代码，在webStorm中可以通过配置，将scss解析成wxss，至于具体怎么配置，可以自行百度。 PS1：这里定义了一个scss rpx function，是因为在webStrom中格式化代码的时候会将数字和单位rpx中间添加一个空格，导致编译报错，所以用一个function去处理 PS2：样式说明（设计稿是基于iphone6视觉稿标准）： button宽高：700rpx * 92rpx (350px * 46px) 包裹canvas的容器的view（.canvas-box）position:fixed,占据除顶部button的高度之外，填满剩余全部空间，canvas居中显示，宽高：700rpx， 100%@function rpx($value) {  @return $value*1rpx;}page {  background-color: #fff6f6;  button {    width: rpx(700);    height: rpx(92);    background-color: #ffddab !important;  }  .canvas-box {    position: fixed;    top: rpx(92);    left: 0;    right: 0;    bottom: 0;    canvas {      position: absolute;      width: rpx(700);      height: 100%;      top: 50%;      left: 50%;      transform: translate(-50%, -50%);    }  }}$4. js 1、在data中定义三个变量data: {        windowWidth: 0, // 可使用窗口宽度        windowHeight: 0, // 可使用窗口高度        ratio: 0 // 根据尺寸动态计算 1px换算成多少rpx    }2、通过wx.getSystemInfo获得系统信息，并且计算ratio    onReady: function (e) {        // 获取系统信息        wx.getSystemInfo({            success: res => {                console.log(res);                this.setData({                    windowWidth: res.windowWidth,                    windowHeight: res.windowHeight,                });                this.setData({                    // 屏幕宽度 375px = 750rpx，1px=2rpx                    // 1px = （750 / 屏幕宽度）rpx；                    // 1rpx = （屏幕宽度 / 750）px;                    ratio: 750 / this.data.windowWidth                });            }        });    },3、button的触发事件chooseImg，通过wx.chooseImage选择图片，通过wx.getImageInfo获取选择的图片的大小chooseImg: function () {        wx.chooseImage({            count: 1,            success: res => {                let imgUrl = res.tempFilePaths[0];                // 获取图片大小                wx.getImageInfo({                    src: imgUrl,                    success: data => {                        let imgWidth = data.width;                        let imgHeight = data.height;                        // 创建canvas，根据选择的图片大小，在canvas上绘制图片和文字                        this.createCanvasShareImage(imgUrl, imgWidth, imgHeight);                    }                });            }        });    }4、创建canvas并在canvas上添加图片和文本 createCanvasShareImage: function (imgUrl, imgW, imgH) {        // 使用wx.createCanvasContext获取绘图上下文 context        let context = wx.createCanvasContext('shareCanvas');        console.log('context: ', context);        // 获取canvas的宽度：        // 750的设计稿基于iphone6的尺寸（屏幕宽度： 375px）在小程序中的比例是： 1px = 2rpx ==> 375px = 750rpx ==> 屏幕宽度(px) = 750rpx        // 所以 1rpx = 屏幕宽度 / 750        // 我们这里css中设置的 canvas 的width：700rpx, 所以 canvas的宽度计算是： [（屏幕宽度 / 750）* 700]rpx， 这样就可以做到在不同手机上都可以适配        let canvasWidthPx = 700 / this.data.ratio;        // 设置 canvas 的背景并填充canvas        context.fillStyle = '#ffdc22';        context.fillRect(0, 0, canvasWidthPx, this.data.windowHeight);        // 绘制图片：图片居中显示在 canvas 中        let imgX = (700 - imgW) / 2;        let imgY = (this.data.windowHeight * this.data.ratio - 46 * this.data.ratio - imgH) / 2;        let clipWidth = imgW * this.data.ratio;        let clipHeight = imgH * this.data.ratio;        context.drawImage(imgUrl, -imgX, -imgY, clipWidth, clipHeight, 0, 0, imgW, imgH);        // 设置字体大小、文本颜色        context.setFontSize(20);        context.fillStyle = \"#000\";        // 计算文本的宽度：measureText() 取到文本的 width        let txtWidth = context.measureText('你若盛开，蝴蝶自来').width;        // 绘制居中文本：这个地方的 (x, y)的坐标是在文本的左下角位置        context.fillText(\"你若盛开，蝴蝶自来\", (canvasWidthPx - txtWidth) / 2, 20 * this.data.ratio);        context.draw();    }5、长按bindlongtapcanva保存图片或者直接预览图片，先通过wx.canvasToTempFilePath将当前画布指定区域的内容导出生成指定大小的的图片，再通过wx.saveImageToPhotosAlbum将图片保存到本地，或者通过wx.previewImage直接预览图片。    saveShareImage() {        wx.canvasToTempFilePath({            canvasId: 'shareCanvas',            success: (res) => {                console.log('canvasToTempFilePath： ', res);                // 将图片保存到相册                wx.saveImageToPhotosAlbum({                    filePath: res.tempFilePath,                    success: (data) => {                        console.log(data);                    }                });                // 直接预览图片                wx.previewImage({                    urls: [res.tempFilePath]                })            }        })    }真机效果图显示（一加六手机） 一加6手机显示的小程序效果图.png保存到手机本地的图片.png作者：豆豆的故事 链接：https://www.jianshu.com/p/75fa54f6caa8"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发 ", "author": "admin", "pub_time": "2016-10-12 22:39", "article_content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:46", "article_content": "效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical 加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain 事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot 是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 global，这个 global 是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 requester.js 里面的封装。图二是需要调用数据的页面渲染。"}
{"title": "微信小程序开发教程第一章：微信小程序开发实操指南 ", "author": "admin", "pub_time": "2016-10-12 22:49", "article_content": "序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1. 获取微信小程序的 AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的 AppID。 利用提供的帐号，登录 https://mp.weixin.qq.com ，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的 AppID 了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份 - 开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的 AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3. 编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch: function () {// 调用 API 从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{// 调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。```/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}```### 4. 创建页面在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。index.wxml 是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了 、、 来搭建页面结构，绑定数据和交互处理函数。index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js// 获取应用实例var app = getApp()Page({data: {motto: 'Hello World',userInfo: {}},// 事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this// 调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){// 更新数据that.setData({userInfo:userInfo})})}})```index.wxss 是页面的样式表：```/**index.wxss**/.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。index.json 是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。**logs 的页面结构**```{{index + 1}}. {{log}}```logs 页面使用 控制标签来组织代码，在 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点//logs.jsvar util = require('../../utils/util.js')Page({data: {logs: []},onLoad: function () {this.setData({logs: (wx.getStorageSync('logs') || []).map(function (log) {return util.formatTime(new Date(log))})})}})运行结果如下：5. 手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。* 下载最新微信开发者工具，打开后你会看到该界面：* 点击「新建 web+」项目，随后出现如下画面：* 该页面内的各项内容需要注意——* AppID：依照官方解释来填。* Appname: 项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。* 本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。* 准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。* 如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的 demo 项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："}
{"title": "微信小程序开发教程第二章：项目构架 ", "author": "admin", "pub_time": "2016-10-12 23:08", "article_content": "微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着 h5 的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上 Console 可以看到：在首页 console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。* wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。* wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。* wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是一操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的 rem.js 也是不支持的。此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！* 找到项目文件夹，导入你的编辑器里面。在这里，我使用了 Sublime Text 编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。* 接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。* 示例项目的「tabBar」是五个菜单按钮：* 找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：* 你可以根据实际项目需求更改，其中：* 「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。* 「“list”」下的代码顺序必须依次放置，不能随便更改。* 「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。* 「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。* 「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。* 「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。* 根据以上代码规则，我做好了示例项目的基本架构，供你参考：* 「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。* 以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。* 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：* 修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。* 另外，公共样式可以在「app.wxss」里直接引用。* 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"}
{"title": "微信小程序开发教程第三章：项目结构以及配置 ", "author": "admin", "pub_time": "2016-10-12 23:22", "article_content": "找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app 的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 tabar 高度会减少很多。 Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar 以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css 文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js 目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 pages 里面才能生效。"}
{"title": "微信小程序开发教程第四章：首页面开发 ", "author": "admin", "pub_time": "2016-10-12 23:26", "article_content": "进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template 名片很多，需要用模板、这里需要微信提供的基础组件大致是 input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC 跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* 名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* Template：定义一个模板，name 模板的名字其实是个作用域。* Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template 时非常方便，is 和 name 一样，data 是 nameData 传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json 数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css 是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 bindChange 为输入框发生改变事件。微信提供的 bindchange 在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js 里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; //this绑定，这个this指向微信的提供windowvar Text = e.detail.value.toUpperCase(); //取到输入的内容if(Text==\"\"){ //如果输入为空 一些东西需要显示 否则不显示show_letter = \"block\";}else{show_letter = \"none\";}this.setData({show_letter:show_letter,showSheet:true});var res = nameData; 获取到传递的数据if(data_type==\"name\"){}else if(data_type==\"time\"){res = timeData; };for(var k in res){ //for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = 0;iIf(data[i].userName!=null && data[i].userName.indexOf(Text)!=-1){data[i][\"display\"] = \"block\"; //存在就是赋值显示}else{data[i][\"display\"] = \"none\"; // 不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js 配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: 调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom 长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC 跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"}
{"title": "微信小程序开发教程第八章：分组开发与左滑功能实现 ", "author": "admin", "pub_time": "2016-10-12 23:31", "article_content": "整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时 bindinput 事件，大家别使用 bindchange 事件，这里的 bindchange 事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了 from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件 bindtouchstart 与 bindtouchmove，这里必须绑定它的 id，这个 id 都是不同的，我这使用的用户创建完成后在后台生成的一个 id 号，之后我再 block 出来使用在这里，这个 id 都是唯一的，不能是相同的 id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了 css3 的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap 点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart 发生后，会执行 bindtouchmove 事件，在这里我们可以判断是否左右滑动：* Var dataId = e.currentTarget.id //获取到前面唯一的id；If(key){ //用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；* Touch是获取触摸点的一些数据，touches 是一个触摸点的数组，每个触摸点包括以下属性：* pageX,pageY：距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴；* clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；* screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用 clientX,clientY 即可。我们在 bindtouchstart 时记录到开始的点，在 bindtouchmove 记录到触摸结束的点，如果 X 轴滑动大于 Y 轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在 wxml 里面 block 的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的 id== 当前被事件操作的 id，那么我给改数组再添加一个 right 向右偏移 15%，否则其他都不偏移，右滑同理，直接全部设置为 0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X 轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个 catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在 data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是 copy 首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给 checked 设置 Boole 开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是 from 表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。"}
{"title": "微信小程序试用报告：前端源码逻辑和工作流 ", "author": "天下雪", "pub_time": "2016-10-13 16:49", "article_content": "文件基本结构：  　  先看入口app.js，app(obj)注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  }})  　  我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性  　  onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。  　  var logs = wx.getStorageSync('logs') || []获取本地缓存中的logs属性，如果值为空，那么设置logs=[] 与HTML5中的localStorage作用相似logs.unshift(Date.now()) 当前登录时间添加到数组中  　  wx.setStorageSync('logs', logs) 将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据  　  getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数    var that = this    if(this.globalData.userInfo){//用户信息不为空      typeof cb == \"function\" && cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；    }else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {　　　　　　　　 console.log(res)              that.globalData.userInfo = res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口              typeof cb == \"function\" && cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息            }          })        }      })    }  }   　  globalData对象用来存储全局数据，在其他地方调用  　  然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等、  　  最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。 {  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  }}  　  然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。  　  先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。  　  index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。　　<!--index.wxml--><view class=\"container\">//视图容器  <view  bindtap=\"bindViewTap\" class=\"userinfo\">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js page()设置添加    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view>  　  index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个 OBJECT 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var app = getApp() // 获取入口文件app的应用实例Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //自定义事件处理函数，点击.userinfo的容易触发此函数  bindViewTap: function() {    wx.navigateTo({//全局对象wx的跳转页面方法      url: '../logs/logs'    })  },  onLoad: function () {//发生页面加载时，自动触发该生命周期函数    console.log('onLoad')    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据，页面自动渲染      that.setData({        userInfo:userInfo      })    })  }})  　  index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。  　  再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。  　  logs.wxml文件<!--logs.wxml--><view class=\"container log-list\">  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>    <text class=\"log-item\">{{index + 1}}. {{log}}</text>  </block></view>  　　logs.js 文件//logs.jsvar util = require('../../utils/util.js') //util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({  data: {    logs: []  },  onLoad: function () {    this.setData({      logs: (wx.getStorageSync('logs') || []).map(function (log) {//通过wx.getStorageSync获取本地缓存的logs日志数据        return util.formatTime(new Date(log))//日期格式化      })    })  }})　　logs.json文件{    \"navigationBarTitleText\": \"查看启动日志\"   //当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}　　基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。"}
{"title": "小程序的持续集成方案 ", "author": "Rolan", "pub_time": "2018-8-2 00:08", "article_content": "半年前，有机会开始接触微信小程序开发。却因为只是接触而并没投入开发小程序的过程中，因此对很多小程序的细节并未有充分的理解，仅仅停留在了解类似的理论层面，比如mpvue修改了 Vue.js 的 runtime 和 compiler 实现了编译及运行在原生小程序能力，比如原生小程序不支持npm包的使用及管理等，当然那时候的技术细节难点都是由非常给力的好同事解决消化了，所以也没多去细究。最近，我开始投入到完成的小程序开发迭代里，却发现一个头痛的问题，如何准确并快速的的把小程序上传去后台，并让测试人员进行测试。问题当遇到多个开发人员并行开发不同功能模块的同一小程序，往往就会遇到测试人员需要进行测试的时候，让开发人员切换至测试分支后，进行构建编译和上传，最终把上传后生产的二维码提供出来进行测试使用。若当前开发人员在认真coding，为某个功能正在奋斗。突然被别人打断并告诉你需要为他提供一个测试环境的二维码….因为为了这个二维码，需要做的事情是：git stashgit checkout branchnpm installnpm run build点击“预览”，生成二维码，或点击上传，更新体验版提供二维码出去后，恢复刚刚的工作状态git checkout branchgit stash popnpm installnpm run dev不断回想刚刚的开发思路理想流程上面所说的，只是一个常见的场景，但是思考一下，这个场景的重复率是否很高，重复这类操作的价值究竟有多少？为了解决不让开发人员为了一个测试环境的二维码而痛苦，我尝试把gitlab ci 和 微信开发者工具的能力进行对接尝试。在理想的流程里，开发人员只需要针对对应的分支进行合并或提交即可，无需关心如何把项目编译及版本分发交付到测试或体验人员手上。接下来，对项目分支的管理不展开过多的说明，只设定develop分支是自动触发小程序持续集成（ 安装依赖、构建、上传至体验版本 ）的目标。微信开发者工具微信开发者工具有提供5个接口能力，并且提供cli 和 http方式调用：命令行启动工具命令行登录命令行提交预览命令行上传代码支持自动化测试由于这次目标只需要把对应develop分支的代码上传微信更新为体验版本，所以微信开发者工具的接口能力最主要的是第4个（命令行上传代码）。如果是功能分支也需要创建预览二维码，可以通过第3个接口能力实现cli和http的调用有什么区别cli方式通过命令行调用安装完成的工具可执行文件，完成登录、预览、上传、自动化测试等操作。调用返回码为 0 时代表正常，为 -1 时错误。 命令行工具所在位置： macOS: <安装路径>/Contents/Resources/app.nw/bin/cli Windows: <安装路径>/cli.bathttp 方式http 服务在工具启动后自动开启，HTTP 服务端口号在用户目录下记录，可通过检查用户目录、检查用户目录下是否有端口文件及尝试连接来判断工具是否安装/启动。 端口号文件位置： macOS : ~/Library/Application Support/微信web开发者工具/Default/.ide Windows : ~/AppData/Local/微信web开发者工具/User Data/Default/.ide说白了，cli可以直接通过调用命令行工具，而http需要先寻找端口再进行接口调用，更适合跨机器调用。 根据我当前情况，选择了cli方式。设置构建机器公司的Mac mini 类似的机器暂时没有资源，不得不回到Windows上进行构建机的设置。但是坑还是挺多，可能一方面也是对windows的不熟悉吧。最后还是选择在Windows上装vmware，在vmware上运行Mac os。在Mac上面，安装微信开发者工具，如何下载安装就没必要多说了。接下来还需要安装gitlab runner，gitlab runner是用来运行你定制的任务（jobs）并把结果返回给 GitLab。 GitLab Runner 配合GitLab CI（GitLab 内置的持续集成服务） 协调完成任务。详情可以查看后面的引用文章。在Mac上安装gitlab runner最简单的是用brew，当然另外下载应用包也是可以的brew install gitlab-runner # 安装gitlab runner\r\nbrew services start gitlab-runner # 开机自动运行\r\ngitlab-runner start # 只需要直接运行（不需要开机自动运行）\r\n复制代码安装完成后，可以进行runner的配置，主要需要提供gitlab url，项目仓库的token，runner tags等，详细信息请参考 Registering Runners | GitLab 中文文档gitlab-runner register \r\n复制代码编写CI文件CI文件编写，最主要是项目根目录上创建一个名为.gitlab-ci.yml，每一行的stages:\r\n  - build # 总体CI的过程，暂时只有一个job：build\r\n\r\nbefore_script:\r\n  - shopt -s expand_aliases # 开启扩展aliases功能 issue https://gitlab.com/gitlab-org/gitlab-runner/issues/1083\r\n  - alias wxcli=\"/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli\" # 指定微信开发者工具cli命名为wxcli\r\n  - type wxcli # 验证wxcli命令是否存在\r\n  - wxcli # 启动微信开发者工具（其实好像有点多余，因为如果当前没启动微信开发者工具，在wxcli -u的时候也会启动）\r\n  - source ~/.bash_aliases # 读取特点的alias，比如配置的nvm，issue https://gitlab.com/gitlab-org/gitlab-runner/issues/1958 \r\n  - npm install # 安装依赖\r\n\r\n# 测试环境\r\ntest-build:\r\n  stage: build # 对应stages上的job名称\r\n  script:\r\n    - npm run build\r\n    - curr_commit_content=`git log -1 --pretty=format:%s` # 获取最近提交的git内容\r\n    - curr_version=`node -p \"require('./package.json').version\"` # 获取package的版本号\r\n    - curr_proj_path=`pwd` # 当前项目路径\r\n    - wxcli -u $curr_version@$curr_proj_path --upload-desc $curr_commit_content # 提交微信开发者\r\n\t  - # 上传成功后，你可以尝试发送一些通知提醒大家可以去打开新版本了，比如钉钉的webhook\r\n  only:\r\n    - develop\r\n  tags:\r\n    - xxx_mp\r\n\r\n复制代码查看构建结果查看构建结果也是很简单，直接在gitlab仓库里的CI/CD —— pipeline 进行查看测试人员和体验人员可以从小程序开发助手上查看最新体验版（记得要在微信小程序后台把该CI用户上传的版本设定成体验版）真的不要再去做重复的工作，太影响心情了。"}
{"title": "微信小程序朋友圈分享图片生成方案实现 ", "author": "Rolan", "pub_time": "2018-8-9 00:03", "article_content": "在小程序界里，生成图片分享到朋友圈这个功能，是如此得光芒耀眼，以至于各个小程序都趋之若鹜地前来跪倒在她的石榴裙下。不幸的是，微信爸爸并没有提供给我们很好很便捷的相关工具；恰恰相反，屏幕截屏的功能被残忍丢进历史的垃圾桶，只留下一个Canvas组件以及围绕在其周围的深渊巨坑们。所以我们准备了一套名为Painter的工具， 为开发者提供一种简单实用的“绘制”图片的解决思路，让开发者可以自由地生成自己想要的图片文件。github传送门： github.com/Kujiale-Mob…如果直接使用canvas进行绘图，那绝对是很酸爽的一次体验，除了失控的代码，还有无数的天坑。先来列举一下canvas 中踩过的坑以及我们的解决（或绕过）的方法。canvas的坑painter从实现上来讲，是用了小程序的canvas作为载体来实现以上功能的。而canvas有很多著名的坑。有的坑，我们小心翼翼地绕了过去；有的坑，我们还是痛快淋漓地一脚踩了下去……在微信版本6.6.6的某些ios机型上，canvas的clip()方法不能被restore。导致在这些机型上无法进行切圆角的操作。迫于无奈在开发中我们不得已抛弃了这些机型，用了一个if语句将这些机器的切圆角功能阉割了。。。小程序的canvas提供了measuretText()方法，暂时只支持测量文本宽度，无法知道文字的具体高度。因此一些元素对齐的需求无法做到很漂亮。在绘制图片的时候，有几率会发生很神奇的表现，即canvas绘图的时候位置出现整体偏差，造成最后生成的图片有残缺。这种情况大多数时候发生在onLoad中调用painter的情况下。我们处理的方法是对图片的宽和高比例进行检测，一旦出现异常，就重新绘制一遍。canvas不能绘制网络图片。canvas.drawImage(url)方法，给url传入一个网络链接，在模拟器上表现完美，然而在真机上无法绘制。我们在Painter中引入了一套自己的网络图片下载后绘制的机制，并在其中加入了LRU存储管理机制。canvas是原生组件，始终位于视图的最上层，z-index设置对其无效。这个就不多说了。。很多人应该都踩过。canvas要进行绘制，则canvas组件必须真实地被写在页面上，而且其wx:if不能为false。不过，允许把canvas组件放置在屏幕之外，如设置position:fixed;left:750rpx;。这一方法是可以解决5，6两点问题的黑科技Painter的功能如图所示通过右边的类似于css又有点像json但其实上它是个js的寥寥几行代码，我们绘制出了左边的这样的图形，包含了背景图片、文字、图片、二维码这四种常用的元素。Painter阅读完代码，绘制成图片以后，会将图片的链接返回给我们。此时，我们可以将图片上传、保存到本地或者显示在屏幕上。它可以很方便地定制所需要的图片，还可以自由动态地给图片更换风格。此外，小程序canvas.drawImage()方法在真机上不能绘制网络图片。而Painter 可以解决这个问题，如果有绘制网络图片的需求也可以考虑使用Painter。Painter其它优势painter可以下载网络图片到本地，并对下载到本地的网络内容进行LRU管理。目前小程序允许的最大本地储存为10m，我们默认painter可使用的本地存储为6m，超出时会对本地存储进行清理。如果需要自定义，可以在/painter/lib/downloader.js中修改MAX_SPACE_IN_B属性。目前子 view 的 css 属性支持 object 或 array。允许将几个view公用的css属性提取出来。由于palette 是以 js 承载的 json，所以你可以在每一个属性中很方便的加上自己的逻辑。也可以把某些属性单独提取出来，让多个 palette 共用，做到模块化。使用demo下载demo项目使用submodule的方式进行管理，因此在clone时需要运行git clone https://github.com/Kujiale-Mobile/Painter.git --recursiveclone完成后可以看到目录。其中，/pages/example中存放的是使用示例，/components/painter就是我们所引入的功能组件。此外还有一个palette目录，里面存放是我们所需要绘图代码。实际工作时，painter会调取card.js里的信息，在图片上绘制出相应的图形，就像一支画笔在调色板上调制蘸取了颜料，然后在画布上创作一样。将Painter引入到自己的项目你可以直接将demo里的painter复制粘贴到自己的项目下，当然也可以更为优雅地运行一下这个代码：git submodule add https://github.com/Kujiale-Mobile/PainterCore.git painter它会将Painter工具放置在你当前的目录下。我们推荐的做法是把它放在你的components下。引入组件像其它的组件一样，在需要引入Painter的页面.json文件中添加：\"usingComponents\":{\r\n  \"painter\":\"/components/painter/painter\"\r\n}组件调用在页面的xml文件中调用painter组件，并传入pallete规则的数据，以及绘制结束以后的回调。<painter palette=\"{{data}}\" bind:imgOK=\"onImgOK\" bind:imgErr=\"onImgErr\"/>palette即是我们的调色板数据，以json形式根据一定规范创建，详细信息请移步下文。绘制回调bind:imgOK=\"onImgOK\"\r\nbind:imgErr=\"onImgErr\"数据传入后，painter就会开始绘制，无论绘制成功或是失败，都能在相应的回调方法里获取相关的信息，如：Pallette说到底，Painter是一支画笔工具，具体要让这支画笔画什么东西，还得由我们，天资聪颖的程序猿们，来告诉它。告诉它应该画什么，在哪里画，画的时候用什么姿势……等等。这需要用一些别的手段，因为科学的实验证明过，试图用普通话这门语言跟它进行沟通，是不会有任何效果的。调色板属性每一块调色板都它自己的整体属性，它一般规定了整个绘图范围的大小、样式、背景等它处于整个json文件的最外层，需要指定以下几个属性：示例代码：{\r\n      background: 'https://qhyxpicoss.kujiale.com/2018/06/12/LMPUSDAKAEBKKOASAAAAAAY8_981x600.png',\r\n      width: '654rpx',\r\n      height: '400rpx',\r\n      borderRadius: '20rpx',\r\n      views: []\r\n }view属性画完了调色板的整体属性以后，就可以向views中增加一些元素了。元素支持四种类型，用type字段进行区分分类。不同种类的view又要求提供有不同的数据，如image元素需要提供它的url，text元素需要提供text文字内容：除了各view的私有属性之外，view还有一些公共属性可以设置：rotate控制元素的旋转，如下图，将一行文字顺时针旋转了6度。{\r\n    type: 'text',\r\n    text: '酷家乐 移动前端',\r\n    css: {\r\n     left: '20rpx',\r\n     top: '50rpx',\r\n     fontSize: '40rpx'\r\n   },\r\n},效果：borderRadius代码(圆形)：{\r\n          type: 'image',\r\n          url: this.cardInfo.avatar,\r\n          css: {\r\n            top: '48rpx',\r\n            left: '448rpx',\r\n            width: '192rpx',\r\n            height: '192rpx',\r\n            borderRadius:'96rpx',\r\n          },\r\n        },方角-->8rpx圆角-->圆形align这个属性值比较有意思，它被用来设置元素在水平方向的、相对于位置设置的对齐方式。什么意思呢？比如说你设置了某元素的left为100rpx，并设置align属性为left，那么该元素的左端就与100rpx对齐；若设置align为center，则该元素的中轴线与100rpx对齐。在下面的例子中，三行文字的left都是230rpx，align分别为left, center, right。红线是横坐标为230rpx的轴线。即，当设置了align属性的时候，left值表达的是元素属性中align的位置。代码：{\r\n          type: 'text',\r\n          text: '酷家乐 移动前端',\r\n          css: {\r\n            left: '330rpx',\r\n            top: '100rpx',\r\n            fontSize: '40rpx',\r\n          },\r\n        },\r\n        {\r\n          type: 'text',\r\n          text: '酷家乐 移动前端',\r\n          css: {\r\n            left: '330rpx',\r\n            top: '200rpx',\r\n            fontSize: '40rpx',\r\n            align: 'center'\r\n          },\r\n        },\r\n        {\r\n          type: 'text',\r\n          text: '酷家乐 移动前端',\r\n          css: {\r\n            left: '330rpx',\r\n            top: '300rpx',\r\n            fontSize: '40rpx',\r\n            align: 'right'\r\n          },\r\n        },有了这个属性，就可以设置元素的对齐形式，完成下面的布局要求了：注意：align属性请和left属性配合使用，设置right值将造成错误。align与rotate当align属性与rotate属性同时存在时，元素的旋转表现是以元素的中心点为中心的。尺寸单位目前 Painter 中支持两种尺寸单位，px 和 rpx，代表的意思和小程序中一致。目前还没有很好地支持百分比的使用。保存图片演示获得图片的url后，可以设置一个点击按钮，点击保存到本地onImgOK(e) {\r\n    this.imagePath = e.detail.path;\r\n  },\r\n\r\n  saveImage() {\r\n    wx.saveImageToPhotosAlbum({\r\n      filePath: this.imagePath,\r\n    })\r\n  },按钮绑定saveImage方法，点击进行保存：生成朋友圈分享图最后，利用Painter工具可以生成不同样式的朋友圈分享图(下图为微信小程序 酷咖名片 线上版部分截图)"}
{"title": "把微信小程序异步API转为Promise，简化异步编程，告别层层回调 ... ", "author": "Rolan", "pub_time": "2018-8-15 00:15", "article_content": "把微信小程序异步API转化为Promise。用Promise处理异步操作有多方便，谁用谁知道。微信官方没有给出Promise API来处理异步操作，而官方API异步的又非常多，这使得多异步编程会层层回调，代码一复杂，回调起来就想砸电脑。于是写了一个通用工具，把微信官方的异步API转化为Promise，方便处理（多）异步操作。你可以这样用：准备转化后的方法并暴露出// /utils/wx-promise.js\r\nimport toPromise from '/module/to-promise/src/index'\r\n\r\nconst toPromiseWx = toPromsie(wx)\r\n\r\nexport const request = toPromiseWx('requset')\r\nexport const getLocation = toPromiseWx('getLocation')\r\nexport const setStorage = toPromiseWx('setStorage')\r\n\r\n//export 其他你项目中可能用到的异步API在其他文件中使用在App.js中使用：//App.js\r\nimport { request } from './utils/wx-promise.js'\r\n\r\nApp({\r\n  onLanuch: () => {\r\n    request({ url: 'http://api.yourapi.com' })\r\n      .then(() => {\r\n        //成功后处理\r\n      })\r\n      .then(() => {\r\n        //失败后处理\r\n      })\r\n  }\r\n})在其他page中使用：// /page/index.js\r\nimport { request, setStorage } from '../utils/wx-promise.js'\r\n\r\npage({\r\n  onLoad: () => {\r\n    request({ url: 'http://api.yourapi.com' })\r\n      .then(() => {\r\n        //成功后处理\r\n      })\r\n      .then(() => {\r\n        //失败后处理\r\n      })\r\n  },\r\n  onHide: () => {\r\n    setStorage({\r\n      key: 'yourkey',\r\n      data: 'yourvalue'\r\n    })\r\n      .then(() => {\r\n        //保存成功\r\n      })\r\n      .then(() => {\r\n        //保存失败\r\n      })\r\n  }\r\n})项目地址：to-promise其他更多更具体用法，直接粘贴README了，如下。to-promise是一个转换微信小程序异步API为Promise的一个工具库优点：避免小程序异步编程多次回调带来的过多回调导致逻辑不清晰，篇幅过长等问题。借助于Promise异步编程特点，支持链式操作，像同步一样写异步。转化后得API几乎和微信官方API一样。使用方法：安装使用git安装到项目根目录/module,git clone https://github.com/tornoda/to-promise或直接下载放入项目目录下如：/module在需要用到的地方引入import toPromise from '/module/to-promise/src/index'绑定微信全局对象(wx)到函数，以便可以取到微信得APIconst toPromiseWx = toPromise(wx)开始转化你需要得异步API//apiName为微信异步方法名，如对wx.request()进行转化\r\nconst request = toPromiseWx('request')\r\n//直接使用request方法举例：import toPromise from '/module/to-promise/src/index'\r\n\r\n//转换wx.getStorage()\r\nconst getStorage = toPromsie(wx)('getStorage') \r\n\r\n//使用\r\ngetStorage({ key: 'test' })\r\n  .then(\r\n    (res) => {\r\n      //res的值与wx.getStorage({ success: (res) => {} })中的res值一样\r\n      //res = {data: 'keyValue'}\r\n      console.log(res.data)//控制台打印storage中key对于的value\r\n      return res.data//如果需要继续链式调用转化后的api，需要把值显示返回\r\n    },\r\n    (err) => {\r\n      //err的值与wx.getStorage({ success: (err) => {} })中的err值一样\r\n      throw err\r\n    }\r\n  )关于Promise对象的使用，请参见PromiseAPItoPromise(global)参数(wx): wx全局对象。即toPromise(wx)这样调用返回(function): 参数(string)为小程序异步方法名。返回一个函数，该函数的参数与返回值如下。参数：(object) 对应wx小程序异步方法中的参数(OBJECT)除去success与fail后的对象。例如：官方APIwx.getLocation(OBJECT)的OBJECT接受如下属性： type altitude success fail complete，那么去除（success fail）后为：type altitude complete。返回: (pending Promsise) 返回一个未知状态的Promise对象，在该对象上调用.then(onFulfilled, onRejected)方法来处理对用成功或失败的情况。onFulfilled为请求成功后调用的回调函数，参数为返回值，onRejected为请求失败后的回调函数，参数为返回的错误信息。简单点来说，const getLocation = toPromiseWx('getLocation')\r\ngetLocation({\r\n  type: 'wgs84',\r\n  altitude: true,\r\n  complete: () => { console.log('to-promsise is awesome') }\r\n}).then(\r\n  (res) => {//dosomething if succeed},\r\n  (err) => {//dosomething if failed}\r\n)与下面官方调用等价wx.getLocation({\r\n  type: 'wgs84',\r\n  altitude: true,\r\n  complete: () => { console.log('to-promsise is awesome') },\r\n  success: (res) => {//dosomething if succeed},\r\n  fail: (err) => {//dosomething if failed}\r\n})应用场景举例单次异步调用，参见API最后多次异步操作调用，且每下一次调用都会用到前一次返回的结果。如：获得GPS信息后，根据GPS信息获取天气信息，取得天气信息后立马存入localStorage。import toPromise from '/module/to-promise/src/index'\r\n\r\nconst toPromiseWx = toPrmise(wx)\r\n\r\n//方法转换\r\nconst getLocation = toPromiseWx('getLocation')\r\nconst request = toPromiseWx('request')\r\nconst setStorage = toPromiseWx('setStorage')\r\n\r\n//链式写逻辑\r\ngetLocation() //获取位置信息\r\n  .then(\r\n    (res) => { //位置获取成功后的处理，res为返回信息\r\n      //处理res后返回有用的信息，这里直接返回res，用于演示\r\n      return Promise.resolve(res) //必须\r\n    },\r\n    (err) => { //位置获取失败后的错误处理，err为错误信息\r\n      //错误处理\r\n      return Promise.resolve(err) //必须\r\n    }\r\n  )\r\n  .then(\r\n    (res) => { //根据位置获取成功后的信息，请求天气信息\r\n      return request({ url: 'http://api.weather.com'}) //返回一个pending 状态下的Promise\r\n    }\r\n  )\r\n  .then(\r\n    (res) => {  //天气获取成功后存入storage的回调\r\n      setStorage({\r\n        key: 'test',\r\n        data: 'res'\r\n      })\r\n    },\r\n    (err) => {\r\n      //天气获取失败后执行这里，err为获取天气失败的错误信息\r\n    }\r\n  )如果使用官方的API写上述逻辑，代码是这样的：wx.getLocation({\r\n  success: (res) => {\r\n    //some transformation with res\r\n    wx.request({\r\n      url: 'http://api.weather.com',\r\n      success: (res) => {\r\n        wx.setStorage({\r\n          success: () => {\r\n            //do something\r\n          },\r\n          fail: (err) => {\r\n            //do something if err happend\r\n          }\r\n        })\r\n      },\r\n      fail: (err) => {\r\n        //do something if err happend\r\n      }\r\n    })\r\n  },\r\n  fail: (err) => {\r\n    //do something if err happend\r\n})\r\n//层层回调，如果逻辑再复杂点，可能就疯了"}
{"title": "小程序生成海报保存分享图片完全指南 ", "author": "Rolan", "pub_time": "2018-8-21 00:28", "article_content": "小程序生成海报保存分享图片完全指南（包括：头像，文字）作者：starkwang原文：https://segmentfault.com/a/1190000016039298业务在小程序中生成海报（包括用户头像和自定义文字）并且保存到本地实现思路利用canvas画布，把用户头像和自定义文字定位好，用户点击按钮保存到本地注意事项 难点小程序canvas不支持自定义宽高，反正我没找到，canvas画布大部分业务都需要全屏，响应式，至少宽100%解决方案：判断到屏幕尺寸，传到wxml 里面远程图片不能直接使用 getImageInfo 获取，需要保存到本地解决方案：canvas直接支持远程图片，不需要使用这个api先来个ui （嘿嘿！此图经过公司的设计授权过）技术栈canvaswx.createCanvasContextwx.canvasToTempFilePathPromise实战首先我们在wxml里面写一个canvas占位注意这里的宽度是100%，响应式，海报的高posterHeight 是从js里面动态计算的<canvas canvas-id=\"starkImg\" style=\"width:100%;height:{{posterHeight}}px;\"></canvas>根据屏幕动态计算海报的尺寸data: {\r\n  motto: 'Hello World',\r\n  hidden: true,\r\n  userInfo: {},\r\n  hasUserInfo: false,\r\n  windowWidth: '',\r\n  posterHeight: '',\r\n},\r\nonLoad: function () {\r\n  const poster = {\r\n    \"with\": 375,\r\n    \"height\": 587\r\n  }\r\n  const systemInfo = wx.getSystemInfoSync()\r\n  let windowWidth = systemInfo.windowWidth\r\n  let windowHeight = systemInfo.windowHeight\r\n  let posterHeight = parseInt((windowWidth / poster.with) * poster.height)\r\n  this.setData({\r\n    windowWidth: windowWidth,\r\n    posterHeight: posterHeight\r\n  })\r\n}背景图片生成  const that = this\r\n  // 图片路径\r\n  const imagePath = '../../static/image/common/'\r\n  let bgimgPromise = new Promise(function (resolve, reject) {\r\n    console.log('data', that.data)\r\n    wx.getImageInfo({\r\n      src: imagePath + \"base.png\",\r\n      success: function (res) {\r\n        resolve(res);\r\n      }\r\n    })\r\n  });头像直接使用远程头像初始化的时候，调取，一定在生成海报之前此处可以存储本地，或使用状态都可以wxml// 可以从后端接口获取 或 官方本身远程地址\r\n\r\n \r\n  <button class=\"share\" type=\"primary\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">开始答题（获取用户信息）</button>\r\njs  getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    let userInfo = e.detail.userInfo\r\n    console.log('userInfo', userInfo)\r\n    // 更新用户信息\r\n    // api.post('更新用户信息的url', userInfo)\r\n    this.setData({\r\n      userInfo: e.detail.userInfo,\r\n      hasUserInfo: true\r\n    })\r\n  },生成海报背景和图片wxmlbgimgPromise.then(res => {\r\n      console.log('Promise.all', res)\r\n      const ctx = wx.createCanvasContext('shareImg')\r\n      ctx.width = windowWidth\r\n      ctx.height = posterHeight\r\n      console.log(windowWidth, posterHeight)\r\n      // 背景图\r\n      ctx.drawImage('../../' + res[0].path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n      // 头像\r\n      ctx.drawImage(that.data.userInfo.avatarUrl, 48, 182, 58, 58, 0, 0)\r\n      ctx.setTextAlign('center')\r\n      ctx.setFillStyle('#000')\r\n      ctx.setFontSize(22)\r\n      // ctx.fillText('分享文字2：stark.wang出品', 88, 414)\r\n      ctx.fillText('分享文字1我的博客：https://shudong.wang', 55, 414)\r\n      ctx.stroke()\r\n      ctx.draw()\r\n    })保存到本地onLoad: function () {\r\n  share: function () {\r\n    var that = this\r\n    wx.showLoading({\r\n      title: '正在制作海报。。。'\r\n    })\r\n    new Promise(function (resolve, reject) {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: 444,\r\n        height: 500,\r\n        destWidth: 555,\r\n        destHeight: 666,\r\n        canvasId: 'starkImg',\r\n        success: function (res) {\r\n          console.log(res.tempFilePath);\r\n          that.setData({\r\n            prurl: res.tempFilePath,\r\n            hidden: false\r\n          })\r\n          wx.hideLoading()\r\n          resolve(res)\r\n        },\r\n        fail: function (res) {\r\n          console.log(res)\r\n        }\r\n      })\r\n    }).then(res => {\r\n      console.log(res)\r\n      this.save()\r\n    })\r\n  }\r\n}结果更新头像裁剪为圆形ctx.save() // 对当前区域保存\r\nctx.beginPath() // 开始新的区域\r\nctx.arc(73, 224, 38, 0, 2 * Math.PI);\r\nctx.clip();  // 从画布上裁剪出这个圆形\r\nctx.drawImage(res[1], 36, 186, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\nctx.restore() // 恢复上面是远程连接容易发生请求失败把头像提前存到本地存储中解决getImg: function () {\r\n  let avatarUrl = this.data.userInfo.avatarUrl\r\n  downLoadFile(avatarUrl).then((res) => {\r\n    console.log(res)\r\n    wx.saveFile({\r\n      tempFilePath: res.data.tempFilePath,\r\n      success: function (res) {\r\n        wx.setStorageSync('avatarUrl', res.savedFilePath)\r\n      }\r\n    })\r\n  })\r\n},获取头像// 头像\r\nlet promiseAvatarUrl = new Promise(function (resolve, reject) {\r\n  resolve(wx.getStorageSync('avatarUrl'))\r\n}).catch(res=>{\r\n  console.log('catch',res)\r\n});背景还是不变const that = this\r\nlet promiseBdImg = new Promise(function (resolve, reject) {\r\n  console.log('data', that.data)\r\n  wx.getImageInfo({\r\n    src: imagePath + \"base1.png\",\r\n    success: function (res) {\r\n      console.log('promiseBdImg', res)\r\n      resolve(res);\r\n    }\r\n  })此时生成canvas更新Promise.all([\r\n    promiseBdImg, promiseAvatarUrl\r\n  ]).then(res => {\r\n    console.log('Promise.all', res)\r\n    const ctx = wx.createCanvasContext('shareImg')\r\n    ctx.width = windowWidth\r\n    ctx.height = posterHeight\r\n    console.log(windowWidth, posterHeight)\r\n    //主要就是计算好各个图文的位置\r\n    ctx.drawImage('../../' + res[0].path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n    ctx.save() // 对当前区域保存\r\n    ctx.beginPath() // 开始新的区域\r\n    ctx.arc(73, 224, 38, 0, 2 * Math.PI);\r\n    ctx.clip();  // 从画布上裁剪出这个圆形\r\n    ctx.drawImage(res[1], 36, 186, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\n    ctx.restore() // 恢复\r\n    ctx.setTextAlign('center')\r\n    ctx.setFillStyle('#000')\r\n    ctx.setFontSize(22)\r\n    ctx.save()\r\n    ctx.beginPath();\r\n    ctx.fillText('作者：stark.wang', 545 / 2, 130)\r\n    ctx.fillText('我的博客：http://shudong.wang', 190, 414)\r\n    ctx.stroke()\r\n    ctx.draw()\r\n  })结果完美ok，如果能帮助你，请赞一个。感觉日后会需要，推荐收藏"}
{"title": "一个 JS 库就能解决小程序跨页传递事件消息和数据 ", "author": "Rolan", "pub_time": "2018-8-21 00:37", "article_content": "由于微信小程序 wx.navigateBack 方法并不支持返回传值，导致页面在返回后，不能方便地即时更新数据。一.需求分析此类需求大概意思是：A 页面进入 B 页面，B 页面返回并传值给 A或在B页面触发事件时，A页面也有事件触发改变。业务分析普遍方法为： 第一种：利用微信的 wx.setStorage，将数据缓存在小程序实例内。从 B 页面返回 A 页面时，B 页面先将数据缓存；然后在 A 页面的 onshow 方法里，调用 wx.getStorage 读取缓存来实现。但为日后维护带来大量隐患。（用全局变量方法类似）第二种：获取前一个 page 实例的方法，也可以实现此功能。部分代码如下：var pages = getCurrentPages();var currPage = pages[pages.length - 1];   //当前页面var prevPage = pages[pages.length - 2];  //上一个页面//直接调用上一个页面的 setData() 方法，把数据存到上一个页面中去prevPage.setData({  mdata:1 })这种方法的弊端：因为进入 B 页面的入口可能是很多个。这样做，可能会导致获取到的页面实例不正确。二.方法介绍（onfire.js的下载地址https://github.com/hustcc/onfire.js） 下面进入正题介绍onfire.js（） onfire.js 是一个很简单的事件分发 JavaScript 库（仅仅 0.9kb），简洁实用。它可以应用于: 1.简单的事件分发。 2.在 React、Vue.js、Angular 中用于跨组件的轻量级实现。 3.事件订阅和发布。使用思路：（做过移动端开发的都知道，类似于iOS的通知和安卓的广播） a.A 页面先订阅一个事件，并定义处理方法； b.从 B 页面返回时，发送消息； c.A 页面卸载时，解除订阅。我的使用方法为： A 页面代码：var onfire = require(\"../utils/onfire.js\");var that;var eventObj = onfire.on('key', function () {    // 当消息被传递时，做具体的事});Page({  data: {  },  onLoad: function(options) {    // Do some initialize when page load.  },  onReady: function() {    // Do something when page ready.  },  onUnload: function (e) {    onfire.un('key');    onfire.un(eventObj);//移除  }})我们可以在 A 页面直接调用 onfire.on 方法，订阅一个名字为 key 的消息。在上面的代码中，消息附带的参数无传参。 如果需要传参的话，直接在 function 里增加参数即可，例如：var eventObj = onfire.on('key', function (data){  // 执行操作})需要注意的是，一定要在 onUnload 里（在页面被关闭时）取消订阅消息，并取消绑定 eventObj。B 页面里代码在回调的地方加入以下代码：onfire.fire('key');//key 为上文中订阅的消息   // 有参数时   onfire.fire('key','test');三.分析库代码function _bind(eventName, callback, is_one, context) {    if (typeof eventName !== string_str || typeof callback !== function_str) {      throw new Error('args: '+string_str+', '+function_str+'');    }    if (! hasOwnKey(__onfireEvents, eventName)) {      __onfireEvents[eventName] = {};    }    __onfireEvents[eventName][++__cnt] = [callback, is_one, context];    return [eventName, __cnt];  }从代码中可以看出订阅 on 方法的时候，实际调用 _bind 方法。该方法利用一个二维数组，来存储订阅的对象。 function _fire_func(eventName, args) {    if (hasOwnKey(__onfireEvents, eventName)) {      _each(__onfireEvents[eventName], function(key, item) {        item[0].apply(item[2], args); //执行订阅时的方法        if (item[1]) delete __onfireEvents[eventName][key]; // 当类型为只订阅一次时，通知后即移除自己。      });    }  }而 fire 发送消息方法的实质，是调用 _fire_func 方法，通过名字（key）来遍历订阅者，然后通知订阅者。function un(event) {    var eventName, key, r = false, type = typeof event;    if (type === string_str) {      // 如果存在key值，则移除数组      if (hasOwnKey(__onfireEvents, event)) {        delete __onfireEvents[event];        return true;      }      return false;    }    else if (type === 'object') {      eventName = event[0];      key = event[1];      //如果找到这个对象则卸载      if (hasOwnKey(__onfireEvents, eventName) && hasOwnKey(__onfireEvents[eventName], key)) {        delete __onfireEvents[eventName][key];        return true;      }      //否则返回false      return false;    }    else if (type === function_str) {        //两层循环来判断方法名      _each(__onfireEvents, function(key_1, item_1) {        _each(item_1, function(key_2, item_2) {          if (item_2[0] === event) {            delete __onfireEvents[key_1][key_2];            r = true;          }        });      });      return r;    }    return true;  }调用un方法，通过名字（key）来遍历订阅者，找到后移除。注：因为卸载支持按 key、对象、方法卸载，所以需要先判断类型，然后按各自规则去解除绑定。作者：honey缘木鱼"}
{"title": "微信小程序有旋转动画效果的音乐组件 ", "author": "Rolan", "pub_time": "2018-8-22 00:12", "article_content": "在微信开发中，写过的一个简单的音乐播放组件，记录下。music 音乐播放组件。属性代码properties: {    // 音乐路径    music: {      type: String,      value: '',      observer: function (newVal) {        this._initMusic(newVal)      }    },    // 样式    musicStyle: {      type: String,      value: 'position: absolute; right: 20rpx; top: 20rpx; width: 100rpx; height: 100rpx;'    },    // 播放时是否有旋转效果    rotate: {      type: Boolean,      value: true    },    // 播放时的icon路径    iconOn: {      type: String,      value: '/resources/img/music-on.png' // 请填写默认的图片地址    },    // 暂停时的icon路径    iconOff: {      type: String,      value: '/resources/img/music-off.png' // 请填写默认的图片地址    }  }初始化音乐首先，在properties中接收页面传来的音乐文件地址，music: {  type: String,  value: '',  observer: function (newVal) {    this._initMusic(newVal)  }}这里的处理是，一旦接收到页面传来的 music 地址，就初始化音乐：_initMusic: function (newVal) {  // 当页面传来新的music时，先销毁之前的audioCtx，否则页面会很嗨  if (this.data.audioCtx) {    this.data.audioCtx.destroy()  }  if (newVal) {    var audioCtx = wx.createInnerAudioContext()    this.setData({        audioCtx: audioCtx    })    if (this.data.audioStatus == '1') {        audioCtx.autoplay = true    }    audioCtx.loop = true    audioCtx.src = newVal  }}audioStatus 用来记录音乐播放状态，在data中默认设置为1：data: {    icon: '',    audioStatus: 1,    audioCtx: '',    musicClass: 'music-on'}wxml文件里，只用一个 标签：<image class='music {{ rotate && musicClass }}'         style=\"{{ musicStyle }}\"         src=\"{{ icon }}\"         bindtap='_switch'         wx:if=\"{{ music }}\"></image>其中， icon 在组件ready()时赋值成播放状态的icon：ready() {    this.setData({      icon: this.data.iconOn    })}音乐旋转效果音乐播放时的旋转效果，是用css动画实现的，wxss文件如下：.music {  position: absolute;  z-index: 99;  -webkit-animation-iteration-count: infinite;}/* 旋转class */.music-on {  animation: music-rotate 4s linear infinite;}/* 旋转动画 */@keyframes music-rotate {  0% {    transform: rotateZ(0deg);  }  100% {    transform: rotateZ(360deg);  }}当 rotate 为true时，使 musicClass 的值为 music-on，就能实现旋转了。当然， musicClass 需要用 this.setData 的方式来切换值。爆丑照：音乐控制手动切换手动点击时，用取反的逻辑控制音乐的播放和暂停：_switch: function () {  // 如果是播放就停止    if (this.data.audioStatus) {    this.setData({      audioStatus: 0,      icon: this.data.iconOff,      musicClass: ''    })    this.data.audioCtx.pause()  // 如果是停止就播放  } else {    this.setData({      audioStatus: 1,      icon: this.data.iconOn,      musicClass: 'music-on'    })    this.data.audioCtx.play()  }}其它情况同时，还要对下列情况做处理：分享时，进入选好友界面、音乐停止，分享回来后，音乐没有继续播放 从此页面跳转到下一个页面时，音乐还在继续 从此页面撤回到上一个页面时，音乐还在继续 解决的方法，是在组件的methods中又写了两个方法：// 写在组件的methods中：// 在引用组件页面的onShow()中调用//  否则，如果当发生分享页面行为并返回时，音乐不会自动播放onShow: function () {  if (this.data.music && this.data.audioStatus) {    this.data.audioCtx.play()  }},// 在引用组件页面的onHide()中调用//  否则，在跳转到下一个页面后，音乐还在继续onHide: function () {  if (this.data.music && this.data.audioStatus) {    this.data.audioCtx.pause()  }  this.setData({    animationData: {}  })}这两个方法分别在页面中的 onShow 和 onHide 中调用，调用方式就是父组件获取到子组件实例对象：例如，给组件加id为\"music-componet\"，调用时就是：// 写在调用页面中onShow: function () {    this.selectComponent('#music-component').onShow()},onHide: function () {    this.selectComponent('#music-component').onHide()}最后，在组件的detached中也调用一下 onHide 方法：// 页面关闭时销毁音乐detached() {    this.onHide()}使用 你可以通过阅读本文，根据自身实际情况写一个 或者，直接凑合用"}
{"title": "关于mpvue的几个点 ", "author": "Rolan", "pub_time": "2018-8-22 00:14", "article_content": "微信小程序的框架众多，而现在我只想记录一下mpvue的几个点...祝你采坑成功。微信小程序在语法规范、API、组件外，因为多了个可组件化component，主要点始终落在app.json、app.wxss、app.js和每个页面和组件的配置上，都是相似雷同的事情，详情移步官方文档相对而已，mpvue是在vue基础上加入了微信小程序的支持，在loader和编译方面多做支持，编码规范以vue为标准。使用现在已vue-cli生成mpvue/mpvue-quickstart模板深入相对于原生小程序，mpvue在代码目录主要维护:App.vue: 作为小程序的创建点和挂载点main.jsapp.jsonvue模型的组件页配置每页导航栏信息找到每页的的main.js,添加export default对应内容import Vue from 'vue'\r\nimport App from './index'\r\nconst app = new Vue(App)\r\napp.$mount()\r\nexport default {\r\n  config: {\r\n    \"navigationBarBackgroundColor\": \"#ffffff\",\r\n    \"navigationBarTextStyle\": \"black\",\r\n    \"navigationBarTitleText\": \"微信接口功能演示\",\r\n    \"backgroundColor\": \"#eeeeee\",\r\n    \"backgroundTextStyle\": \"light\"\r\n  }\r\n}\r\n网上说这是设置每页navigation内容和状态的方法，亲试不行暂时可以替代的方法：wx.setNavigationBarTitle({\r\n  title: '关卡'\r\n})\r\nFAQS报错mpvue 未找到入口 app.json 文件正常情况：npm run dev执行一下mpvue的编译在dist目录下会自动产生一个app.json题外话：安装依赖包的时候或者npm run dev的时候提示缺少依赖的话，直接把node_modules 下面的文件全部删掉，然后重新npm intall 简单粗暴解决问题分析： 因为缺乏依赖而没自动生成app.json解决之道： 只需要把packpage.json里的mpvue-loade后面的‘^’去掉，重新安装依赖即可。npm install\r\nnpm run dev\r\nnpm run dev 无法编译成功情况如下：$ npm run dev\r\n> color-life@1.0.0 dev /home/happy/Dev/coding/color-life\r\n> node build/dev-server.js\r\n尝试如下也无法解决：1.npm run dev不行\r\n2.删除module重装也不行\r\n3.重新初始化项目也不行\r\n这主要是编译时遇到代码缺失解决：如果有组件只有纯template，加上即可：<script>\r\n  export default {}\r\n</script>\r\nv-show使用失效分析v-show的特点：v-show只能简单的切换元素的css属性 display不支持 <template> 元素不支持 v-else使用v-show时，很容易将v-show直接下载创建的组件上，如<template>\r\n    <components v-show=\"isShow\"></components>\r\n</template>\r\n因此组件的显隐状态无法根据isShow响应状态解决：只需要在组件外包括一层元素进行控制<template>\r\n    <div v-show=\"isShow\"> \r\n        <components></components>\r\n    </div>\r\n</template>    \r\n科普：v-if直接是创建-销毁组件"}
{"title": "如何在小程序wxml文件中编写js代码 ", "author": "Rolan", "pub_time": "2018-8-22 00:28", "article_content": "当我们创建页面时发现有个.wxs文件发现有个.wxs文件，关于wxs文件如何使用呢？ WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 wxs可以说就是为了满足能在页面中使用js存在的，在wxml页面中，只能在插值{{ }}中写简单的js表达式，而不能调用方法，例如直接在wxml页面中直接保留数据的小数点的后两位。 通常的解决办法是在page的data对象中先把这个数据截赋给某个变量，然后在页面中使用这个变量，但是问题又来了，如果变量多了呢，是不是要定义很多次。 相对来说wxml中使用js语法就比较薄弱了，wxs就是弥补了这样的短处。 关于wxs文件的使用方法如下： .wxs的实例代码为：<!-- page/tools.wxs -->var bar = function (a,b) {var total = a * b;total = total.toFixed(2);//保留两位小数return total;}module.exports = { bar: bar};在wxml中引用代码：<!-- page/index/index.wxml --><wxs src=\"./../tools.wxs\" module=\"tools\" /><view> {{tools.bar(2,3)}} </view>最后输出结果如图：结果注意：wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。 wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。 wxs 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。"}
{"title": "使用mpvue开发github小程序总结 ", "author": "Rolan", "pub_time": "2018-8-22 00:37", "article_content": "最近有点闲，想起关注已久的 mpvue 写小程序，所以稍微肝了半个多月写了个 github 版的微信小程序，已上线。现在总结一下遇到的坑。项目地址、 github.com/cheesekun/w…mina坑scroll-view 高度可滚动视图区域。使用竖向滚动时，需要给 <scroll-view/> 一个固定高度，通过 WXSS 设置 height。小程序提供的 scroll-view 组件，想让他能滚动，就要给他提供一个固定的高度。我们一般需求是，上一块区域固定，下一块区域可滚动，我的处理方法是，拿到机型的可视高度，减去上一块固定区域的高度，动态赋值 scroll-view 最终高度。// 以 search 页为例\r\n// 滚动区域高度 = 总高度 - 搜索框高度 - tabs 高度\r\nonLoad () {\r\n  wx.getSystemInfo({\r\n    success: (res) => {\r\n      this.height = res.windowHeight // 获取机型可视高度\r\n    }\r\n  })\r\n\r\n  let query = wx.createSelectorQuery()\r\n  // 选择id\r\n  query.select('#search').boundingClientRect()\r\n\r\n  query.exec(res => {\r\n    let searchH = res[0].height // 获取search框高度\r\n    this.height = this.height - searchH - this.tabsH\r\n  })\r\n}\r\n复制代码坑点： wx.createSelectorQuery() 获取不了 display: none 的元素高度。我的解决方法是：在 trending 页获取到 tabs 组件的高度，再存放到 vuex 中，给 search页使用生命周期（同一page携带不同参数）小程序生命周期当我们从一个页面①进入页面②时，我们一般在 onLoad 进行初始数据的获取，从页面②返回到页面①时，若两个页面是不同的page，如 ①为page/info ，②为page/repo，那没问题，①页面 unOnLoad ，②页面 onShow 。但是若 ①为page/info?user=a ， ②为page/info?user=b ，那gg了，从页面②返回到页面①，页面①的数据会变成页面②的数据为了避免这种情况，我一开始使用 onShow 代替 onLoad ，也就是在 onShow 的时候获取页面的初始数据。但是这个情况就有点可怕了，我们知道 onShow 很多情况都会触发到，切换前后台，从一个页面返回到另一个，都会触发 onShow ，这就导致会触发很多不必要的请求，而且用户体验极差。可我很多需求就是类似从 ①为page/info?user=a 到 ②为page/info?user=b ，因此曲线救国想出用 vuex 维护有相关需求页面的路由栈。页面 onLoad 的时候，推入query参数到栈中， onShow 时，若当前页面的参数和栈中最后一个元素相同，则不重新加载数据。当页面被销毁，则在 onUnload 中把相应的页面栈推出。这样就可以避免很多无谓的 onShow 请求。onLoad () {\r\n    this.reset()\r\n    const options = getQuery()\r\n    user = options.login\r\n    // vuex\r\n    this.reposStack.push(options)\r\n\r\n    this.getRepos()\r\n  },\r\n  onShow () {\r\n    const options = getQuery()\r\n    // vuex\r\n    let reposStack = JSON.parse(JSON.stringify(this.reposStack))\r\n    let len = reposStack.length\r\n    let endStack = reposStack[len - 1]\r\n    if (JSON.stringify(endStack) === JSON.stringify(options)) {\r\n      return\r\n    }\r\n    this.reset()\r\n    user = options.login\r\n    this.getRepos()\r\n  },\r\n  onUnload () {\r\n    // vuex\r\n    this.reposStack.slice(0, -1)\r\n  }\r\n复制代码mpvue坑query参数mpvue 可以通过  this.$root.$mp.query 在所有页面的组件内获取路径参数。如果以 mina 来说的话，我们是通过在生命周期 onLoad(options) ，拿到 options 上携带的路径参数， mpvue 提供了 this.$root.$mp.query ,我们可以所有生命周期上使用。但是我们知道，当我们从当前页返回到上一页时，上一页并不会执行 onLoad() ,假设当前页和上一页是同个 page ，只是携带参数不同的话，此时回退到上一页，上一页的 this.$root.$mp.query 不会变成自己的 query ，还是会变成当前页的 query举例：①page/info?a=1 => ②page/info?b=2当我从②返回到①时，①的 this.$root.$mp.query 会变成 {b:2}我猜 mpvue 的 this.$root.$mp.query 是通过 onLoad(options) 获取到 options ，再赋值。但是遇到小程序页面返回不会执行 onLoad为了避免麻烦，我直接使用了小程序的api getCurrentPages() ，获取路由栈中最后一个路由的参数getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。/**\r\n * 获取当前路径参数\r\n * 不用mpvue提供的this.$root.$mp.query\r\n * 因为其进入同一页面，参数不会变化\r\n*/\r\nexport function getQuery () {\r\n  /* 获取当前路由栈数组 */\r\n  const pages = getCurrentPages()\r\n  const currentPage = pages[pages.length - 1]\r\n  const options = currentPage.options\r\n\r\n  return options\r\n} \r\n复制代码后记前面几个问题是我初次使用 mpvue 开发小程序遇到的最大的坑了吧。（好久没有写东西了，写得好烂。）不过确实使用 mpvue 开发小程序，能组件化，支持 npm ，比原生开发舒服很多。体验还是很好的。 小程序现在是真的太火了。感觉是个前端都要去玩一下。 再次推一下项目地址，有兴趣的朋友可以参考一下。 github.com/cheesekun/w…作者：芝士君原文：https://juejin.im/post/5b7bd9ea51882542d23a0e3d"}
{"title": "微信小程序 canvas圆角矩形的绘制 ", "author": "Rolan", "pub_time": "2018-8-23 00:02", "article_content": "作者： 清夜原文：https://juejin.im/post/5b7cecd7e51d4538e3318f27微信小程序允许对普通元素通过 border-radius 的设置来进行圆角的绘制，但有时候在使用 canvas 绘图的时候，也需要圆角，例如需要将页面上某块区域导出为图片下载到本地的时候，常用的解决方法就是使用 canvas 将这块区域绘制出来，最后导出 canvas 即可，但是 canvas 没有直接提供圆角的绘制 api ，所以需要 曲线救国圆角矩形与一般矩形的区别在于，前者的四个角都是圆弧，所以只需要将一般矩形的四个角切掉，换成圆弧即可，如下图就是一个一般矩形被切掉了四个角的样子：很明显，切掉了四个角的矩形，剩下其实就是四条 line ，既然如此，完全可以跳过绘制矩形然后切角这一步，因为切角的结果就是四条边( line )，直接绘制四条边即可。 然后在每两条边的缺角处绘制弧度为 0.5 * Math.PI 的圆弧，最后这四条边与四个圆弧所封闭的图形就是圆角矩形：原理知道了，代码就很好写了，这里只说几个注意点：封闭图形的 fillStyle 颜色设置为 transparent想将封闭路径的图形绘制下来，需要调用 stroke 或 fill 方法，默认 stroke 或 fill 的颜色是 black ，但是这里有个问题， 圆弧的绘制可能会出现锯齿或者糊边，如果 stroke 或 fill的颜色，与你所需要绘制的圆角矩形的边缘色调不一致，这种糊边的感觉会比二者色调一致的更明显， 下图第一个为色调一致，第二个为色调不一致的情况：不过据我观测，只要不是特意放大仔细看，无论是色调是否一致，其实一般人很难注意到糊边的事情clip绘制好了圆角选区之后，还需要调用 ctx.clip 方法来裁剪选区save 与 restore如果这个矩形选区只是 canvas 画布的一部分，为了避免对后续的影响，最好在 beginPath 之前，将之前的动作 save ，然后画完后再 restore一个关于 在 canvas 上绘制圆角图片，并下载到本地 的可运行示例代码已经放到 github 上了，注释也比较详细，需要的可自取其中关键代码如下：/**\r\n  * \r\n  * @param {CanvasContext} ctx canvas上下文\r\n  * @param {number} x 圆角矩形选区的左上角 x坐标\r\n  * @param {number} y 圆角矩形选区的左上角 y坐标\r\n  * @param {number} w 圆角矩形选区的宽度\r\n  * @param {number} h 圆角矩形选区的高度\r\n  * @param {number} r 圆角的半径\r\n  */\r\nfunction roundRect(ctx, x, y, w, h, r) {\r\n  // 开始绘制\r\n  ctx.beginPath()\r\n  // 因为边缘描边存在锯齿，最好指定使用 transparent 填充\r\n  // 这里是使用 fill 还是 stroke都可以，二选一即可\r\n  ctx.setFillStyle('transparent')\r\n  // ctx.setStrokeStyle('transparent')\r\n  // 左上角\r\n  ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5)\r\n\r\n  // border-top\r\n  ctx.moveTo(x + r, y)\r\n  ctx.lineTo(x + w - r, y)\r\n  ctx.lineTo(x + w, y + r)\r\n  // 右上角\r\n  ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2)\r\n\r\n  // border-right\r\n  ctx.lineTo(x + w, y + h - r)\r\n  ctx.lineTo(x + w - r, y + h)\r\n  // 右下角\r\n  ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5)\r\n\r\n  // border-bottom\r\n  ctx.lineTo(x + r, y + h)\r\n  ctx.lineTo(x, y + h - r)\r\n  // 左下角\r\n  ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI)\r\n\r\n  // border-left\r\n  ctx.lineTo(x, y + r)\r\n  ctx.lineTo(x + r, y)\r\n\r\n  // 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应\r\n  ctx.fill()\r\n  // ctx.stroke()\r\n  ctx.closePath()\r\n  // 剪切\r\n  ctx.clip()\r\n}\r\n复制代码"}
{"title": "微信小程序 手势解锁组件（无卡顿） ", "author": "Rolan", "pub_time": "2018-8-23 00:06", "article_content": "本人博客文章地址：http://liuhuihao.com/fontend/js/mini-gestrue-lock/代码地址： Mpvue版本： https://github.com/geminate/mpvue-gesture-lock 原生小程序版本：https://github.com/geminate/mini-gesture-lock一. 简介最近在 开发小程序的时候 遇到了这种手势解锁的需求，网上逛了一圈基本都是使用Canvas实现的，经过本人测试，所有使用Canvas实现的解锁组件，在Android实机测试时均存在严重卡顿问题。原因是 小程序的 canvas onTouchMove事件效率很低（2018/08/17 测试），吐槽一句，小程序现在有很多的坑官方都不去处理，论坛里一大堆问题也没人解决。。。。既然微信官方暂时没有要解决这个问题的意思，那咱们开发者就只能自己想办法了，于是本人**使用 dom 实现 **了一个基础版本的 手势解锁组件，有两个版本，分别使用mpvue 和 小程序原生写法。效果图：gesture.gif二. 核心实现由于 mpvue 版本 和 小程序原生版本思路基本一致，仅代码写法略有不同，因此一下均以 mpvue 代码做说明。布局代码<div class=\"gesture-lock\"       :class=\"{error:error}\"       :style=\"{width: containerWidth +'rpx', height:containerWidth +'rpx'}\"       @touchstart=\"onTouchStart\"       @touchmove=\"onTouchMove\"       @touchend=\"onTouchEnd\"  >    <!-- 9 个圆 -->    <div v-for=\"(item,i) in circleArray\" :key=\"i\" class=\"cycle\" :class=\"{check:item.check}\"         :style=\"{left:item.style.left,top:item.style.top,width:item.style.width,height:item.style.width}\">    </div>    <!-- 已激活锁之间的线段 -->    <div v-for=\"(item,i) in lineArray\" :key=\"i\" class=\"line\"         :style=\"{left:item.activeLeft,top:item.activeTop,width:item.activeWidth,transform:'rotate('+item.activeRotate+')'}\">    </div>    <!-- 最后一个激活的锁与当前位置之间的线段 -->    <div class=\"line\"         :style=\"{left:activeLine.activeLeft,top:activeLine.activeTop,width:activeLine.activeWidth,transform:'rotate('+activeLine.activeRotate+')'}\">    </div>  </div>布局代码主要分为 3 部分：9个圆形锁、已激活的锁之间的线段 和 最后一个激活的锁与当前手指位置之间的线段。全部 线段 与 圆 均通过 dom和样式实现。避免canvas卡顿。2. JS逻辑(1). 初始化constructor(containerWidth, cycleRadius) {    // ....    this.windowWidth = wx.getSystemInfoSync().windowWidth;// 窗口大小(用于rpx 和 px 转换)    this.initCircleArray();  }  // 初始化 画布上的 9个圆  initCircleArray() {    const cycleMargin = (this.containerWidth - 6 * this.cycleRadius) / 6;    let count = 0;    for (let i = 0; i < 3; i++) {      for (let j = 0; j < 3; j++) {        count++;        this.circleArray.push({          count: count,          x: this.rpxTopx((cycleMargin + this.cycleRadius) * (j * 2 + 1)),          y: this.rpxTopx((cycleMargin + this.cycleRadius) * (i * 2 + 1)),          radius: this.rpxTopx(this.cycleRadius),          check: false,          style: {            left: (cycleMargin + this.cycleRadius) * (j * 2 + 1) - this.cycleRadius + 'rpx',            top: (cycleMargin + this.cycleRadius) * (i * 2 + 1) - this.cycleRadius + 'rpx',            width: this.cycleRadius * 2 + 'rpx',          }        });      }    }  }初始化的时候，需要将9个圆的对象数组初始化，根据输入的容器宽度 和 锁半径计算出9个锁的位置及对应的css样式。这里需要注意rpx与px之前的转换。(2). onTouchStartonTouchStart(e) {    this.setOffset(e);    this.checkTouch({x: e.pageX - this.offsetX, y: e.pageY - this.offsetY}); }// 检测当时 触摸位置是否位于 锁上  checkTouch({x, y}) {    for (let i = 0; i < this.circleArray.length; i++) {      let point = this.circleArray[i];      if (this.isPointInCycle(x, y, point.x, point.y, point.radius)) {        if (!point.check) {          this.checkPoints.push(point.count);          if (this.lastCheckPoint != 0) {            // 已激活锁之间的线段            const line = this.drawLine(this.lastCheckPoint, point);            this.lineArray.push(line);          }          this.lastCheckPoint = point;        }        point.check = true;        return;      }    }  }当手指按下的时候，首先需要获取到 容器的 offset，然后检查当前手指的位置是否位于 锁圆 内部，如果位于内部的化将这个锁变为已激活状态，并压入激活锁数组。(3). onTouchMoveonTouchMove(e) {    this.moveDraw(e)  }// 移动 绘制  moveDraw(e) {    // 画经过的圆    const x = e.pageX - this.offsetX;    const y = e.pageY - this.offsetY;    this.checkTouch({x, y});    // 画 最后一个激活的锁与当前位置之间的线段    this.activeLine = this.drawLine(this.lastCheckPoint, {x, y});  }当手指在按下并移动的时候，实时检查当前手指的位置是否在未激活的锁上，如果位于未激活的锁上，则将其激活并压入激活锁数组，并按顺序绘制激活锁之间的连线。除此之外还需要绘制上一个激活锁到当前手指位置的连线。(4).onTouchEndonTouchEnd(e) {    const checkPoints = this.checkPoints;    this.reset();    return checkPoints;  }手指放开的时候 清空全部状态作者：Madokami 链接：https://www.jianshu.com/p/c7bd3a9486c5"}
{"title": "小程序中打开网页和pdf ", "author": "Rolan", "pub_time": "2018-8-23 00:12", "article_content": "打开网页的方法有两种第一种是最简单的微信官方提供的方法，直接把要打开的网页地址赋给web-view标签的src属性     <web-view src=\"{{article}}\"> </web-view>第二种需要引入一个第三方插件，下面的写法只适用于wepy框架中，其他框架中写法略有不同。<template><view>    //插件中的固定写法    <import src=\"../../wxParse/wxParse.wxml\" />    <template is=\"wxParse\" data=\"{{wxParseData:article.nodes}}\" />    <view wx:if='article' class='addclass'></view></view></template><script>//引入插件import WxParse from \"../../wxParse/wxParse\";export default class webview extends wepy.page {    data = {        //网页地址路径        article: '',    }    methods = {    }    async onLoad(options) {        let ret = await api.rentalContracts({            id: this.id,            method: 'GET'        });        this.article = ret.data        //调用插件中的方法设置article中的网页路径        WxParse.wxParse('article', 'html', this.article, this, 1);    }}打开phf文件给按钮定义一个preview方法，在downloadFile方法中调用wx.openDocument方法就可以实现。       preview() {            let that=this.            wx.downloadFile({                url: 'https://www.*******.com/contract/default/pdf',                success: function(res) {                    console.log(res)                    var Path = res.tempFilePath //返回的文件临时地址，用于后面打开本地预览所用                    that.webview=Path                    wx.openDocument({                        filePath: Path,                        success: function(res) {                            console.log('打开文档成功')                        }                    })                },                fail: function(res) {                    console.log(res)                }            })        },作者：王炳祺 链接：https://www.jianshu.com/p/098fd010d88b"}
{"title": "微信小程序云端解决方案教程一：文件上传下载应用场景 ", "author": "天下雪", "pub_time": "2016-10-15 16:55", "article_content": "内容架构：部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 开通和配置 COS6. 启动小相册示例 Node 服务7. 微信小程序服务器配置8. 启动小相册 Demo主要功能实现上传图片获取图片列表下载和保存图片删除图片微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。小相册是结合腾讯云对象存储服务（Cloud Object Service，简称COS）制作的一个微信小程序示例。在代码结构上包含如下两部分：applet: 小相册应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的 Node 服务端代码，作为服务器和applet通信，提供 CGI 接口示例用于拉取 COS 图片资源、上传图片到 COS、删除 COS 图片等。小相册主要功能如下：列出 COS 服务器中的图片列表点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 COS 服务器中轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片长按任意图片，可将其保存到本地，或从 COS 中删除部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署小相册的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通和配置 COS小相册示例的图片资源是存储在 COS 上的，要使用 COS 服务，需要登录 COS 管理控制台，然后在其中完成以下操作：开通 COS 服务分配得到唯一的APP ID使用密钥管理生成一对SecretID和SecretKey（用于调用 COS API）在 Bucket 列表中创建公有读私有写访问权限、CDN加速的 bucket（存储图片的目标容器）6. 启动小相册示例 Node 服务在镜像中，小相册示例的 Node 服务代码已部署在目录/data/release/qcloud-applet-album下：进入该目录：cd /data/release/qcloud-applet-album在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 COS 配置：module.exports = {    // Node 监听的端口号    port: '9993',    ROUTE_BASE_PATH: '/applet',    cosAppId: '填写开通 COS 时分配的 APP ID',    cosSecretId: '填写密钥 SecretID',    cosSecretKey: '填写密钥 SecretKey',    cosFileBucket: '填写创建的公有读私有写的bucket名称',};小相册示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json7. 微信小程序服务器配置进入微信公众平台管理后台设置服务器配置，配置类似如下设置：注意：需要将 www.qcloud.la 设置为上面申请的域名，将 downloadFile 合法域名设置为在 COS 管理控制台中自己创建的 bucket 的相应 CDN 加速访问地址，如下图所示：8. 启动小相册 Demo在微信开发者工具将小相册应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开小相册Demo开始体验。这里有个问题。截止目前为止，微信小程序提供的上传和下载 API 无法在调试工具中正常工作，需要用手机微信扫码预览体验。主要功能实现上传图片上传图片使用了微信小程序提供的wx.chooseImage(OBJECT)获取需要上传的文件路径，然后调用上传文件接口wx.request(OBJECT)发送 HTTPS POST 请求到自己指定的后台服务器。和传统表单文件上传一样，请求头Content-Type也是multipart/form-data。后台服务器收到请求后，使用 npm 模块 multiparty 解析 multipart/form-data 请求，将解析后的数据保存为指定目录下的临时文件。拿到临时文件的路径后，就可直接调用 COS SDK 提供的文件上传 API 进行图片存储，最后得到图片的存储路径及访问地址（存储的图片路径也可以直接在 COS 管理控制台看到）。获取图片列表调用列举目录下文件&目录 API可以获取到在 COS 服务端指定 bucket 和该 bucket 指定路径下存储的图片。下载和保存图片指定图片的访问地址，然后调用微信小程序提供的wx.downloadFile(OBJECT)和wx.saveFile(OBJECT)接口可以直接将图片下载和保存本地。这里要注意图片访问地址的域名需要和服务器配置的 dowmloadFile 合法域名一致，否则无法下载。删除图片删除图片也十分简单，直接调用文件删除 API 就可以将存储在 COS 服务端的图片删除。"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《上》 ", "author": "天下雪", "pub_time": "2016-10-16 18:55", "article_content": "本文已获得原作者授权微信小程序内测至今也有20天左右，也有很多人作出了很多不错的DEMO并发布到github了。前几日看见了豆瓣电影这个demo，感觉很不错，也跟着做了一个，作为复习巩固文档API用。废话不多说，直接进入正题：第一节只写一个首页的展示，数据用的是自己写的虚拟的数据 新建一个demo，不要使用微信自带的DEMO，直接从零开始写起：首先创建3个文件：app.jsonapp.jsapps.wxss app.json  : 主要写配置项：内容如下，具体的每个key值对应的意思，这里就不再细说了，可以看我之前的配置指南，{\"pages\":[\"pages/index/index\",\"pages/rank/rank\",],\"window\":{\"enablePullDownRefresh\":true,\"backgroundColor\":\"#eee\",\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" },\"tabBar\": {\"color\": \"#d7ced5\",\"selectedColor\": \"#535f71\",\"borderStyle\": \"white\", \"backgroundColor\": \"#f9f9f9\",\"list\": [ {\"pagePath\": \"pages/index/index\", \"text\": \"推荐电影\", \"iconPath\": \"images/board.png\", \"selectedIconPath\": \"images/board-actived.png\" },{\"pagePath\": \"pages/rank/rank\",\"text\": \"北美票房\",\"iconPath\": \"images/note.png\",\"selectedIconPath\": \"images/note-actived.png\"}]},\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},\"debug\": true} app.js  :  主要用来注册一个小程序的实例 App({onLaunch: function () {},onShow: function () {},onHide: function () {},globalData: 'I am global data'});  app.wxss : 公用样式，基本等同于CSS，暂时不需要写内容。 创建好3个文件后，就可以开始写页面的内容了：新创建2个文件夹images和pages，一个放图片一，个放页面。目前只pages下面再创建2个文件夹index和rank，每个文件下分别创建json,js,wxml,wxss文件，此时目录如下：虽然不一定4个文件类型都需要用到，但为了之后方便，建议还是先创建好，需要用到的时候就比较方便了，不用再去创建。首先写index.js:   (为了模拟循环数组，data下面的moivelist还需要多复制几份，这里只写了一份出来，imgsrc路径要写好) Page({    data:{    moivelist:[{    imgsrc: \"../../images/AN2.jpg\",    title: \"肖申克的救赎\",    introduce: \"The shrakwos RedenpeTion(1994)\",    author: \"弗兰克*德拉立邦\",    rank: \"9.6\"}]},onLoad: function(options) {console.log(1);},onReady: function() {// Do something when page ready.},onShow: function() {// Do something when page show.},onHide: function() {// Do something when page hide.},onUnload: function() {// Do something when page close.},onPullDownRefresh: function() {// Do something when pull down},// Event handler.viewTap: function() {this.setData({text: 'Set some data for updating view.'})}})这里出现了很多on函数事件，对应页面的生命周期每个过程对应的事件，这里暂时先关注data对象小程序是以数据驱动的，页面进来的时候通过动态获取数据，通过{{xxx}}将数据绑定，并将数据渲染到视图层，这里先以一个虚拟的data数据模拟 然后写index.wxml文件：从上面显示的首页的图片来看，主要是1个标题，以及下面一个列表，列表用过循环来渲染出所有的数据标题:  标题比较简单，主要是写css<view class=\"head-title\"><text>豆瓣电影top250</text></view>这里主要讲下面的列表循环，可以发现我们只要写好列表中的第一个就可以了，其他的通过循环来展示列表主要分为左中右三块，分别为图片，内容，以及评分3块<block wx:for=\"{{moivelist}}\">  //循环渲染，wx:for=\"{{ xxx }}\" 代表循环js文件里面的data数据中的xxx<view>//微信循环时会给出每个项目的内容以及每个项目的下标，默认为item和index，item.imgsrc意为对象的（imgsrc）  key值图片：<image class=\"moive-img\" style=\"\" mode=\"\" src=\"{{item.imgsrc}}\" binderror=\"\" bindload=\"\"></image>内容：<view class=\"moive-content\">     <view class=\"content-titile\">        <text >{{item.title}}</text>    </view>    <view class=\"content-introduce\">         <text >{{item.introduce}}</text>    </view>    <view class=\"content-author\">        < text >{{item.author}}</text>\t    </view>\t</view>评分：<text class=\"content-rank\">{{item.rank}}</text></view></block>   基本都这里wxml就结束了，样式主要通过wxss来操作，样式比较简单，就不写了，主要讲一下左中右这三块通过将左中右这三块的父级设置为display:flex;左边和右边都设置为固定rpx，中间设置为flex:1。这样写代表中间这一块的内容占满：左边和右边布局后生下来的空间 ，即左右布局好后，剩多少，flex：1就等于多少。 第一节项目代码见：demo1https://github.com/linrunzheng/wx-samll-demo"}
{"title": "微信小程序实战教程：火车票查询（含demo） ", "author": "天下雪", "pub_time": "2016-10-17 22:25", "article_content": "界面展示  结合动态图描述一下目前实现的功能：2.1 主页上半部分显示用户头像与用户名（和微信中的信息一致，这部分组件是工具自带的，我们可以修改这部分组件和内容，稍候会提到）；下半部分显示一个经典的问候语“Hello World”，提供一个可点击的按钮“点击获取火车票”；2.2 点击按钮后，通过事先指定的参数（调用了百度APIStore中去哪网火车票查询接口，站-站查询所需参数为始发地、目的地及时间）发送网络请求，将获取到的JSON数据按火车车次为节点进行解析并在新页面显示基本信息（除了详细座位信息），为每个车次提供一个可点击的按钮“点击查看座位信息”；2.3 点击某车次中的座位查询按钮后，会将该车次对应的所有座位信息显示在新页面中；2.4 点击后两个页面左上角的“返回”按钮可回到上一页，这个功能也是工具自带的； 顺便提一下在博客园中插入动画，上面的演示过程是一张格式为gif的图片，像添加普通图片一样操作即可。录制工具使用的是灵者Gif录制，可以指定开始、停止时所需操作与区域等录制信息。  3. 要点分析关于微信小程序工具的使用及初始项目的结构说明，网上资源已经很丰富，这里不打算再啰嗦 下面开始讲讲我个人在学习与开发过程中认为值得分享与记录的点，欢迎大小神们一起讨论与指正，特别是讲得不对或有待改善的地方。下面只给出和讲的点直接相关的代码，整体代码可以到项目工程中去查看，建议大家自己调试一遍。 3.1 indexindex是项目新建时自动生成的，作为小程序的启动页面。3.1.1 index.wxml首页的头像与用户名，从上图的演示过程可以看出我将微信的名字“***”改成了“用户名”：<view  bindtap=\"bindViewTap\" class=\"userinfo\"> 　　<image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image> 　　<text class=\"userinfo-nickname\">用户名</text>  <!-- {{userInfo.nickName}}直接写成“用户名” --></view>用户名部分原本的内容为{{userInfo.nickName}}，{{key_name}}的作用是获取关键字名为key_name对应的值（数据一般以key_name:value的形式定义在wxml文件同目录下js文件的data成员中，后面会讲解），image显示的头像资源也是通过这种方式指定为src=\"{{userInfo.avatarUrl}}\"，程序中产生的数据可以在开发者工具顶部偏右的AppData栏中查看。如果不需要从js文件中获取数据，那么可以像代码中“用户名”那样直接写入数据值，不过一般不推荐这样做，因为像Android等平台App在开发时会将数据值放入strings.xml等文件，目的是为了将数据与布局分离，布局和功能实现代码分离，方便开发与维护。组件中的class项用来设置其样式，属性名对应的样式信息定义在wxss文件中，除了可以使用定义在本目录wxss文件中的样式，还可以使用app.wxss文件中定义的。如果样式只是在某页面中使用，那么建议定义在其目录下的wxss文件中，即局部作用域内；如果是多个页面共同使用，即全局样式，那么一般定义在主程序app.wxss文件中。class样式可以指定组件的宽高、背景颜色等属性，本文不再进行详述。在界面下方添加按钮“点击获取火车票”组件：<view class=\"gettrain-button\" bindtap=\"getTrainInfo\"> 　　<text>点击获取火车票</text> </view>按钮的目标是为了让用户可以点击进行交互，至于使用button、text或其他组件，视具体需求而定。这里是利用text组件，文本内容直接写入了字串“点击获取火车票”，对于只有一个子组件的布局其实可以如下面代码不用嵌套，一层布局搞定。一般来说嵌套层数越少，加载速度越快，这对移动程序的体验是至关重要的。<view class=\"gettrain-button\" bindtap=\"getTrainInfo\"> 　　点击获取火车票 </view>但如果在父容器下有多个子组件共享其定义的样式，那么嵌套可以另代码简洁很多：<view class=\"gettrain-button\"> 　　<text bindtap=\"getTrainInfo\">点击获取火车票</text> 　　<text bindtap=\"getCarInfo\">点击获取汽车票</text> 　　<text bindtap=\"getPlaneInfo\">点击获取飞机票</text> </view>组件若要有点击交互功能，须为其绑定事件响应方法，常用的有单点--bindtap，长按--binglongtap。bindtap=\"getTrainInfo\"，双引号中的文本是方法名称，在js文件中以该名定义方法，做需要的处理即可。3.1.2 index.js 实现wxml布局中按钮“点击获取火车票”绑定的函数功能：//获取火车票函数getTrainInfo: function() {    wx.request({        url: 'http://apis.baidu.com/qunar/qunar_train_service/s2ssearch',        header: {            apikey: '361cf2a2459552575b0e86e0f62302bc',        },        data: {            version: '1.0',            from: '北京',            to: '杭州',            date: '2016-11-15',        },        success: function(res) {            var json = res.data;            //将JSON类型转为String类型用以url参数传递，否则传递后会变成[object Object]            var jsonString = JSON.stringify(json);            wx.navigateTo({                url: '../train/train?trainInfos='+jsonString,            });        },    });},我们先来看看微信小程序官网对于网络请求方法--wx.request(OBJECT)的说明： 一般来说，wx api提供的方法默认会有一个Object参数，需要时传入，不需要时不传便是。不过这对于像我这种Android开发者来说一开始有点不适应，怎么函数调用时都传入一个{...}参数，内部各个项之间用逗号“,”分隔，代码中的url、data等。从代码中看，发起网络请求时传入了图中列出的四项参数：url、header、data及success，不同需求传入的参数也会不同。对于wx.request方法而言，需根据网络请求目标来传参数的是前四项：url、header、data及method。以本案例利用百度APIStore去哪网火车票获取站--站火车票信息来说（http://apistore.baidu.com/apiworks/servicedetail/697.html），其官网给出的接口调用的参数信息与格式如下：将上面两张图中的信息结合起来看，参数是一一对应的：wx url——火车票查询 接口地址；header——请求参数header；data——请求参数urlParam；method——请求方法；因为wx中的method参数默认是GET，和火车票查询接口指定的一致，所以调用时可以省略。而对于最后三个回调函数：success、fail及comlete，代码中添加了success，在请求成功时对数据进行处理。当然，一般的程序还得对请求失败的情况做处理。下面就来分析success方法中的代码，包括JSON数据的转换与新页面的跳转，请求返回的数据以参数res的形式传入到function中。先来看看res中包含了哪些信息，通过代码console.log(res)可以将其打印在工具调试页面的Console项中。request--ok和statusCode--200表示请求成功，所以才会回调success方法。而data对象才是我们需要的数据，更精确地说，data.data.trainList对象才是真正的火车票信息。var json = res.data，获取data对象（网络请求返回的数据一般为JSON格式），赋给变量json；var jsonString = JSON.stringify(json)，将JSON类型对象暂时转换为String类型，用来作为url的参数部分进行传递；一开始在这里耽搁了很久，不进行转换直接传的话在目标页面获取不到想要的数据，下面会说明原因；url: '../train/train?trainInfos='+jsonString，通过url指定的信息跳转到对应页面，如果不需要额外参数，直接写url: '../train/train'；如果只是传递简单的值，可写成url: '../train/train?param=123'；至此，如果网络没有问题，点击按钮便可以进行火车票的查询并携带结果数据跳转到新页面了。 3.2 traintrain是自定义新建的页面，用来显示火车票基本信息，注意新添的页面需在app.json文件中进行配置。\"pages/train/train\",  //火车票车次信息页面 \"pages/seat/seat\"  //车次余票信息页面3.2.1 train.wxml由于站--站火车票所有车次的始发站和终点站是一样，如北京--杭州东，所以先在页面顶部显示站点信息：<text class=\"train-item\">出发地：{{trainList[0].from}}</text><text class=\"train-item\">目的地：{{trainList[0].to}}</text>trainList对象会在js文件中定义成data成员，值为上面最后一张图中的JSON对象--trainList，即火车票车次数组，每个元素包含一个车次的具体信息。接下来显示每个车次的信息，以横线作分隔（由于是以学习和测试为目的，所以就没有在布局的美观上下功夫，大家见谅）：<view class=\"line\"></view><block wx:for=\"{{trainList}}\" wx:for-item=\"train\">    <text class=\"train-item\">{{index+1}}. 车次：{{train.trainNo}}</text>    <text class=\"train-item\">车型：{{train.trainType}}</text>    <text class=\"train-item\">起始时间：{{train.startTime}}</text>    <text class=\"train-item\">到站时间：{{train.endTime}}</text>    <text class=\"train-item\">总时长：{{train.duration}}</text>    <view id=\"trainindex-{{index}}\" class=\"getseat-button\" bindtap=\"getSeatInfo\">        <text>点击查看座位信息</text>    </view>    <view class=\"line\"></view></block>第1、11行很简单，在站点与车次、车次与车次之间添加横线。当布局中的组件个数和js中的数据有关，即在wxml中写死组件不能满足需求时，可以利用block和wx:for来进行组件的动态生成。第2行wx:for=\"{{trainList}}\"表示block块中的组件可以使用数组trainList中的内容，从下标0开始迭代，数据中有几个元素，就会动态生成几套组件。wx:for-item=\"train\"指定数组中元素的名称为train（默认的是item，指定的意义之一是可读性强），后续获取属性值时可通过train.key_name的形式。第3行开始添加组件，类型是text，值为{{index+1}}. 车次：{{train.trainNo}}，前半部分用来标明每个车次的序号，从1开始；而index和item类似，是默认的迭代索引名称，其实就是数组元素当前的下标，从0开始。后面几行添加text组件和第3行差不多，但第8行有两个点说一下：*1 bindtap=\"getSeatInfo\"，绑定一个回调函数，点击时跳转到新页面，显示当前车次对应的座位信息；*2 id=\"trainindex-{{index}}\"，给组件指定id，可以看到之前的组件都没有设置过该属性（不需要就可以不设置），那么什么时候需要呢？其中一种情况，当js中某组件绑定的回调方法需要得知是哪个组件触发了自己的时候，比如第一点中的方法getSeatInfo，要想点击某车次的查看座位信息按钮后显示出对应的座位信息，就得知道点击组件对应的trainList数组下标，而这个需求，正好可以借助id和index属性来实现；3.2.2 train.js首先定义data成员trainList，用来接收index页面传递过来的数据：trainList: []页面启动时若有数据需要载入，那么得添加onLoad方法（一开始自动运行，在其中实现数据的加载与处理），否则可以不添加。onLoad: function(options) {　　var jsonString = options.trainInfos;　　//将字串类型转为JSON类型　　var json = JSON.parse(jsonString);　　this.setData({    　　trainList: json.data.trainList,　　});},当方法的调用者有参数传入时，我们可以通过添加方法参数的形式来获取。对于参数名，自动启方法一般为options，组件回调方法一般为e（event）。第2行获取index页面在打开train页面时传入的火车票信息参数trainInfos。第4行将String类型对象转换回JSON格式，之前在index页面提到过，url传的参数是由JSON格式对象转换过来的String类型。第6行将真正的火车票车次信息数组取出，赋给数据成员trainList。注意：给数据成员赋值时，必须调用页面自身的setData方法，否则就算赋值了也不会同步到wxml文件中去，这一点容易出错且不好定位原因。车次数组得到后，wxml文件就会根据组件的属性设置显示对应的信息。再来看实现按钮“点击查看座位信息”对应的回调方法：getSeatInfo: function(e) {    var prefix = 'trainindex-';    var trainIndex = e.currentTarget.id.substring(prefix.length);    //输出根据组件id获取的车票索引，用以显示详细的座位信息    console.log(trainIndex);    var trainNo = this.data.trainList[trainIndex].trainNo;    var json = this.data.trainList[trainIndex].seatInfos;    //将JSON类型转为String类型用以url参数传递，否则传递后会变成[object Object]，同时传递车次    var jsonString = JSON.stringify(json);    wx.navigateTo({        url: '../seat/seat?'+'trainNo='+trainNo+'&seatInfos='+jsonString,    });},第2、3行获取之前定义的组件id中的index部分，即点击组件对应的trainList数组的下标。当然原先定义时也可以不添加前缀'trainindex-'，完全是为了可读性，因为当项目越来越大时有个一目了然的标示总是不错的。第6、7行分别获取车次信息的列车号与座位信息，他们稍候会被传递到seat页面。第9行同样地将得到的JSON格式对象先转换为String类型，让其可以在url中作为可被正确传递的参数。第11行打开新的页面seat显示座位信息，多个参数之间以“&”符号分隔。3.2.3 train.json主程序中app.json文件除了配置需要调用onLoad方法的页面外，还指定了一些全局的window样式。若某个页面在自己的json文件中没有定义局部的window属性，或根本没有json文件，那默认将使用全局的。项目初始没有为index生成json文件，因为其作为启动页，直接用全局的“WeChat”就好，其实index标题应该是小程序的名称，我们自己真正开发的程序肯定得取另一个名字。可以看到，logs、train及seat都对标题进行了定义，结果就是会覆盖掉全局的值。以train为例，其在json文件中定义标题为“站-站火车查询信息”：{ 　　\"navigationBarTitleText\": \"站-站火车查询信息\" }还有一点，页面的json文件不需要也不能页面配置属性（Pages），只能设置window属性，所以就可以省略window名称，直接像上述代码用{...}形式即可。 3.3 seatseat页面用来显示某车次的座位信息，包括座位等级、票价及余票。通过train页面的分析，相信大家对网络请求，数据在页面与页面、wxml与js文件之间的传递渐渐熟悉了。而seat和train类似，没有什么特别的地方，所以和logs一样这里就不再讲什么了。 4. 小感悟 微信小程序，虽然目前还不知道其在微信的接入口，但应该和订阅号、服务号以及企业号会有所不同。搜索打开使用，用完关闭，没有移动app的安装、下载等过程，微信流量大，轻便、易用等特性是其优点。然而正是因为这个优点，开发者担心这有可能使得小程序不能够像app那样强大，毕竟接入口、审核机制、推广成本以及最大允许内存等这些还未确定的因素对一款应用来说都是至关重要的。对于初学者（如原先搞android开发），暂且不管上面提到的那些，在弄明白应用需求的同时，得迈开并加快对前端知识学习的脚步了。本文项目代码获取地址Github：https://github.com/VincentWYJ/WXAppTrain.git；Blog file：http://files.cnblogs.com/files/tgyf/WXAppTrain.rar；"}
{"title": "零基础入门篇：微信小程序开发博客项目《上》 ", "author": "天下雪", "pub_time": "2016-10-18 22:24", "article_content": "刚好这几天空闲时间比较多，就来记录下开发一个小程序，粗略版博客（这个是零基础入门篇幅，比较繁琐，若已经入门，请忽略）1、新建项目选择无AppID模式进入项目初始化2、文件讲解小程序里面一个文件夹就是一个页面，包含四个文件。.js结尾的是脚本文件。.wxml是页面标签文件，即类似我们原先使用的html标签一样。.wxss是样式文件，即是我们原先使用的css3.3、开始开发打开文件app.json，page对象表示每添加一个页面，就需要往里面加一条路由，名称必须和文件夹和文件一致。4、路由导航由于小程序默认首页是index，在首页触发事件后我们需要进行处理编辑blog文件夹下面blog.wxml,里面添加“<view>这个是我个人博客</view>”，编辑index文件里面的index.js文件，添加路由，完成后保存文件（一定要保存），点击开发工具左侧菜单栏“编译”，然后就进入页面进入主页后，点击下，触发我们刚刚绑定的函数，跳转到我们的页面"}
{"title": "微信小程序把玩《五》：checkbox组件，form组件，input组件 ", "author": "天下雪", "pub_time": "2016-10-20 13:06", "article_content": "一：checkbox组件不得不吐糟下checkbox默认样式真是有点略丑！！！checkbox组件为一个多选框被放到checkbox-group组中，并在checkbox-group（只能包含checkbox）中设置监听事件。checkbox-group监听方法：checkbox多选属性：wxml<!--checkbox-group就是一个checkbox组 有个监听事件bindchange，监听数据选中和取消--><checkbox-group bindchange=\"listenCheckboxChange\"><!--这里用label显示内容，for循环写法 wx:for-items 默认item为每一项-->    <label style=\"display: flex;\"  wx:for-items=\"{{items}}\">    <!--value值和默认选中状态都是通过数据绑定在js中的-->        <checkbox value=\"{{item.name}}\" checked=\"{{item.checked}}\"/>{{item.value}}    </label></checkbox-group>jsPage({    /**     * 初始化数据     */  data:{    items: [        {name: 'JAVA', value: 'Android', checked: 'true'},        {name: 'Object-C', value: 'IOS'},        {name: 'JSX', value: 'ReactNative'},        {name: 'JS', value: 'wechat'},        {name: 'Python', value: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\nxiaochengxu123\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发工具安装指南及注意事项 \n              微信小程序简易全攻略《一》开始构建与创建页面 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《六》：picker组件，radio组件，slider组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSTN8DDV', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1542709855|ee37a674a90971d240d6f31435aac1c8|2';"}
{"title": "微信小程序简易全攻略《一》开始构建与创建页面 ", "author": "天下雪", "pub_time": "2016-10-20 14:23", "article_content": "一：开始构建最近微信小程序开始火起来了，虽然还没开放公测，但是开发工具，本地环境却是可以构建了废话不多说，直接进入正题；1. 首先下载工具https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1474632113_xQVCl&token=&lang=zh_CN点击上面的链接 找到小程序开发者工具 点击下载 对应版本，傻瓜式的安装不必细述2. 构建小程序安装完成后  双击 打开应用  打开微信并扫描 确认登录即可点击添加项目选择 无 AppID  -->  填写项目名称 -->  选择项目目录（没有的话可以先创建一个空文件夹） --> 点击 添加项目欧了  简单的 hello world 就创建好了二：创建页面好了 hello world 创建好了 ，咱开始写页面了，那么如何创建一个简单的页面呢，废话不多说，开始撸代码新建一个页面需要以下几步，1. 在pages 中添加一个目录（当然如果你觉得写在现有的目录里面就好 那这一步就省略啦）点击左侧的 编辑  -->  点中 pages 文件夹  -->   点击右上角的  +  号  --> 在下拉菜单中选择 目录  --> 弹出框中 填写目录 名称 （这里我们写了test）--> 点击 确定2. 新建一个wxml 文件选中 test  文件夹 --> 点击 右上角  + 号  --->  选择  wxml 类型 文件  --> 填入文件名  （注意 这里必须填写 后缀名 至少 我的版本是必须填入的）3. 编辑test.wxml 文件为了方便测试 我们随便 填写点内容进去[html] view plain copy<view class=\"container\">      <text>这是我的test页面哦哦！！！</text>  </view>  4. 创建test.js文件使用同样的方法在test 目录下创建一个 test.js 文件[javascript] view plain copy//test.js  //获取应用实例  var app = getApp()  Page({    data: {      userInfo: {}    },    onLoad: function () {      console.log('onLoad test');    }  })  5. 将test 页面加入 app.json在pages 属性中 加入一条 test 页面所在的目录 这里是相对路径 首部不必填写 /6. 在首页加入访问链接好了 上面路径也加好了 我们得加个入口 才能看到自己写的页面啊 ， 小程序的首页一般是默认显示 pages 属性中的第一条路径所指向的页面  ，如果我们不想破坏原有的 那么 我们直接找到首页  pages/index/index.wxml  添加一个链接[html] view plain copy<view class=\"btn-area\">     <navigator url=\"/pages/test/test\" hover-class=\"navigator-hover\">跳转test页面</navigator>   </view>  7. 访问一且准备就绪 ，点击左下角的 “编译”，出现如下 页面 然后 点击 “”跳转test页面“”哇哈哈，看到了没，你的页面做好了！！！（注意所有页面编辑后 请按 ctrl + s 保存键）"}
{"title": "微信小程序简易全攻略《二》设置页面标题与底部导航 ", "author": "天下雪", "pub_time": "2016-10-20 14:33", "article_content": "一：设置页面标题页面写好了，总感觉哪里不爽，对，就是那，每个页面的标题都一样，都是 Wechatcou 呀 真cou, 那咱就单独说说，如何设置 页面标题。设置页面标题 ，相当的简单，找到所在页面的目录，新建一个 json 文件，比如我们上一次建造的 test 页面我们  找到 pages/test/ 目录 新建一个 test.json 文件 加入如下代码{    \"navigationBarTitleText\": \"霸气侧漏\"  } view plain co效果如下：二：设置底部导航好了 小程序的头部标题 设置好了，我们来说说底部导航栏是如何实现的。我们先来看个效果图这里，我们添加了三个导航图标，因为我们有三个页面，微信小程序最多能加5个。那他们是怎么出现怎么着色的呢？两步就搞定！1. 图标准备阿里图标库  http://www.iconfont.cn/collections/show/29我们进入该网站，鼠标滑到一个喜欢的图标上面  点击下方的 下载按钮在弹出框中 选择了 俩个不同颜色的 图标  选择64px大小即可，我选择的是png  然后下载下来 起上别名 将上述起好名字的图标 保存到 小程序 项目目录中 新创建的 images 文件夹中，准备工作就做好了2. 更改配置文件我们找到项目根目录中的配置文件 app.json 加入如下配置信息 \"tabBar\": {    \"color\": \"#a9b7b7\",    \"selectedColor\": \"#11cd6e\",    \"borderStyle\":\"white\",    \"list\": [{      \"selectedIconPath\": \"images/111.png\",      \"iconPath\": \"images/11.png\",      \"pagePath\": \"pages/index/index\",      \"text\": \"首页\"    }, {      \"selectedIconPath\": \"images/221.png\",      \"iconPath\": \"images/22.png\",      \"pagePath\": \"pages/logs/logs\",      \"text\": \"日志\"    }, {      \"selectedIconPath\": \"images/331.png\",      \"iconPath\": \"images/33.png\",      \"pagePath\": \"pages/test/test\",      \"text\": \"开心测试\"    }]  },解释一下 对应的属性信息tabBar  指底部的 导航配置属性color  未选择时 底部导航文字的颜色selectedColor  选择时 底部导航文字的颜色borderStyle  底部导航边框的样色（注意 这里如果没有写入样式 会导致 导航框上边框会出现默认的浅灰色线条）list   导航配置数组selectedIconPath 选中时 图标路径iconPath 未选择时 图标路径pagePath 页面访问地址text  导航图标下方文字如果要改变更详细的样式 请参看https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabBar好了，保存 编译  就可以看到上面的效果了。"}
{"title": "微信小程序简易全攻略《三》创建轮播图与数据请求，表单的创建、提交、与接收 ... ", "author": "天下雪", "pub_time": "2016-10-20 15:04", "article_content": "一：创建轮播图应用中最常见的就是轮播图了，今儿个就讲讲微信小程序中轮播图的使用轮播图，不外乎俩个要素，跳转链接 和 图片地址1. 设置数据我在 pages/test/test.js中添加如下数据//test.js//获取应用实例var app = getApp()Page({  data: {      imgUrls: [       {          link:'/pages/index/index',          url:'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg'        },{          link:'/pages/logs/logs',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg'        },{          link:'/pages/test/test',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'        }     ],    indicatorDots: true,    autoplay: true,    interval: 5000,    duration: 1000,    userInfo: {}  },  onLoad: function () {    console.log('onLoad test');  }})其中 imgUrls 是我们轮播图中将要用到的 图片地址和 跳转链接indicatgorRots 是否出现焦点autoplay  是否自动播放interval  自动播放间隔时间duration 滑动动画时间更多样式编辑请参看文档  https://mp.weixin.qq.com/debug/wxadoc/dev/component/swiper.html?t=14750520542282. 部署到页面找到 文件 pages/test/test.wxml<swiper indicator-dots=\"{{indicatorDots}}\"        autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">      <block wx:for=\"{{imgUrls}}\">        <swiper-item>           <navigator url=\"{{item.link}}\" hover-class=\"navigator-hover\">            <image src=\"{{item.url}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>           </navigator>         </swiper-item>      </block></swiper>注意： swiper 千万不要在外面  加上任何标签 例如 <view> 之类的 ，如果加了可能会导致轮播图出不来3. 添加页面样式创建文件 pages/test/test.wxss.slide-image{      width: 100%;  }  加上上面的样式可以使 轮播图的宽度达到100% 然后更漂亮点，当然可以根据自己的喜好罗！看效果二：数据请求 表单的创建 提交 与接收开始正题了，本节小小研究了下 微信小程序的表单创建与提交先看看效果1. 表单页面<view id=\"adduser\">    <form bindsubmit=\"formSubmit\" bindreset=\"formReset\">         <view class=\"section\">            <view class=\"section__title\">姓名:</view>            <view class='form-group'>                <input type=\"text\" class=\"input-text\" name=\"username\" placeholder=\"请输入姓名\" />            </view>            </view>        <view class=\"section section_gap\">            <view class=\"section__title\">年龄:</view>            <view class='form-group'>                <slider name=\"age\" show-value ></slider>            </view>            </view>        <view class=\"section section_gap\">            <view class=\"section__title\">性别:</view>            <view class='form-group'>                <radio-group name=\"gender\">                  <label><radio value=\"1\"/>男</label>                  <label><radio value=\"0\"/>女</label>                </radio-group>            </view>            </view>        <view class=\"section\">            <view class=\"section__title\">地区选择:</view>            <view class='form-group'>                <picker bindchange=\"bindPickerChange\" value=\"{{index}}\" range=\"{{array}}\">                    <view class=\"picker\">                        <input type=\"hidden\" disabled=\"true\" name=\"addr\" value=\"{{array[index]}}\"/>                    </view>                </picker>            </view>        </view>        <view class=\"section section_gap\">            <view class=\"section__title\">爱好:</view>            <view class='form-group'>                <checkbox-group name=\"hobby\">                    <label><checkbox value=\"羽毛球\"/>羽毛球</label>                    <label><checkbox value=\"游泳\"/>游泳</label>                </checkbox-group>            </view>        </view>                <view class=\"section section_gap\">            <view class=\"section__title\">是否显示:</view>            <view class='form-group'>                 <switch name=\"isshow\"/>            </view>        </view>        <view class=\"section btn-area\">            <button formType=\"submit\">提交</button>            <button formType=\"reset\">清空</button>        </view>    </form>     <!-- 黑框提示并消失 -->    <toast hidden=\"{{toast1Hidden}}\" bindchange=\"toast1Change\">        {{notice_str}}    </toast>    <!-- 确认框 及 提示框 -->    <view class=\"page__bd\">        <modal title=\"确认\" confirm-text=\"确定\" cancel-text=\"取消\" hidden=\"{{modalHidden}}\" mask bindconfirm=\"confirm_one\" bindcancel=\"cancel_one\">            确认提交么？        </modal>        <modal class=\"modal\" hidden=\"{{modalHidden2}}\" no-cancel bindconfirm=\"modalChange2\" bindcancel=\"modalChange2\">            <view> 提示 </view>            <view> 清空成功 </view>        </modal>    </view></view>    2. js 代码var app = getApp();Page({  data:{    // text:\"这是一个页面\"    array:[\"中国\",\"美国\",\"巴西\",\"日本\"],    toast1Hidden:true,    modalHidden: true,    modalHidden2: true,    notice_str: '',    index:0  },  toast1Change:function(e){    this.setData({toast1Hidden:true});  },  //弹出确认框  modalTap: function(e) {    this.setData({      modalHidden: false    })  },  confirm_one: function(e) {    console.log(e);    this.setData({      modalHidden: true,      toast1Hidden:false,      notice_str: '提交成功'    });  },  cancel_one: function(e) {    console.log(e);    this.setData({      modalHidden: true,      toast1Hidden:false,      notice_str: '取消成功'    });  },  //弹出提示框  modalTap2: function(e) {    this.setData({      modalHidden2: false    })  },  modalChange2: function(e) {    this.setData({      modalHidden2: true    })  },  bindPickerChange: function(e) {    console.log('picker发送选择改变，携带值为', e.detail.value)    this.setData({      index: e.detail.value    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  },  formSubmit: function(e) {    var that = this;    var formData = e.detail.value;     wx.request({      url: 'http://test.com:8080/test/socket.php?msg=2',      data: formData,      header: {          'Content-Type': 'application/json'      },      success: function(res) {        console.log(res.data)        that.modalTap();      }    })  },  formReset: function() {    console.log('form发生了reset事件');    this.modalTap2();  }})3. 部分样式#adduser{    background: #f5f5f5;}.section__title{    float: left;    width:30%;}.form-group{    float: right;    width: 70%;}.section{    clear: both;    width:90%;    margin: 2rem auto;}.input-text{    border: 1px solid #ddd;}.button{    border: 1px solid #1aad19;    border-radius: 2px;}.picker{    padding: 13px;    background-color: #FFFFFF;}4. 服务器端<?phpvar_dump($_REQUEST);本节 集合了 表单  https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html?t=1476197486816数据请求 https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1476197484427提示框  https://mp.weixin.qq.com/debug/wxadoc/dev/component/toast.html?t=1476197486420确认和非确认框  https://mp.weixin.qq.com/debug/wxadoc/dev/component/modal.html?t=1476197489278以及相关表单 的信息 ， 之后将分解讲解 对应的小功能。"}
{"title": "微信小程序简易全攻略《四》模板条件列表渲染完成模拟公众号自动回复 ... ", "author": "天下雪", "pub_time": "2016-10-20 15:10", "article_content": "最近突发奇想，如果微信小程序不在微信公众号里了该如何使用 自动回复呢？先看下效果话不多说 直接上代码1.页面代码：<swiper indicator-dots=\"{{indicatorDots}}\"        autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">      <block wx:for=\"{{imgUrls}}\">        <swiper-item>           <navigator url=\"{{item.link}}\" hover-class=\"navigator-hover\">            <image src=\"{{item.url}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>           </navigator>         </swiper-item>      </block></swiper> <block>    <input type=\"text\" class=\"input-text\" bindchange=\"setInputValue\"  placeholder=\"请输入你要咨询的内容\"/>    <button bindtap=\"getgetinputSEnd\" class=\"input-button\">发送</button></block><view class=\"chat-area\">        <view wx:for=\"{{msgs}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">        <view class=\"say-title\">            <block wx:if=\"{{idx%2 != 0}}\"><text class=\"red-font\">客服：</text></block>            <block wx:if=\"{{idx%2 == 0}}\"><text class=\"green-font\">你：</text></block>        </view>        <view class=\"say-content\">            <block wx:if=\"{{itemName.type == 'video'}}\">                <video src=\"{{itemName.msg}}\"></video>            </block>            <block wx:if=\"{{itemName.type == 'voice'}}\">                <audio src=\"{{itemName.msg}}\" controls loop></audio>            </block>            <block wx:if=\"{{itemName.type == 'image'}}\">                <image src=\"{{itemName.msg}}\"></image>            </block>            <block wx:if=\"{{itemName.type == 'text'}}\">                <text>{{itemName.msg}}</text>            </block>        </view>    </view></view>页面中 使用了 模板的 条件渲染 ：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1476197490824 列表渲染：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html?t=14761974929812. 样式代码.slide-image{    width: 100%;}.input-text{border:1px solid #abcdef;width:88%;background:#ddd;line-height:100%;text-indent: 0.5rem;margin:1rem auto;height:40px;}.input-button{    background:#48C23D;margin:0.5rem 5%;color:#fff;}.chat-area{    width: 90%;    margin:0.5rem 5%;    border:1px solid #ddd;    background:#eee;    font-size: 1rem;}.red-font{    color:#DC143C;}.green-font{    color:#48C23D;}.say-content{font-size:80%;width:80%;margin:0.5rem 5%;}3. js代码//test.js//获取应用实例var app = getApp();Page({  data: {      imgUrls: [       {          link:'/pages/index/index',          url:'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg'        },{          link:'/pages/logs/logs',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg'        },{          link:'/pages/test/test',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'        }     ],    indicatorDots: true,    autoplay: true,    interval: 5000,    duration: 1000,    msgs:[],    inputdata:'',    userInfo: {}  },  onLoad: function () {    console.log('onLoad test');    console.log(this.data.msgs);  },  getgetinputSEnd:function(){      var input = this.data.inputdata;      var that = this;      var msgs = that.data.msgs;       msgs.push({msg:input,'type':'text'});      //--------------------------------- 微信数据请求           wx.request({        url: 'http://test.com:8080/test/socket.php',        data: {          msg:input        },        header: {            'Content-Type': 'application/json'        },        success: function(res) {          msgs.push({msg:res.data.content,'type':res.data.msgType});          that.setData({msgs:msgs});          console.log(res.data)        }      })       },  setInputValue:function(e){      console.log(e.detail);      this.data.inputdata = e.detail.value;  }})4. 服务器端代码<?php$params = $_REQUEST;$msg = $params['msg'];$content = array();switch ($msg) {    case '1': \tcase '美女': \t\t$content['msgType'] = 'image'; \t\t$content['content'] = 'https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=ae4df4ec878ba61ec0eecf2f713497cc/43a7d933c895d143b233160576f082025aaf074a.jpg'; \t\tbreak; \tcase '2': \tcase '音乐': \t\t$content['msgType'] = 'voice'; \t\t$content['content'] = 'http://www.w3school.com.cn/i/song.mp3'; \t\tbreak; \tcase '3': \tcase '视频': \t\t$content['msgType'] = 'video'; \t\t$content['content'] = 'http://www.w3school.com.cn//i/movie.ogg'; \t\tbreak;\t \tcase '4': \tcase '笑话': \t\t$content['msgType'] = 'text'; \t\t$content['content'] = '一男子在闹市骑摩托撞昏了一个陌生的老汉! 男子惊吓的不知所措!围观群众越来越多!突然,该男抱住老汉,声泪俱下的喊道:“爹,你等着我,我这就去给...'; \t\tbreak;\t\t \tdefault: \t\t$content['msgType'] = 'text'; \t\t$content['content'] = '您发送的指令不在识别范围内： \t\t                       你可以选择  \t\t                         1 美女  \t\t                         2 音乐 \t\t                         3 视频 \t\t                         4 笑话 '; \t\tbreak; }  echo json_encode($content);"}
{"title": "微信小程序开发新手实战教程 ", "author": "天下雪", "pub_time": "2016-10-20 17:47", "article_content": "创建快捷项目app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。 app.json是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 app.wxss是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。App({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  },  onShow:function() {    console.log(\"show\");  },  onHide:function() {    console.log(\"hide\");  }})注意必须在 app.js 中注册App() ，不能注册多个。 onLaunch：程序初始化执行，且只执行一次。 onShow:程序启动，或从程序后台进入前台时执行。 onHide:程序从前台进入后台时执行。 可以添加任意函数到OBJECT中，使用this访问。底部导航 添加images目录，放入图片资源并添加主程序页面 添加底部导航tabBar{  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\",    \"pages/main/main\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#dddddd\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  },  \"tabBar\":{    \"color\":\"#000\",    \"selectedColor\":\"#48c33c\",    \"borderStyle\":\"block\",    \"backgroundColor\":\"#ffffff\",    \"list\":[{      \"pagePath\":\"pages/index/index\",      \"iconPath\":\"images/footer/index.png\",      \"selectedIconPath\":\"images/footer/indexS.png\",      \"text\":\"首页\"    },    {      \"pagePath\":\"pages/logs/logs\",      \"iconPath\":\"images/footer/logs.png\",      \"selectedIconPath\":\"images/footer/logsS.png\",      \"text\":\"日志\"    },    {      \"pagePath\":\"pages/main/main\",      \"iconPath\":\"images/footer/main.png\",      \"selectedIconPath\":\"images/footer/mainS.png\",      \"text\":\"主程序\"    }    ]  }}color：文字默认颜色 selectedColor：文字选中颜色 borderStyle：上边框颜色（只支持black/white） backgroundColor：背景色 list：菜单列表list属性 pagePath：页面路径（需要在pages中初始化） iconPath：图片路径，大小限制40kb selectedIconPath：选中样式图片路径，大小限制40kb text：按钮文字数据绑定main.jsPage({\r\n  data:{\r\n    text:\"这是一个页面\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})12345678910111213141516171819201234567891011121314151617181920main.wxml<view>\r\n    <text>{{text}}</text>\r\n</view>123123view组件 flex-direction： row：横向排列；column：纵向排列 justify-content：flex-start：左对齐； flex-end：右对齐；center：居中；space-between：两端分散对齐；space-around：居中分散对齐 align-items：flex-start：垂直顶部；flex-end：垂直底部；center：垂直居中轮播    <swiper indicator-dots=\"true\" autoplay=\"true\" duration=\"1000\" bindchange=\"listenSwiper\" >\r\n        <swiper-item>\r\n            <view style=\"background: red; height: 150px\"></view>\r\n        </swiper-item>\r\n        <swiper-item>\r\n            <view style=\"background: green; height: 150px\"></view>\r\n        </swiper-item>\r\n            <swiper-item>\r\n            <view style=\"background: blue; height: 150px\"></view>\r\n        </swiper-item>    \r\n    </swiper>12345678910111234567891011属性名 类型 默认值 说明 indicator-dots Boolean false 是否显示面板指示点 autoplay Boolean false 是否自动切换 current Number 0 当前所在页面的 index interval Number 5000 自动切换时间间隔 duration Number 1000 滑动动画时长 bindchange EventHandle current 改变时会触发 change 事件，event.detail = {current: current} 注意：其中只可放置组件，其他节点会被自动删除。 仅可放置在组件中，宽高自动设置为100%。获取轮播改变事件listenSwiper:function(e) {\r\n    console.log(e)\r\n},123123值Object {target: Object, currentTarget: Object, type: \"change\", timeStamp: 35345, detail: Object}\r\ncurrentTarget\r\n:\r\nObject\r\ndetail\r\n:\r\nObject\r\ntarget\r\n:\r\nObject\r\ntimeStamp\r\n:\r\n35345\r\ntype\r\n:\r\n\"change\"\r\n__proto__\r\n:\r\nObject1234567891011121314151617181912345678910111213141516171819图标 icon type 有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear size 默认23px color 同css的color<!--成功图标-->    <icon type=\"success\" size=\"40\"/>    <!--安全成功标志图标-->    <icon type=\"safe_success\" size=\"40\"/>    <!--提示信息图标-->    <icon type=\"info\" size=\"40\"/>    <!--带圆的信息提示图标-->    <icon type=\"info_circle\" size=\"40\"/>    <!--不带圆的成功图标-->    <icon type=\"success_no_circle\" size=\"40\"/>    <!--带圆的成功图标-->    <icon type=\"success_circle\" size=\"40\"/>    <!--警告图标-->    <icon type=\"warn\" size=\"40\"/>    <!--带圆的等待图标-->    <icon type=\"waiting_circle\" size=\"40\"/>    <!--等待图标-->    <icon type=\"waiting\" size=\"40\"/>    <!--下载图标-->    <icon type=\"download\" size=\"40\"/>    <!--取消图标-->    <icon type=\"cancel\" size=\"40\"/>    <!--清除图标-->    <icon type=\"clear\" size=\"40\"/>    <!--改变颜色的success-->    <icon type=\"success\" size=\"40\" color=\"red\"/>进度条 percent Float 无 百分比0~100 show-info Boolean false 在进度条右侧显示百分比 stroke-width Number 6 进度条线的宽度，单位px color Color #09BB07 进度条颜色 active Boolean false 进度条从左往右的动画<progress percent=\"80\" show-info=\"true\" stroke-width=\"5\" color=\"red\" active=\"true\"/>按钮 button    <button type=\"defaule\" bindtap=\"clickButton\">Defalut</button>    <!--原始颜色，不可点击状态， 正在加载状态-->    <button type=\"primary\" disabled=\"true\" loading=\"true\">Primary</button>    <button type=\"warn\">warn</button>注：button-hover 默认为{background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;}按钮点击事件  clickButton: function(e) {    console.log(e);  },CHECKBOX    <!--checkbox-group是checkbox的组，使用bindchange，监听数据选中和取消-->    <checkbox-group bindchange=\"listenCheckboxChange\">        <label style=\"display: flex;\"  wx:for-items=\"{{items}}\">            <checkbox value=\"{{item.name}}\" checked=\"{{item.checked}}\"/>{{item.value}}        </label>    </checkbox-group>绑定事件 绑定数据items: [        {          name: 'S',           value: 'S',           checked: 'true'        },        {          name: 'O',           value: 'O'        },        {          name: 'N',           value: 'N'        },        {          name: 'G',           value: 'G'        },        {          name: 'SONG',           value: 'SONG'        }    ]绑定监听事件  listenCheckboxChange:function(e) {      console.log(e);  },至此页面源代码（Git）：https://github.com/yz-mengxiangsong/wechatDemo.git"}
{"title": "秀杰实战教程系列《五》：实战课程之记账应用开发（续） ", "author": "天下雪", "pub_time": "2016-10-21 10:26", "article_content": "缘起：昨天官方开发有了更新v0.10.101100，Picker的mode属性已经支持date以及time（background-image的bug也修复），于是来更新此实例。目标：实现集成日期组件如图官方文档出处：https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html步骤，在item.wxml文件中增加一个picker组件，如下：如图从图中可以看出：1.日期后面是空白的，应该默认显示今天日期； 2.点击确定也没有显示到组件上，需要实现bindDateChange方法。于是我们需要在item.js文件中，声明一个data值date与wxml中的{{date}}绑定关联然后在onLoad中初始化字符串格式的日期值，详细说明见注释：经过如上处理，日期组件已经显示为当前日期如图处理到此，我们还需要修复一个逻辑错误，即组件的结束日期应该不超过当日，做法也很简单，只需要在wxml文件中对picker的日期属性end由2017-09-01改为{{date}}即可<picker mode=\"date\" value=\"{{date}}\" start=\"{{date}}\" end=\"2017-09-01\" bindchange=\"bindDateChange\">\r\n吐槽一下，官方的picker的还是有bug的，完全不听start与end使唤，仍可以选任意日期，暂时不去理会，代码就这么写着，什么时候开发工具修复了自然可以了，毕竟是现在还只是内测，就将就用着。接下来处理日期组件点击确认事件bindDateChange回到item.js文件声明一个bindDateChange方法，添加如下代码以写回data中的date值至此，已经实现集成日期picker组件。剩下的就是将它同之前的标题、类型、金额字段那样存在json再本地setStorage存储即可，这里不作赘述"}
{"title": "新手跳坑指南：小程序开发过程中遇到的各种坑 ", "author": "天下雪", "pub_time": "2016-10-21 11:06", "article_content": "1：wx.request 中 method:\"POST” 模式下，后台收到请求，但是data:{}数据全部消失，也就是发了一个空请求！！2：wx.uploadFile和wx.downloadFile 这两个基佬传说在真机有效，在IDE环境中无效~~反正我是没试通，后台没收到任何请求3：【问题】wx.request 中 method:\"POST” 模式下，后台收到请求，但是data:{}数据全部消失，也就是发了一个空请求！！     【解决】可以看下是不是设置了Content-Type='application/json'，我是设置了这个后发现微信也会自动加上'application/json'导致Content-Type变成了application/jsonapplication/json，注释掉自己设置的Content-Type='application/json'就正常了4：【问题】wx.uploadFile和wx.downloadFile 这两个基佬传说在真机有效，在IDE环境中无效~~反正我是没试通，后台没收到任何请求     【解决】开发工具更新前pc无效，手机可以；开发工具更新后pc可以，手机可以。5：【问题】canvas的图片绘制实例无效！！（就是下边这些）var context = wx.createContext()wx.chooseImage({success: function(res) {context.drawImage(res.tempFilePaths[0], 0, 0)wx.drawCanvas({canvasId: 1,actions: context.getActions()})}})6：【问题】分割线用1rpx的时候有时候有些分辨率不显示     【解决】将单位改成px就可以了7：小程序中无法使用图文混合的富文本，以前在网站后台编辑的文章详情和商品详情都无法直接在小程序中正常显示"}
{"title": "微信小程序登录态验证流程 ", "author": "天下雪", "pub_time": "2016-10-21 11:42", "article_content": "点击进入原地址小程序调用wx.login得到code.调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）。用户数据的加解密通讯需要依赖会话密钥完成。小程序调用wx.getUserInfo得到rawData, signatrue, encryptData.小程序调用server获取token接口, 传入code, rawData, signature, encryptData.server调用微信提供的jsoncode2session接口获取openid, session_key, 调用失败应给予客户端反馈, 微信侧返回错误则可判断为恶意请求, 可以不返回. 微信文档链接这是一个 HTTP 接口，开发者服务器使用登录凭证 code 获取 session_key 和 openid。其中 session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。接口地址：\"https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code\"server计算signature, 并与小程序传入的signature比较, 校验signature的合法性, 不匹配则返回signature不匹配的错误. 不匹配的场景可判断为恶意请求, 可以不返回. 微信文档链接通过调用接口（如 wx.getUserInfo）获取敏感数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )将 signature、rawData、以及用户登录态发送给开发者服务器，开发者在数据库中找到该用户对应的 session-key，使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的可信度。使用第4步返回的session_key解密encryptData, 将解得的信息与rawData中信息进行比较, 需要完全匹配, 解得的信息中也包括openid, 也需要与第4步返回的openid匹配. 解密失败或不匹配应该返回客户相应错误. 微信文档链接接口如果涉及敏感数据（如wx.getUserInfo当中的 openid ），接口的明文内容将不包含敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据( encryptData )进行对称解密。 解密算法如下：对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。对称解密的目标密文为 Base64_Decode(encryptData),对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节对称解密算法初始向量 iv = aeskey, 同样是16字节rawData格式:{\r\n    \"nickName\": \"Band\",\r\n    \"gender\": 1,\r\n    \"language\": \"zh_CN\",\r\n    \"city\": \"Guangzhou\",\r\n    \"province\": \"Guangdong\",\r\n    \"country\": \"CN\",\r\n    \"avatarUrl\": \"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0\"\r\n}\r\nencryptData解密之后格式:{\r\n    \"openId\": \"OPENID\",\r\n    \"nickName\": \"NICKNAME\",\r\n    \"gender\": 1,\r\n    \"city\": \"CITY\",\r\n    \"province\": \"PROVINCE\",\r\n    \"country\": \"COUNTRY\",\r\n    \"avatarUrl\": \"AVATARURL\",\r\n    \"unionId\": \"UNIONID\"\r\n}\r\n使用session_key作为密钥, 加密至少包括openid, timestamp, random(随机值), version(版本)的内容, 得到token. 加密算法可以参考微信对encryptData的加密算法. server应该缓存session_key, 缓存的过期时间不应该小于token的过期时间. 将openid, token返回给客户端.小程序每次业务请求都必须带上openid和token, server验证token的合法性: token能否被正常解密; 解密后的openid和传入的openid是否一致; 解密后可得到token的生成时间, token是否过期. 全部校验通过即可正常处理业务请求."}
{"title": "秀杰实战教程系列《六》：服务端之用户注册与登录基于ThinkPHP5描述 ... ", "author": "天下雪", "pub_time": "2016-10-21 14:46", "article_content": "1.下载ThinkPHP 5.0.1：http://www.thinkphp.cn/down/855.html2.安装 解压到站点根目录http://localhost/thinkphp_5.0.1_core/public/访问，可以看到:) ThinkPHP V5 十年磨一剑 - 为API开发设计的高性能框架 [ V5.0 版本由 七牛云 独家赞助发布 ] 新手快速入门完全开发手册说明安装成功。以上url等同于http://localhost/thinkphp_5.0.1_core/public/index.php/index/index/index第一个index是模块名，第二个index是控制器名，第三个index是方法名出处参见config.php Line 60-673.用户登录控制器目标是我们需要一个如下的接口，供我们提交用户信息http://localhost/thinkphp_5.0.1_core/public/index.php/index/user/login参数：openid创建Controller稍加改造输出json格式header(\"Content-type: application/json\");无效！查看文档，需要改配置修改第36行4.用户登录模型5. 配置数据库信息进入database.php6. 建表7. 获取用户输入使用PostMan 测试输出\"灵犀网络\"字样8. 查询是否用户是否已经存在通过openid查询数据库，判断用户是否已经注册如有，返回用户的id,accessToken,username9. 插入新用户创建并返回用户信息10. json输入用户信息，供小程序本地缓存，主要是accessToken配置文件config.php指定了返回类型是json的话，不必通过$user->toArray()，即为纯净的array。而不是如下的对象格式。"}
{"title": "微信小程序开发之吐司toast(消息提示框) ", "author": "天下雪", "pub_time": "2016-10-21 14:50", "article_content": "做Android的时候对toast是很熟悉的.微信小程序开发中吐司也是重要的消息提示方式.上代码:1.index.wxmltoast是微信提供的组件,duration是延迟时间,单位毫秒.这里设置是1000ms.bindchange是事件.在index.js中触发事件即可。<!--index.wxml-->  <toast hidden=\"{{toastHidden}}\" duration=\"1000\" bindchange=\"onToastChanged\">            {{toastText}}    </toast>  2.index.js先在data中定义参数,toastHidden(吐司是否显示),toastText(吐司文本),函数onToastChanged(),当toastHidden变化为时执行,也就是为false时置为true;不加函数吐司不会消失。//index.js  //获取应用实例  var app = getApp()  Page( {    data: {      toastHidden: true, //吐司      toastText: '',//吐司文本    },    onToastChanged: function() {      this.setData( { toastHidden: !this.data.toastHidden });    },    onLoad: function() {      this.setData( {        toastHidden: false, //吐司        toastText: '我是吐司',//吐司文本      })    }  })  我是直接在页面初始化(onLoad:function)时执行,可根据自己需求赋值给toastHidden和toastText。"}
{"title": "微信小程序把玩《六》：picker组件，radio组件，slider组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:03", "article_content": "一：picker组件picker选择器分为三种，普通选择器，时间选择器， 日期选择器 用mode属性区分，默认是普通选择器。测试时时间和日期点击无反应不知道是BUG还是啥！没法手机测试现在也不知道咋回事！！主要属性：普通选择器时间选择器日期选择器wxml<view>普通选择器</view><!--mode默认selector range数据源value选择的index bindchange事件监听--><picker mode=\"selector\" range=\"{{array}}\" value=\"{{index}}\" bindchange=\"listenerPickerSelected\">    <text>{{array[index]}}</text></picker><view>时间选择器</view><picker mode=\"time\" value=\"{{time}}\" start=\"06:00\" end=\"24:00\" bindchange=\"listenerTimePickerSelected\">    <text>{{time}}</text></picker><view>日期选择器</view><picker mode=\"date\" value=\"{{date}}\" start=\"2016-09-26\" end=\"2017-10-10\" bindchange=\"listenerDatePickerSelected\">    <text>{{date}}</text></picker>jsPage({  data:{    // text:\"这是一个页面\"    array: ['Android', 'IOS', 'ReactNativ', 'WeChat', 'Web'],    index: 0,    time: '08:30',    date: '2016-09-26'  },  /**   * 监听普通picker选择器   */  listenerPickerSelected: function(e) {      //改变index值，通过setData()方法重绘界面      this.setData({        index: e.detail.value      });  },   /**   * 监听时间picker选择器   */  listenerTimePickerSelected: function(e) {      //调用setData()重新绘制      this.setData({          time: e.detail.value,      });  },  /**   * 监听日期picker选择器   */  listenerDatePickerSelected:function(e) {    this.setDate({      date: e.detail.value    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：radio组件赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                (1)\r\n\r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              新手跳坑指南：小程序开发过程中遇到的各种坑 \n              微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ...\n                                    \n                  • 微信小程序把玩《二》：页面生命周期，模块化，数据绑定，view组件 ... ...\n                                    \n                  • 微信小程序把玩《三》：scroll-view组件，swiper组件，icon组件\n                                    \n                  • 微信小程序把玩《四》：text组件，progress组件，button组件\n                                    \n                  • 微信小程序把玩《五》：checkbox组件，form组件，input组件\n                                    \n                  • 微信小程序把玩《八》：toast组件，loading组件，navigator组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                    \n                  • 小程序 自定义slider组件音频播放实例\n                                    \n                  • 微信小程序radio点选框，再次点击取消\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSTN8DDV', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1542709869|8d74b097fde782b99b5eb5755f59510a|2';"}
{"title": "微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:11", "article_content": "一：switch组件switch开关组件使用主要属性：wxml<!--switch类型开关--><view>switch类型开关</view><switch type=\"switch\" checked=\"true\" bindchange=\"listenerSwitch\"/><!--checkbox类型开关--><view>checkbox类型开关</view><switch type=\"checkbox\" bindchange=\"listenerCheckboxSwitch\" />jsPage({  data:{    // text:\"这是一个页面\"  },  /**   * switch开关监听   */  listenerSwitch: function(e) {    console.log('switch类型开关当前状态-----', e.detail.value);  },  /**   * checkbox类型开关监听   */  listenerCheckboxSwitch: function(e) {    console.log('checkbox类型开关当前状态-----', e.detail.value)  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：action-sheet组件action-sheet组件是从底部弹出可选菜单项，估计也是借鉴iOS的设计添加的，action-sheet有两个子组件， action-sheet-item为每个选项，action-sheet-cancel取消选项，与action-sheet-item中间会有间隔，并且点击会触发action-sheet监听事件主要属性：wxml<!--触发action-sheet事件--><button type=\"primary\" bindtap=\"listenerButton\">弹出ActionSheet</button><!--默认action-sheet为隐藏，由button触发--><action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"listenerActionSheet\" >    <block wx:for-items=\"{{actionSheetItems}}\" >         <action-sheet-item >{{item}}</action-sheet-item>    </block>    <!--自动隐藏action-sheet-->    <action-sheet-cancel>取消</action-sheet-cancel></action-sheet>jsPage({  data:{    // text:\"这是一个页面\"    actionSheetHidden: true,    actionSheetItems: ['item1', 'item2', 'item3']  },  listenerButton: function() {      this.setData({        //取反          actionSheetHidden: !this.data.actionSheetHidden      });  },  listenerActionSheet:function() {    this.setData({      actionSheetHidden: !this.data.actionSheetHidden    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})三：modal组件modal弹出框常用在提示一些信息比如：退出应用，清楚缓存，修改资料提交时一些提示等等。常用属性：wxml<!--监听button点击事件--><button bindtap=\"listenerButton\" type=\"primary\">弹出modal</button><!--弹出框--><modal     title=\"退出应用\"     hidden=\"{{hiddenModal}}\"     confirm-text=\"再看看\"     cancel-text=\"退出\"     bindconfirm=\"listenerConfirm\"     bindcancel=\"listenerCancel\" >     您是否真的要退出应用     </modal>jsPage({  data:{    // text:\"这是一个页面\"    hiddenModal: true  },  listenerButton:function() {      this.setData({          hiddenModal: !this.data.hiddenModal      })  },  listenerConfirm:function() {      this.setData({          hiddenModal: true      })  },  listenerCancel:function() {      this.setData({          hiddenModal: true      })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})"}
{"title": "精品教程：微信小程序实战之知乎日报 ", "author": "天下雪", "pub_time": "2016-10-21 16:27", "article_content": "上一次的《微信小程序之小豆瓣图书》制作了一个图书的查询功能，只是简单地应用到了网络请求，其他大多数小程序应有的知识。而本次的示例是知乎日报，功能点比较多，页面也比上次复杂了许多。在我编写这个DEMO之前，网上已经有很多网友弄出了相同的DEMO，也是非常不错的，毕竟这个案例很经典，有比较完整的API，很值得模仿学习。本次个人的DEMO也算是一次小小的练习吧。由于知乎日报是一个资讯类的App，UI的布局主要是以资讯列表页、资讯详情页和评论页为主，当然本次也附带了应用设置页，不过现阶段功能尚未编写，过段时间会更新补充，继续完善。API分析本次应用使用了知乎日报的API，相比上次豆瓣图书的数量比较多了，但是部分仍然有限制，而且自己没有找到评论接口的分页参数，所以评论这块没有做数据的分页。以下是使用到的具体API，更加详细参数和返回结构可参照网上网友分享的 知乎日报-API-分析 ，在此就不做再次分析了。启动界面图片http://news-at.zhihu.com/api/4/start-image/{size}参数说明size图片尺寸，格式：宽*高。例如: 768*1024获取刚进入应用时的显示封面，可以根据传递的尺寸参数来获取适配用户屏幕的封面。获取最新日报http://news-at.zhihu.com/api/4/news/latest返回的数据用于日报的首页列表，首页的结构有上下部分，上部分是图片滑动模块，用于展示热门日报，下部分是首页日报列表，以上接口返回的数据有热门日报和首页日报获取日报详细http://news-at.zhihu.com/api/4/news/{id}参数说明id日报id在点击日报列表也的日报项时，需要跳转到日报详情页展示日报的具体信息，这个接口用来获取日报的展示封面和具体内容。历史日报http://news.at.zhihu.com/api/4/news/before/{date}参数说明date年月日格式时间yyyyMMdd,例如：20150903、20161202这个接口也是用与首页列表的日报展示，但是不同的是此接口需要传一个日期参数，如20150804格式。获取最新日报接口只能获取当天的日报列表，如果需要获取前天或者更久之前的日报，则需要这个接口单独获取。日报额外信息http://news-at.zhihu.com/api/4/story-extra/{id}参数说明id日报id在日报详情页面中，不仅要展示日报的内容，好需要额外获取此日报的评论数目和推荐人数等额外信息。日报长评http://news-at.zhihu.com/api/4/story/{id}/long-comments参数说明id日报id日报的评论页面展示长评用到的接口（没有找到分页参数，分页没有做）日报短评http://news-at.zhihu.com/api/4/story/{id}/short-comments参数说明id日报id日报的评论页面展示段评用到的接口（没有找到分页参数，分页没有做）主题日报栏目列表http://news-at.zhihu.com/api/4/themes主页的侧边栏显示有主题日报的列表，需要通过这个接口获取主题日报栏目列表主题日报具体内容列表http://news-at.zhihu.com/api/4/theme/{themeId}参数说明themeId主题日报栏目id在主页侧栏点击主题日报进入主题日报的内容页，需要展示此主题日报下的日报列表。代码编写启动页作为一个仿制知乎日报的伪APP，高大上的启动封面是必须的，哈哈。启动页面很简单，请求一个应用启动封面接口，获取封面路径和版权信息。当进入页面，在onLoad事件中获取屏幕的宽和高来请求适合尺寸的图片，在onReady中请求加载图片，在请求成果之后，延迟2s进入首页，防止页面一闪而过。onLoad: function( options ) {\r\n    var _this = this;\r\n    wx.getSystemInfo( {\r\n      success: function( res ) {\r\n        _this.setData( {\r\n          screenHeight: res.windowHeight,\r\n          screenWidth: res.windowWidth,\r\n        });\r\n      }\r\n    });\r\n},\r\n\r\nonReady: function() {\r\n    var _this = this;\r\n    var size = this.data.screenWidth + '*' + this.data.screenHeight;\r\n    requests.getSplashCover( size, ( data ) => {\r\n      _this.setData( { splash: data });\r\n    }, null, () => {\r\n      toIndexPage.call(_this);\r\n    });\r\n}\r\n  \r\n/**\r\n * 跳转到首页\r\n */\r\nfunction toIndexPage() {\r\n  setTimeout( function() {\r\n    wx.redirectTo( {\r\n      url: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发之吐司toast(消息提示框) \n              精品教程《二》：微信小程序实战之小豆瓣图书 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程《二》：微信小程序实战之小豆瓣图书\n                                    \n                  • Rebecca Han：微信小程序仿知乎Demo实战教程（适用1028版本）\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 从零开始一个微信小程序版知乎\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSTN8DDV', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\nnode.js 抓取网页内容（针对微信小程序云开2018-10-22小程序的全栈开发新时代2018-10-31万字解析小程序（2）：如何保证大海上可以2018-10-22微信小程序：动画（Animation）2018-10-29微信小程序http连接访问解决方案2018-11-06megalo -- 网易考拉小程序解决方案2018-10-29微信小程序之物流状态时间轴2018-11-01微信小程序中的ios兼容性问题2018-11-01微信小程序·云开发初体验2018-11-12\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n清新小程序实战：和你的100个愿望清单（云2018-11-19小程序背景音乐2018-11-15小程序 - 上传图片(预览、上传(进度条)、删2018-11-07有没有同城小程序的！2018-11-06大学签到2018-10-27背单词小程序，小鸡单词，仿墨墨背单词2018-10-22微信小程序翻译demo12018-10-21开源分享，记账小程序demo2018-10-17微信小程序Demo:水浒卡2018-10-17\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1542709871|5574a3127ce31bff15e2482357be2f74|2';"}
{"title": "精品教程《二》：微信小程序实战之小豆瓣图书 ", "author": "天下雪", "pub_time": "2016-10-21 16:35", "article_content": "最近微信小程序被炒得很火热，本人也抱着试一试的态度下载了微信web开发者工具，开发工具比较简洁，功能相对比较少，个性化设置也没有。了解完开发工具之后，顺便看了一下小程序的官方开发文档，大概了解了小程序的开发流程和一些常用的API。了解了小程序之后，自己就有了想要做一个小demo的冲动，虽然自己对小程序还没有做过很多实践，只是在官方例子上徘徊，但是还是想做出点小东西。既然要做一个demo，自然需要到数据，自己有又不想独自搭建服务端，所以在网上搜索可以用来提供测试数据的免费api，最后我选择了豆瓣图书。豆瓣图书提供的api功能比较少，加上不开放appkey申请，所以无法操作用户数据。只能做点简单的图书查询和图书详细信息展示，这个demo只有两个页面，非常之简单。豆瓣图书APIdemo中用到的豆瓣图书api只有两个，一个是图书搜索，另一个是获取图书详情。搜索图书赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              精品教程：微信小程序实战之知乎日报 \n              有渔微信小程序系统进阶《四》小程序组件 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程：微信小程序实战之知乎日报\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 小程序之豆瓣电影源码解读\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSTN8DDV', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\nnode.js 抓取网页内容（针对微信小程序云开2018-10-22小程序的全栈开发新时代2018-10-31万字解析小程序（2）：如何保证大海上可以2018-10-22微信小程序：动画（Animation）2018-10-29微信小程序http连接访问解决方案2018-11-06megalo -- 网易考拉小程序解决方案2018-10-29微信小程序之物流状态时间轴2018-11-01微信小程序中的ios兼容性问题2018-11-01微信小程序·云开发初体验2018-11-12\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n清新小程序实战：和你的100个愿望清单（云2018-11-19小程序背景音乐2018-11-15小程序 - 上传图片(预览、上传(进度条)、删2018-11-07有没有同城小程序的！2018-11-06大学签到2018-10-27背单词小程序，小鸡单词，仿墨墨背单词2018-10-22微信小程序翻译demo12018-10-21开源分享，记账小程序demo2018-10-17微信小程序Demo:水浒卡2018-10-17\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1542709872|aadb66b8945aeeac224b23a03587bd54|2';"}
{"title": "零基础入门篇：微信小程序开发博客项目《中》 ", "author": "天下雪", "pub_time": "2016-10-18 22:31", "article_content": "1、添加一些图片素材（网上找的），复制到项目的根目录下面，和pages目录同级2、查看微信文档介绍3、打开blog文件夹，编辑blog.js，page函数里面添加对象，data对象表示数据，即和后台交互的数据都在这里面存储和展示，onLoad,onReady等函数是微信在页面加载时默认存在的函数，我们可以重写，实现我们自己的逻辑4、点击编译查看对应的效果，及函数加载顺序,onLoad、onShow 、onReady的加载顺序5、网络请求打开微信文档，里面有对应的网络请求api，wx.request（），接收一个对象，包含我们请求的各种参数（交互的域名正式环境有限制，而且需要为https）6、编辑blog.js，在onLoad函数里面发起网络请求，接口地址是我测试用的地址，会返回对应的数据列表，注意的地方是this指向问题，因为是在回调函数里面获取数据的，然后需要放到data对象里面，所以需要提前保存this对象的地址现在进入页面就可看到控制台打印接收到的数据了（数据请求也可以这样发送）[javascript] view plain copy//发起网络请求     wx.request({      url: app.globalData.blog_url+'/article/findHotArticles.action',      data:{          size:20      },      success: function(res) {        console.log(res.data);          //把获取到的结果放到数据层        that.setData({           list:res.data          })        }    })  7、ok，现在就是展示数据的时候了,打开微信微信官方文档，主要使用的是view标签，详情参考文档8、展示层代码，使用<block wx:for=\"{{list}}\"> 遍历文章对象，{{}} 取的是data数据层里面的数据绑定的下拉函数（不做处理）10、处理样式，view标签可以使用css3的样式，并且微信本身也提供一些计算尺寸的方法，也支持样式选择器，类选择器，id选择器，直接看代码，编辑我们的blog.wxss11、现在就可以保存，然后点击左侧的编译，就完成了列表展示已经可以见世人了，码字不容易，篇幅较长，请留意第三篇"}
{"title": "前端外行的微信小程序瞎折腾之旅 ", "author": "天下雪", "pub_time": "2016-10-18 22:48", "article_content": "前言惭愧，最近下班回家沉迷山口山了，前一阵子搞antlr语法转换，这一阵子搞微信小程序，一直拖着没写点啥，一步一步来吧，肯定都得总结点东西留给自己看的。新技术尝鲜我一直是一个Android客户端开发，前端经验只停留在w3cschool上面很基础的最初版本html,css,js学习，纯helloworld水准，就学了不到10分钟。所以这里也算是给客户端开发们打点气，新的东西阻碍的永远是你上手的动力，而不是这个东西的难易。顺带强调自己是前端外行，也是希望各位看官关于内容里如果有很多关于前端理解的偏差，帮我指正和修改。加了一些小程序开发群，发现很多常问的问题是：我想上手小程序，需要先学啥语言，先学习html css js吗？小程序是用js开发吗？那我是不是要去先学js？想上手学小程序，需要什么知识储备吗？我的看法是，我反正从来都不是这样学任何一个新东西的，我就一句话直接开干啊!遇到啥问题再具体查啥问题。这也跟个人接触新东西的习惯有关，反正我是完全不喜欢那种打算学个新东西（注意是’新’东西），然后就问一下有啥经典书籍么？先抱着一本16开，三四厘米厚的一本大厚书，（我习惯叫砖书，很厚很大砸人很疼），看个好几天一个礼拜的，然后还没上手。或者听到个新东西技术是html，然后美名其曰技术储备，俩仨礼拜略微看明白点html，css，但也毫无实战经验，俩仨礼拜，连小程序的边都没摸到。对于’新’东西，等系统化的出书，黄花菜都凉了啊，以前捣鼓RN的时候，无数人问RN有什么好书看，现在RN书停留的版本都是0.2X之前，并且一个个都很浅，现在0.3X已经天翻地覆了，这种啥都等系统化整理文章，做好技术储备，再开始动手，完全不是我的个人学习风格。直接上手是最快的，虽然资料少，但是有源码下，源码是最好的指导方案，没源码，官方文档，Github交流，网上及时阅读最新的碎片化博客文章，这些绝对是最快的学习和了解’新’东西的手段。光读光看是绝对没用的，最有效最有效的手段是，直接上手，上项目，哪怕是仿写一些开放API接口的app（知乎日报，豆瓣电影，有太多开放提供服务器api，让广大客户端开发者练手的）以上只是我的个人学习习惯，因人而异扯淡吐槽xx火了，客户端要完蛋，前端要火小程序会不会灭掉客户端开发明年培训机构大量前端要涌入了小程序也不一定就会火，客户端不可代替当初RN出来就是这样一波风气，小程序出来也是，我对任何这种话题是毫无兴趣！这种然并卵的话题，键盘侠们热火朝天讨论几个小时，时间就过去了，然后就可以happy下班了，有这功夫demo都写出来了，项目都上线了开发环境上面其实也扯了太多的废话，微信小程序其实有自己的IDE开发环境，一切都在这个开发环境里面，下载官方IDE开发包，开始运行，就可以直接开发预览小程序了。但这里有个IDE开发包破解的问题，小程序目前需要是需要邀请码的，有邀请码你就会有属于你业务的微信小程序appId，有邀请码的好处是你可以把小程序部署到真机上，没有邀请码，无论你是否破解了IDE，你都无法真机预览，但是IDE里面的模拟器预览完全没有问题，能运行，能实现绝大部分功能，完全可以项目上先开发起来，等待一旦公测，就直接上线。不破解IDE先说结论：现在的最新版本IDE，完全不需要破解！最新版本的92300的IDE，mac下是一个dmg包，直接安装就能使用选择+号添加项目你能看到创建新项目必须填写AppID在92300版本里面，已经贴心的新增了一个无AppID的按钮，点了后会得到提示无AppID部分功能受限说的很吓人，这部分API很少，就2个，并且IDE提供了模拟数据返回，完全不影响绝大部分开发你就是破解了，不提示部分功能受限，也是该没法正常还照样没法正常工作，毕竟微信也有自己的服务器验证，你破解后填的AppID终归是假的选择工程目录，这时候切记如果你是从0开始创建工程，而不是拥有线程的wx小程序demo代码，一定要在选择工程目录的时候，创建全新文件夹只有全新创建的文件夹才会开启quickstart自动创建初始工程文件功能，(如下图）自动创建好一个helloworld工程quickstart的自动创建工程，是可以无报错直接运行run起来的。但如果文件夹内有文件，IDE就不会创建任何的初始文件的。破解IDE首先，感谢@老郭以迅雷不及掩耳盗铃之神速第一时间破解了微信官方IDE，并且开源提供给大家使用，GitHub weapp-ide crack因为在早期的版本，微信的IDE，没有AppID的人是无法体验的，必须经过破解，才能开始自己写demo进行练手。而老郭在第一时间破解了IDE，让所有人能从代码上第一时间体验这个神秘的小程序（真机就没办法了）后来倒逼微信官方，把小程序IDE直接开放，才有了上面提到的无AppID模式。但是，我使用破解IDE的时候，发现很多人遇到了个问题，按部就班一步一步把IDE破解了，创建新工程的时候，是没有quickstart这一部的，如果什么都不太懂的人做到这一部，一打开工程，一个文件没有直接点运行，直接会报错，什么can not find app.js之类的，context之类的错误，我看到这个后，直接从网上顺手找个demo（就在老郭的Git里就有）扔到目录里，就一切运行了。所以目前我的感受就是，破解倒逼了微信官方开放无AppID体验，简直太威武了，但对于经验尚浅的新手，破解的一大堆东西和步骤，很可能会出现一大堆不知道为啥的错误提示的时候，真的不如直接下最新版IDE，不破解直接无AppID体验。开动起来官方文档全在这里 官方文档，里面包含简易教程，框架，组件，API，工具等等官方文档其实内容真的不多，很多东西写的很浅，光看文档我是觉得很是吃力，因为很多前端开发的概念并不深入，很多标签，css的名字及其陌生，所以辅助上别人的demo食用就很赞quickStart 工程文件基础项目基础文件app.json 这里对小程序所有的页面进行配置，其实详细的大家可以看官方文档，跟你app界面结构相关的就是前三个“pages”字段表示app包含的所有页面，只有在这里注册过的页面才会有效进行编译，如果你的app不包含”tab”字段，那么app的首页就是”pages”数组里面的第一个page“window”字段是处理对于navigationbar的一些样式设置“tabBar”字段如果存在，表示app开启首页面为底部tabbar的形式，这样每个tab所对应的page在”tabBar”字段里设置“networkTimeout”,”debug”这两个字段一个配置全局网络超时，一个开启debug模式app.wxss 这里其实是全局的CSS，凡是在这里写过的CSS样式，在各自子page里面可以直接使用，写在其他.wxss文件里的样式是不能跨page使用的，可以通过@import进行样式导入，导入别的.wxss文件，但是目前我实践的结果@import只有在主app.wxss里才有效，路径是相对路径app.js 这里就是纯js代码逻辑了，官方的demo里给你展示了一些基本代码，调用了微信的login接口，回调，读取用户头像，读本地存储之类的。并且通过js的一个全局函数getApp()可以获得app.js的这个app对象。页面文件如果一个页面起名叫HomePage，那么我们就应该自行手动创建3个文件，文件名一致才会被系统正确的识别HomePage.js 代表着这个页面的业务逻辑，当你在空白js里面输入page的时候会自动出现代码补全，帮你补全了一个page的所有生命周期，onLoad，onHide啥的，其他的js代码提示很不完善╮(╯_╰)╭HomePage.wxss 这里面写这个页面的专属css，别的页面不能使用，只在这个页面下可以用，但是可以被import到app.wxss里面，实现全局通用，并且wxss的代码提示非常完善，很爽，很多文档没写的css表，可以通过ide代码提示+推测标准css3，来知道如何编写HomePage.wxml 这里面写这个页面了，这种WXML语法看起来就很像html，但他还真不是html，html的东西完全不能直接在这里用。你必须用wx提供的wxml相关组件完全重写，条件渲染，循环渲染，数据绑定，都得按着微信的规定来，并且提供了最简单的模板模块功能，实现一定程度的复用。还可以有个可选的HomePage.json文件，页面也是可以拥有自己的.json文件进行一些专属配置的，但是页面的json可以配置的字段不如app.json多，职能配置关于本window相关的一些表现，比如上手开搞创建一个新目录HomePage，创建好我们页面自己的HomePage至少三个文件HomePage.js里面写page，自动补全好页面生命周期，其余留空修改app.json里面 “pages”字段，添加进去我们最新的页面路径，并且放到最上面。直接点编译，你会发现，你的微信小程序已经在模拟器里面运行起来了，没有报错，只是空白一片，什么也没有嘛。后面开始动手画UI了，这个我没有啥教学的，因为上文提供的github各种demo里面丰富多彩的所有组件用法已经够全的了，我这手把手的教如何写一个按钮，如何写一个text，如何水平排布好几段文字，这就有点太无脑了。我举例几个项目中用到的界面，然后写点我这个小白在趟出这些界面的时候遇到的一些问题点吧开发小记小程序的mvvm小程序天然有一套数据和UI的绑定机制，在js文件里有如下代码，在onload里面发起网络请求，网络请求后回来，handleResponse，再之后setData，可以看到这个data其实就是一个vm当任何时候在js逻辑里面，修改了data，这样的wxml中，这种就是告诉负责UI的WXML，这块UI要和bookList这个data里面的一个字段进行绑定，任何时候data发生了变化，这个UI都会根据最新的数据结果刷新小程序的代码复用&模块化可以看出来，我的2个页面，最重要的就是一个书籍详情Cell，进行复用，避免代码大量的机械性重复。模块化得从3个层面，js，wxss，wxml来说js的模块化：小程序的js看起来就是最普通的js，似乎看起来是不支持ES6的，因此用传统的module.exports就可以封装js的api模块提供外部使用wxss的样式导入：上文提过，每个page只能认自己page的wxss，和全局的app.wxss，其他的wxss是不支持由别的文件直接引入的，但是可以在全局app.wxss里面使用@import来把别的文件的样式，导入全局，这样各自page都能使用了wxml的模板：官方文档里说支持<template>的方式创建一个模板，模板支持使用data传入数据，我的项目里没这么使用过，我用的另一种方案wxml的引用：官方文档里也说明了支持<include>他的作用其实只是原封不动的代码字符串拷贝，会拷贝目标wxml文件里除<template>外所有的标签，原封不动的拷贝替换到<include>位置（这是纯字符串复制，不能支持指定代码灵活变化，需要灵活变化请使用模板）点击事件传值下面这个代码就是我的bookCell的wxml代码，可以看到这里大量使用了进行UI和data的绑定，这样每次setData，都会让ui直接生效，但我这里重点给大家看一下关于绑定点击事件。官方文档里面写的真是比较简单，bindtap=\"tapBook\"写好了这一句后，每当这个UI元素被点击的时候，都一定会触发对应page的.js文件中tapBook这个jsfunction，看起来很容易，但传值呢？发生点击我怎么知道点击的时候是哪个book被点击了？第几个本书？书的id是啥？关键就在这里data-sectionIndex=\"\" data-rowIndex=\"\"这一行给添加了2个属性，都是以data-开头，自定义的名字为结束，并且绑定上了2个数据（for 循环的index，for循环后面说），这样添加自定义的data-xx属性就是为点击事件传递属性的关键这是对应js代码，当触发tapBook的时候，会把event当做参数传入，event.currentTarget.dataset.xxx 就能获取你刚才data-xx绑定的数据，我刚才把sectionIndex rowIndex的列表点击index绑上了，于是通过这个方法取出来了。切记，你在wxml里几遍data-xx，写了大写英文字母，此处在js里调用的时候被自动全部变成小写了，你再写大写是undefine的for循环创建列表官方文档里面给了好几种for循环的方案，什么 ，都可以绑定上一个js数组数据，然后按着数组的个数循环渲染列表形UI，这就是一个for循环创建列表的例子wx:for的意思是告诉这个内用循环创建内容，循环所绑定的数组是listItem.column_list.book_infowx:for-item的意思是，你在下面写当次循环需要用到的具体数组元素，你起名成listBookItemwx:for-index的意思是，你在下面写档次循环需要用到的数组下表，你起名成了rowIndex循环内我include的代码，就是上文点击事件传值介绍的代码，这时候我们回过头去看<text class=\"novelBookTitleText\">[] </text><view class=\"novelBookDesc\" data-sectionIndex=\"\" data-rowIndex=\"\" bindtap=\"tapBook\" tapIndex=\"\">怎么样，用到listBookItem数据在绑定上了吧，用到rowIndex在点击事件了把，同理可知sectionIndex其实是另外一个我没展示的外层循环的wx:for-index定义。wx对象提供的API所谓API其实就是，在js文件里，微信也提供了很多native API，以wx.xxx开头，官方API文档，包括很多内容，我就不一一举例了，这里举例几个比较重要的分类网络http请求(最常用，各大demo都是通过wx.request()来做http请求)大文件上传下载websockt数据数据缓存，本地key-value式数据存储各种同步，异步，数据处理接口导航 页面之间各种跳转动画 绘图媒体设备 重力感应，系统信息，网络状态，罗盘等等微信支付微信登陆，用户信息可以看出，都是直接跟网络，跟设备，相关的信息。界面跳转我们在小程序mvvm里面已经看到了一段关于wx.request的演示，这里演示一下，界面之间跳转wx.nativateTo() 通过push动画打开新的页面wx.redirectTo() 当前页面重定向到新页面进行展示，不打开wx.navigatBack() 通过pop动画，弹出到上一级界面wx.nativateTo是有数量限制的，小程序界面栈层级不能超过5的，所以很多场景可以选择使用wx.redirectTo可以看到，界面跳转通过url跳转，而传值也通过url的方式传值，你传过去的值会直接写进onLoad生命周期函数的options参数里面，名字和你在url里面写的是一样的。CSS说实话，一直以来都在做客户端开发，这种css式的界面开发模式，实在是太陌生了，css式的思维，css式的嵌套，对一个新手来说有点痛苦。我的Github上面的小程序Demo 这里面的代码其实不多，基本上是我们项目的雏形，但最让我头疼的就是那些css，我整整写了一整天，才大约摸到一丢丢前端开发，css思维的方式方法这个我也没啥好说的，毕竟我是大大大大菜鸟，就是多写写就有感觉了。值得一提的是IDE对于WXSS文件里，css的代码补全非常赞，各种都能第一时间补全，对于我这个根本记不住那么多css名字的新手来说，这个实在是太好了。另外，完全支持- position: absolute和- position: relative的绝对坐标布局，也完全支持flexBox的弹性盒子布局，和我一起的小伙伴表示，基本上大部分的css都是直接可以用，我把线上项目迁移到wxss的时候也感觉到了，打开chrome的debug模式，照着线上wap站，原封不动的照着写css布局参数，基本上没有任何问题调试大家玩起来就知道了，微信小程序的调试模式，和chrome的debug模式一模一样，其实这个ide就是拿nw.js写的，里面是一套webkit，源码里面就有chrome的debug’tool的js代码哈哈底层实现探讨关于这个小程序底层是如何运作的，在刚出的第一天，就引来无数的遐想，wx独有的wxml wxss到底是拿什么做的？到底是不是h5?到底能不能做成native体验？无数人都在猜测。在最开始的时候，ide被破解，并且被证实ide是基于webkit做的，很多人猜微信在真机上就是webview啦（后面事实证明，目前也还真是）但我当时就觉得这其实说明不了啥，wx特别抽象出来的 wxml结构，就是想定义一个独立出来的独有抽象层，他虽然目前把这个抽象层（一种自己独有的vdom结构？我是前端新人，不一定对哈），最后又重新通过编译转成了html，最后交给webview来展现（辅助绑定上了一些native插件，比如wxapp里面的视频，tab，navi，input keyboard，map等等，都是通过addsubview的方式直接add到UI/WKwebview上的）但是这并不代表，这样的架构就是依赖在webkit，和webview的，完全独有的抽象中间层vdom，就是为了摆脱对webkit的依赖，未来可以很轻松的切换底层架构，直接切换成reactnative or weex 那样的vdom + native渲染的模式，这样就没了webview的依赖，（虽然现在选择的方案，是又绕路回到了html和webkit，但依赖和选择权已经牢牢攥在了自己手里）微信小程序开发人员回答渲染机制这篇文章看起来官方人员态度有点遮遮掩掩，含糊其辞，通篇都没直指要害-如何渲染，但我觉得解读一下，是这样的潜台词（开玩笑！莫喷：我们很高大上，我们抽象了很多东西，其实我们还是主要用webview渲染，辅助了很多native，就是不太好意思这么直白的说出来）但我特别认可微博上的这个回答"}
{"title": "完整微信小程序开发教程实例详解：微天气《上》 ", "author": "天下雪", "pub_time": "2016-10-19 10:04", "article_content": "这次带大家一起开发一个功能完整的微信小程序，希望能对大家有一些参考价值。这次咱们一起开发一个天气预报小程序，之所以选这个类型，有两个原因。 一是天气类的小程序整体复杂度比较低，适合我们说明问题。 另外，这种类型的应用也更加适合微信小程序生态的场景，我的理解这个生态不适宜开发过于复杂的应用。 所以选了则个类型。咱们首先来看看最终效果，有个感官的认识：这个是在我的调试器上面的最终运行效果，根据你当前的位置显示当前以及未来一周的天气情况。 对于小程序的使用场景，个人觉得比较适合。准备工作先给大家看了运行效果，建立一个感官认识。那么接下来，我们就可以开始了。首先在微信开发者工具里建立一个项目:接下来，项目创建窗口有一点说明下， 在 AppID 条目中， 如果你已经有了内测账号，就填写你的 AppID， 如果你还没有内测账号，点击旁边的无AppID就可以了(相信大多数同学是没有内测账号的，所以可以使用这个方法继续在本地调试)。关于小程序的基本流程，以及项目结构等，可以参看咱们之前的文章 不需内测账号，带你体验微信小程序完整开发过程。 基础部分咱们这里就不多赘述。项目结构整个项目的文件结构如下：大家可以看到，有一个 index 目录里面是主页。 app.js 是程序主入口， utils.js 是咱们的工具脚本，用于读取天气数据。 还有一个 bg.jpg 的图片文件，是小程序的背景图。这个项目的所有文件都在这里了，是不是挺简单的？ 项目的完整代大家可以在咱们的 Github 主页上查看https://github.com/swiftcafex/wechat-weather基本结构介绍完了， 接下来咱们可以开始 Coding 了。 对于这个天气程序来说， 首先要处理的一个事情就是天气数据的获取了。 那咱们就一步一步的来做。首先，我们需要获取当前的地理位置， 微信给我们提供了相应的接口， 我们在 util.js 中可以定义这样一个方法：function getLocation(callback) {    wx.getLocation({           success: function(res) {        \tcallback(true, res.latitude, res.longitude);        },        fail: function() {        \tcallback(false);        }    })}wx.getLocation 方法给我们返回一个我们当前位置的经纬度信息。 如果成功，我们将信息传回给 callback， 如果失败我们给 callback 传回 false。 注意，失败的情况在实际开发中是需要注意处理的。比如，如果一些用户没有开启定位权限，不处理失败的话，就有可能产生预期之外的情况了。获取到当前位置之后，我们还要获取什么呢？ 天气数据。 相关的 API 很多， 我们这个小程序用的是 darksky.net提供的天气 API。 它提供了一个很简单的 API 接口:function getWeatherByLocation(latitude, longitude, callback) {    var apiKey = \"你自己的Key\";    var apiURL = \"https://api.darksky.net/forecast/\" + apiKey + \"/\" + latitude + \",\" + longitude + \"?lang=zh&units=ca\";    wx.request({        url: apiURL,        success: function(res){            var weatherData = parseWeatherData(res.data);            getCityName(latitude, longitude, function(city){                weatherData.city = city;                callback(weatherData);            });                    }    });}getWeatherByLocation 这个方法依然写在 util.js 里面，它的逻辑也很简单，拼接出 darksky 的 API 的 URL，然后调用 wx.request 请求网络数据。 因为我们不需要用到 API 返回的所有数据， 只需要获得当天的天气，以及未来 7 天的预报即可。 所以这里还使用 parseWeatherData 方法取得我们需要的数据并重组成新的结果。 这个方法的定义如下：function parseWeatherData(data) {    var weather = {};    weather[\"current\"] = data.currently;    weather[\"daily\"] = data.daily;    return weather;}从上面的代码不难看出，我们只取得了原始结果集的 currently 和 daily 数据，然后重新返回。 为什么我们要这样取得部分数据呢，主要是因为这个接口的其他数据我们并不需要，所以就没必要再传给应用层了。 原始数据的格式给大家贴一下：优化数据格式大家可能注意到了，这个 API 给我们返回的数据中，有些数据的格式我们还需要继续处理一下。 比如 time 是用时间戳的形式给我们返回的，但我们需要将时间显示在 UI 上， 所以我们就需要进行一下格式转换。 另外 temperature 字段的格式也不是我们需要的。温度数据我们不需要显示到小数点之后，取整数就可以。定义几个格式化数据的方法：//将时间戳格式化为日期function formatDate(timestamp) {    var date = new Date(timestamp * 1000);    return date.getMonth()+1 + \"月\" + date.getDate() + \"日 \" + formatWeekday(timestamp);}//将时间戳格式化为时间function formatTime(timestamp) {    var date = new Date(timestamp * 1000);    return date.getHours() + \":\" + date.getMinutes();}//中文形式的每周日期function formatWeekday(timestamp) {    var date = new Date(timestamp * 1000);    var weekday = [\"周日\", \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\"];    var index = date.getDay();    return weekday[index];}这三个方法都是对日期进行格式化输出。具体功能代码里的注释已经说明了，不多赘述。 最后，我们把前面所有的方法整合起来，组成给应用层的接口：//加载天气数据function requestWeatherData(cb) {    getLocation(function(success, latitude, longitude){      //如果 GPS 信息获取不成功， 设置一个默认坐标      if(success == false) {          latitude = 39.90403;          longitude = 116.407526;      }                  //请求天气数据 API      getWeatherByLocation(latitude, longitude, function(weatherData){                         cb(weatherData);          });    });}请求原始数据，这里调用了 getLocation 请求当前位置， 在回调里面判断返回结果是否获取位置成功，如果不成功，设置一个默认位置。 这个判断在实际的产品中还是比较有用的。 位置获取不成功的情况还是比较多的。比如用户没有开启定位权限。紧接着，在里面又调用了 getWeatherByLocation 方法获取天气数据，然后将原始的天气数据返回。原始数据读取成功后， 我们再封装一层，将原始数据进行加工：function loadWeatherData(callback) {    requestWeatherData(function(data){      //对原始数据做一些修整， 然后输出给前端      var weatherData = {};      weatherData = data;            weatherData.current.formattedDate = formatDate(data.current.time);      weatherData.current.formattedTime = formatTime(data.current.time);      weatherData.current.temperature = parseInt(weatherData.current.temperature);      var wantedDaily = [];      for(var i = 1;i < weatherData.daily.data.length;i++) {        var wantedDailyItem = weatherData.daily.data[i];        var time = weatherData.daily.data[i].time;        wantedDailyItem[\"weekday\"] = formatWeekday(time);        wantedDailyItem[\"temperatureMin\"] = parseInt(weatherData.daily.data[i][\"temperatureMin\"])        wantedDailyItem[\"temperatureMax\"] = parseInt(weatherData.daily.data[i][\"temperatureMax\"])        wantedDaily.push(wantedDailyItem);      }            weatherData.daily.data = wantedDaily;      callback(weatherData);    });}这是最终输出给应用层的方法，它里面用了咱们刚才定义的几个数据格式化方法将返回的原始天气数据加工了一下。 最终传递给回调方法。最后我们将这个方法暴露给应用层：module.exports = {    loadWeatherData: loadWeatherData}这个语法和 nodejs 比较相似。 到此为止，咱们这个小程序的数据处理逻辑部分就开发完成了。 大家可以稍微消化一下， 下一篇会和大家一起处理应用层的逻辑。 如果你想查看完整的代码， 也可以进入 Github 主页下载：https://github.com/swiftcafex/wechat-weather。"}
{"title": "完整微信小程序开发教程实例详解：微天气《下》：应用层，UI层 ... ... ", "author": "天下雪", "pub_time": "2016-10-19 10:12", "article_content": "一：应用层在上一篇文章中，咱们把微天气的数据层的逻辑搭建完成了。这次我们来构建这个小程序的应用层。数据层开发完成，接下来我们就可以专注应用层的逻辑了。 我们这个小程序不需要修改 app.js 只保留它的默认代码即可：//app.jsApp({  onLaunch: function () {      },   globalData:{    userInfo:null  }})主要的应用层逻辑都在 index.js 这个页面上：//index.js//获取应用实例var util = require('../../util.js')Page({  data: {    weather: {}  },  onLoad: function () {    var that = this;    util.loadWeatherData(function(data){       that.setData({        weather: data      });    });      }})大体看一下， 也并不复杂。 首先使用 require 语句导入我们上一篇文章中定义的 util.js 文件。 这里面提供了获取天气数据的整个逻辑。然后 Page 对象中， data 数据层定义了天气数据的结构：data: {    weather: {}}在 onLoad 方法中， 使用 util 中的 loadWeatherData 方法获取天气数据并设置到 UI 上：onLoad: function () {\tvar that = this;\tutil.loadWeatherData(function(data){\t  that.setData({\t    weather: data\t  });\t});    }这个逻辑也不难理解，获取到数据后， 使用 setData 方法将它设置到数据层中。 注意，一定要用 setData 方法。 不能直接用这种属性赋值形式：that.data.weather = data这样虽然也能设置底层数据，但它不能更新 UI 层的显示。 这也是微信数据绑定机制的一个原理。 所以大家在操作数据绑定的时候，一定要注意这一点， 否则就会容易造成很麻烦的调试问题。到此为止， 小程序的应用逻辑部分就完成了。 怎么样，很简单吧。 对于应用层这块的逻辑，主要注意数据绑定和声明周期相关的内容即可。这两个地方比较容易产生非预期的结果。 其他地方和我们开发其他程序基本差不多。 关于应用层逻辑，咱们就聊到这里， 下篇再和大家聊聊 UI 层相关的内容。这样我们就可以对小程序的整个开发过程有一个了解了。二：UI 层那么咱们继续， 首先咱们来看一下 index.wxml, 这个页面中定义了 index 页面的 UI：<!--index.wxml--><!-- <view class=\"container\">    <view class=\"top\">    <view>{{weather.city}}</view>    <view>{{weather.current.formattedDate}}</view>    <view>{{weather.current.formattedTime}} 更新</view>  </view>  <view class=\"topRegion\">    <view id=\"temperature\" >{{weather.current.temperature}}℃</view>    <view id=\"summary\" >{{weather.current.summary}}</view>  </view>  <view class=\"summary\" >    <view>一周天气预报</view>    <view style=\"margin-top:20rpx\">{{weather.daily.summary}}</view>  </view>  <view class=\"daily\" >    <view class=\"daily_item\" wx:for=\"{{weather.daily.data}}\">      <view class=\"daily_weekday\" >{{item.weekday}}</view>      <view class=\"daily_temperature\" >{{item.temperatureMin}}-{{item.temperatureMax}}℃ </view>            <view class=\"daily_summary\" >{{item.summary}}</view>    </view>  </view></view> -->首页的所有 UI 内容就都在这里了， 大家是否还记得咱们这个小程序主界面的样子？ 贴出来再给大家回顾一下：这个界面就是上面那段代码生成的了。 接下来咱们逐一分解。 把上面的完整代码简化一下，咱们先来看看整个 UI 的结构：<!-- <view class=\"container\">    <view class=\"top\">  </view>  <view class=\"topRegion\">  </view>  <view class=\"summary\" >  </view>  <view class=\"daily\" >    </view>  </view></view>-->最外层是一个 class 为 container 的 View， 它的里面放了 4 个子 View， 分别为 top， topRegion，summary 和 daily。top 区域是我们最顶部的地方来看看 top 的完整定义：<!-- <view class=\"top\">\t<view>{{weather.city}}</view>\t<view>{{weather.current.formattedDate}}</view>\t<view>{{weather.current.formattedTime}} 更新</view></view> -->里面的 3 个子视图分别对应了要显示的几个数据条目， 并且用一对大括号来引用我们 index.js 中定义的 data 数据中的内容。 关于数据绑定的基本知识咱们在之前的文章中已经介绍过， 如果对数据绑定不熟悉的话还可以参看之前的内容~然后接下来就是 topRegion, 这个区域也很简单，显示我们当前地区的温度以及天气情况：<!-- <view class=\"topRegion\">   <view id=\"temperature\" >{{weather.current.temperature}}℃</view>   <view id=\"summary\" >{{weather.current.summary}}</view></view> -->还是简单的数据绑定， 体现在界面上就是这个区域：summary 区域的逻辑和前面两个分别不大， 就不多说了。 最后再来看一下 daily 部分， 这里面用到了一个循环语法：<!-- <view class=\"daily\" >\t<view class=\"daily_item\" wx:for=\"{{weather.daily.data}}\">\t  <view class=\"daily_weekday\" >{{item.weekday}}</view>\t  <view class=\"daily_temperature\" >{{item.temperatureMin}}-{{item.temperatureMax}}℃ </view>      \t  <view class=\"daily_summary\" >{{item.summary}}</view>\t</view></view>-->它的第一个子视图使用了 wx:for 这个语法。 这个标记相当于对传入它的属性进行一个循环遍历， 也就是 。 然后这个标签内部的子标签会根据集合的数量重复出现，如果要引用每次遍历到的元素， 可以使用 item， 比如我们这里的 和 等。这样，我们最终在界面看到的效果是一个循环遍历后的结果:到此为止， index.wxml 的内容咱们就都介绍完了。 但是单纯的只有这些还不能构成完整的 UI 界面。 还需要最后一个东西， 那就是 wxss，也就是样式表。 那么继续来看几个例子：.container {  height: 100%;  display: flex;  flex-direction: column;  box-sizing: border-box;  background-image: url(images/bg.jpg);  background-size: 100%;  padding: 20rpx;}这个是最外层 container 的样式，它除了可以使用传统的 css 样式， 还可以使用微信特有的一些样式， 比如 display: flex 和 flex-direction: column。 还要注意我们这里用到了一个新的单位 rpx。 这个也是微信自有的特性 - responsive pixel。 它相当于一个自适应尺寸，所有的屏幕宽度都是 750rpx， 我们只需要记得这个特性即可， 其他的微信小程序会根据具体的手机尺寸自行计算相对尺寸。这里我就捡两个重要的特点和大家介绍一下。 这个小程序完整的样式表比较繁琐。而且都是相似的内容， 就不跟大家过多讲解。 如果大家需要了解完整的内容， 还是可以到咱们的 Github 主页上面下载完整的项目https://github.com/swiftcafex/wechat-weather结尾到此为止，用了三篇文章跟大家介绍了一个小程序从构建到开发的完整过过程。 这个天气小程序逻辑并不复杂，但通过它大家应该可以对整个开发的过程有一个亲身的了解。"}
{"title": "微信小程序开发进阶篇：生命周期、数据绑定与模块化 ", "author": "天下雪", "pub_time": "2016-10-19 11:27", "article_content": "一：生命周期准备写一个小系列，帮大家梳理一下微信小程序整体的技术架构。 尽量做到用最短的篇幅说明问题，帮助大家快速了解这个平台。 这次就先说说小程序的生命周期。关于生命周期，这在很多开发生态周都会有，比如原生的 iOS 和 Android 开发中都有类似的概念。这次咱们就详细了解一下小程序的生命周期。以及两个核心概念 —— App 和 Page。App()App 函数是整个小程序的入口， 这在我们上篇文章中已经介绍了， 咱们再把代码贴出来回顾一遍：App({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },    getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  }})大体上就是这样了， 微信开发工具的默认项目中定义了 onLaunch 方法， 它就是一个生命周期方法。 除了这个方法之外， 还有另外两个生命周期方法， 这里给大家列出：onLaunch: 小程序初始化完成。onShow: 小程序显示，初始化完成后会调用， 从后台切换进来也会调用。onHide: 小程序隐藏，用户在微信中点后退按钮算隐藏， 用户按 Home 键切回桌面也算隐藏， 这时 onHide 方法都会被调用。这就是 App 目前开放的所有的生命周期方法了。根据你的小程序业务逻辑，使用这些生命周期方法即可。getApp()微信还给我们提供了 getApp 函数， 这是一个全局函数， 在任何地方调用这个函数都可以得到 App 的实例，供我们使用。 这样我们在需要使用 App 对象相关属性的时候，就可以引用到它了。PagePage 是小程序中另外一个重要的对象， 它表示小程序的每一个单独的页面。 它也包含生命周期。 它的方法如下：data: 表示页面的数据， 用于前端 UI 显示数据。onLoad: 页面加载完成。onReady: 页面渲染完成。onShow: 页面显示。onHide: 页面隐藏。onUnload: 页面卸载。Page 的基本结构如下：Page({  data: {    message: \"Hello world.\"  },  onLoad: function(options) {    // Do some initialize when page load.  },  onReady: function() {    // Do something when page ready.  },  onShow: function() {    // Do something when page show.  },  onHide: function() {    // Do something when page hide.  },  onUnload: function() {    // Do something when page close.  }})当前端页面需要显示数据的时候， 可以这样：<!-- <view>{{message}}</view> -->这里面的 message 就是引用的 Page 对象中，我们定义在 data 属性中的 key 所对应的内容了。 这样 Page 以及它的数据如何与前端显示绑定起来的流程咱们就明白了。接下来， 我们怎么处理前端 UI 上面的用户操作事件呢? 比如用户点击， 我们可以使用 bindtap 属性：<!-- <view bindtap=\"viewTapped\" >{{message}}</view> -->bindtap 属性指定了一个方法名，我们只需要在 Page 对象里面实现这个方法就可以处理用户的点击操作了：Page({  viewTapped: function() {    console.log('hello world.')  }})当然， Page 还提供了修改它内部数据的方法 —— setData， 我们可以在刚才这个点击事件中使用 setData 修改显示在前端中的文字：Page({  viewTapped: function() {    this.setData({      message: '你好， 世界'    });  }})二：数据绑定与模块化微信小程序的 UI 层如何与控制层交互， 以及怎么样响应用户操作事件， 这次咱们来聊聊。WXML微信小程序使用 WXML 文件作为 UI 视图。 WXML 其实就是 WeiXin Markup Language 的缩写。 是一种类似 XML 语法结构的 UI 定义方式。它可以进行数据绑定， 显示 Page 中相应的属性：<!-- <view> {{message}} </view> -->两对括号中的 message 对应 Page 中 data 属性中的 message：Page({  data: {    message: 'Hello World'  }})当然， 我们还可以进行循环显示， 这个语法可能会和大家平时使用过的模板语法不太相同：<!-- <view wx:for=\"{{array}}\"> {{item}} </view> -->wx:for 是微信定义的一个特殊属性， 其实相当于一个 for 循环， 重复显示 View 空间， 然后将数组中的每一个元素都遍历一遍， 下面是 array 在 Page 中的定义：Page({  data: {    array: [\"Swift\", \"Objctive-C\", \"Javascript\"]  }})上面 WXML 例子中的 代表我们 data 中的 array 数组， 而 表示的就是数组遍历中的每一个元素， 编译运行后的界面显示如下：除了 wx:for 这种循环遍历语法之外， 微信还提供了另外一种， wx:if, 大家从名称中应该就可以想到， 它是一个条件判断， 只有当条件判断成立， 才会显示这个 View。 除了 wx:if 之外， 还提供了了 wx:elif, wx:else<!-- <view wx:if=\"{{false}}\" >Hello Title</view><view wx:elif=\"{{false}}\" >Hello World</view><view wx:else >Hello Wechat</view>-->注意这三个属性的用法， wx:if 和 wx:elif 这两个属性后面需要跟随一个布尔表达式用于判断， 而 wx:else 后面不需要跟随任何表达式。 这三个属性的逻辑和我们平时开发中的 if else 判断逻辑完全一样，也比较好理解。关于 wx:else 微信官方的示例中是给他指定了表达式属性的。 但我在真实环境上测试了一下， wx:else 无论是否指定后面的属性值，最终的输出结果都是一样的， 所以这可能是官方示例的一个笔误。 按照 if 表达式正常的逻辑来看，应该不需要给它再设属性了。 大家可以留意一下。模板说完了循环和条件判断语法， WXML 还支持模板定义, 比如这样：<!-- <template name=\"hello\" >  <view>    Hello, {{name}}  </view></template><template is=\"hello\" data=\"{{...swift}}\" ></template><template is=\"hello\" data=\"{{...objc}}\" ></template>-->简单解释一下， 第一个 template 标签是模板定义， name 属性定义了它的名字，在两个标签之间是它的内部结构。 然后紧接着的后两个 template 标签是模板的引用， is 属性代表要引用哪个模板。 我们这里填入的都是 hello， 也就是我们最开始定义的这个模板结构。 然后就是 data 属性，通过它传入模板需要的相关数据。 先来开一下 swift 和 objc 这两个数据的定义：Page({  data: {        swift: { name: \"Swift\"},     objc: { name: \"Objective-C\"}  }})swift 和 objc 都是两个 JSON 对象， 都包含一个 name 属性。 大家注意看我们前面模板引用 data 属性的方式：<!-- <template is=\"hello\" data=\"{{...swift}}\" ></template> -->这里我们在一对大括号中的变量名前面还写了三个点 —— …… 其实是一个操作符， 用于将 swift 变量内部的值 “展开”， 这么说可能不太好理解， 咱们还回到模板的定义中：<!-- <template name=\"hello\" >  <view>    Hello, {{name}}  </view></template>-->我们看到， template 内部使用 来引用我们传入对象的属性。 这就需要我们 “展开” 传入的对象， 才能让模板找到对应 key 的值。 简单来说， 如果我们不适用 … 这个操作符，而是直接像这样传入对象：<!-- <template is=\"hello\" data=\"{{swift}}\" ></template> -->如果这样运行程序的话， 模板是不能正确读取到 name 属性的。模板的引用当然， 我们可以不用把模板的定义和引用它的代码写到一起， 我们可以把模板的定义单独写在一个 WXML 文件中， 然后在另外一个文件中使用 import 来引入它。 这也是一个结构良好的项目的通常做法。 比如我们刚才的模板存放到 hello.wxml 中， 我们就可以这样引用它：<!--<import src=\"hello.wxml\" /><template is=\"hello\" data=\"{{...swift}}\" ></template><template is=\"hello\" data=\"{{...objc}}\" ></template>-->这样我们可以比较好的进行模块划分。 当然， 除了 import 之外， 微信还给我们提供了另外一种引用方式， include。 简而言之， 他们之间的区别是这样， import 只能引入目标文件中的 template 定义， 不会引入具体的 UI 内容。 而 include 正好相反， 它只会引入目标文件中的内容，不会引入 template 定义, 比如我们有一个文件，叫做 header.wxml：<!-- <view>Header Title</view>-->然后我们在 index.wxml 中这样引用：<!--<include src=\"header.wxml\" /><view>Hello world!</view>-->这样就会引入 header.wxml 中定义的内容了， 最后的输出结果就是他们两个文件中所有 UI 组件的整合了。 这就是 import 和 include 的区别了。"}
{"title": "IOS开发者试水：微信小程序开发教程-从零开始（1） ", "author": "天下雪", "pub_time": "2016-10-19 12:12", "article_content": "前言微信小程序暂时处于内测期间，公司大的版本刚好上线了，闲来无事，看看微信小程序的文档，顺便学习学习，在此希望和大家一起共勉，发现自己越来越懒惰了，越活越没上进心了，有点危险，给自己敲下警钟吧。废话不多说，开始记录下这些天学习到的一些知识，希望对正在阅读的你有所帮助！ 本文为iOS开发者Bison自学微信小程序所写，所以很多东西都和iOS进行了一下对比。开搞创建项目在此滤过，相信大家看着官方文档就可以搞定首先我们先把整个app的架构搭起来一般市面上的app都已tabbar展示的方式为主，今天我就仿原生的IT Blog下面让我们看下IT blog长什么样吧！首先是TABBAR下面我将简单的介绍一下微信小程序一些不可缺的目录结构。 下面借用官方的解释WXSS(WEIXIN STYLE SHEETS)是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。为了适应广大的前端开发者，我们的 WXSS 具有 CSS 大部分特性。 同时为了更适合开发微信小程序，我们对 CSS 进行了扩充以及修改。APP.JSON 文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 TAB 等。文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。相当于iOS开发中的AppDelegateAPP.JS 是小程序逻辑部分根据上面的目录结构的解释不难看出，我们的tabbar是写在哪的，没错就是app.json，下面让我们看下代码{\r\n  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ],\r\n  \"window\":{\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\":\"black\"\r\n  },\r\n  \"tabBar\": {\r\n    \"backgroundColor\":\"#000000\",\r\n    \"list\": [{\r\n      \"iconPath\":\"image/icon_API.png\",\r\n      \"selectedIconPath\":\"image/icon_API_HL.png\",\r\n      \"pagePath\": \"pages/index/index\",\r\n      \"text\": \"首页\"\r\n    }, {\r\n      \"iconPath\":\"image/icon_component.png\",\r\n      \"selectedIconPath\":\"image/icon_component_HL.png\",\r\n      \"pagePath\": \"pages/about/about\",\r\n      \"text\": \"我的\"\r\n    }]\r\n  }\r\n}上图框出来的地方就是我们的tabbar，tabbar里面可以传一个数组list，想显示多少个tab就到这里加就行，当然个数是有限制的最多5个，一个的话就没必要了。这点和iOS开发里面颇为相似。 下面我们按下com + s 再 编译一下，就可以看到如下结果了iconPath为默认图片路径，selectedIconPath为点击时的图片路径，text的话我想不说大家也已经猜到了，对，没错就是图片下面显示的title了。我们这暂时只写了俩个Tab，在此主要也就是实现我们的首页效果。 由我们的效果图可以看出，iOS开发中我们的布局主要用的是tabview，而在微信小程序中类似tabviewCell的布局又是怎么写的呢？下面我们先写贴下代码再做下解说。<!--文章列表模板 begin-->\r\n<template name=\"itmes\">\r\n     <view class=\"imgs\"><image src=\"\" class=\"in-img\" background-size=\"cover\" model=\"scaleToFill\"></image></view>\r\n    <view class=\"infos\">\r\n      <view class=\"title\"></view>\r\n      <view class=\"date\"></view>\r\n       <view class=\"classification\"></view>\r\n    </view>\r\n</template>\r\n<!--文章列表模板 begin-->在这段代码中<template name=\"items\">…</template>是微信小程序中的模板，那什么是模板呢？官方文档是这样解释的。模板WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。我的理解这个相当于iOS开发中的cell，cell有了的话， 那就只缺少一个数据源了，下面我们暂时做一个本地的数据源。数据主要是写在js代码当中的，下面来看下代码//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    newList:[{url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"ss\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdassss\",classification:\"ss\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"12\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"333\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"44\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"44\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"32\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"123\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"456\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"},\r\n             {url:\"baidu.com\",title:\"sdsadsadasdas\",classification:\"454\",time:\"2016-10-17\",imgURL:\"../../image/wechatHL.png\"}\r\n    ]\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function() {\r\n    wx.navigateTo({\r\n      url: '../logs/logs'\r\n    })\r\n  }\r\n\r\n})其中的newList为我们的数据源,数组里面包含多个字典，字典里面有我们所需要的5个字段。 cell 和数据源都有了，那就只差一个显示了， 显示在微信小程序当中用的是列表渲染列表渲染在组件上使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item下面我们来看看这个列表渲染是怎么做的,首先切换到index.wxml中，代码如下。<!--循环渲染列表 begin-->\r\n<block wx:for=\"\">\r\n  <template is=\"itmes\" data=\"\" />\r\n</block>\r\n<!--循环渲染列表 end-->com + s 再 编译一下可以看到如下的效果到此微信小程序的列表功能已经做完了，当然我们看到的布局都是很乱的，下一篇我们将优化UI让他和我们的效果图一样。"}
{"title": "IOS开发者试水：微信小程序开发教程-从零开始（2） ", "author": "天下雪", "pub_time": "2016-10-19 13:49", "article_content": "这篇文章我将讲解列表的点击以及UI的优化，达到一个我们预期的一种效果。首先我们创建一个详情的界面所需的文件,如下图所示:详情页的话，我们暂时随便搭建一下，主要是看下怎么做跳转。首先我们在详情页面随便写点东西，代码如下：<!--detail.wxml-->\r\n<view class=\"container\">\r\n666666\r\n</view>这样的话在外面的详情页会显示666666这些个字样，然后我们在index.wxml中写跳转的代码，主要代码如下：<navigator url=\"navigate?title=navigate\" hover-class=\"navigator-hover\">\r\n跳转到新页面\r\n</navigator>其中url为应用内的跳转链接title=navigate为传过去的字段hover-class指定点击时的样式类，当hover-class=”none”时，没有点击态效果.完整的代码如下图框起来的地方运行一下，可以瞧瞧效果如下。由图可以看出跳转的功能已经做好了，下面我们开始优化一下首页的UI 优化UI 的话主要是在index.wxss中，根据每个控件的class名来写相应的设置。 首先我们把整个页面做一下设置，代码如下：/**index.wxss**/\r\n.list {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 20rpx;\r\n}padding为内边框，首页整个的class名为list，所以用.list{}来设置。然后设置一下navigator块，再然后来设置我们的每一个列表，在这里我把它命名为cell，看上去对于iOS开发来说亲切一点。具体代码如下：navigator{ overflow: hidden;}\r\n\r\n.cell{\r\n  margin-bottom:  20rpx;\r\n  height: 200rpx;\r\n  position: relative;\r\n}再然后我们设置cell中图片的位置，具体代码如下：.imgs{\r\n  float: right;\r\n}\r\n.imgs image { \r\n  display: block;\r\n  width: 200rpx;\r\n  height: 200rpx;\r\n}由代码可以看出，我们的图片设置了向右对齐，宽和高分别设置了200rpx，我们运行一下看看效果图片是否已经改变了。相对于我们的效果图的图片部分，应该已经差不多就是这个样子了，下面让我们再调一调标题以及其他部分UI 的调试。 我们把其他部分的UI都放在class=”infos”; 首先我们先调这一大块的布局，代码如下：.infos {\r\n  float: left; \r\n  width: 480rpx;\r\n  height: 200rpx;\r\n  padding: 20rpx 0 0 20rpx;\r\n}然后设置里面的每一个小部件，代码如下：.title {font-size: 20px;}\r\n\r\n.date {\r\n  padding-top: 50rpx;\r\n  float: right;\r\n  font-size: 16px;\r\n  color: #aaa;\r\n  position: relative;\r\n\r\n}\r\n.classification{\r\n  padding-top: 50rpx;\r\n  font-size: 16px;\r\n  color: #aaa;\r\n  position: relative;\r\n}最后我们运行一下看下结果如何："}
{"title": "IOS开发者试水：微信小程序开发教程-从零开始（3） ", "author": "天下雪", "pub_time": "2016-10-19 13:56", "article_content": "这篇文章我将讲解列表的网络请求以及网络数据的对接。首先找到我们的index.js文件，然后看看微信小程序的网络请求文档很轻松的就可以找到我们的示例代码：wx.request({\r\n  url: 'test.php',\r\n  data: {\r\n     x: '' ,\r\n     y: ''\r\n  },\r\n  header: {\r\n      'Content-Type': 'application/json'\r\n  },\r\n  success: function(res) {\r\n    console.log(res.data)\r\n  }\r\n})url为我们需要请求的接口data为我们的请求参数header为设置请求的 header , header 中不能设置 Referersuccess收到开发者服务成功返回的回调函数，res = {data: ‘开发者服务器返回的内容’}console.log( res.data )为打印请求下来的数据默认为get请求，在此我们就用默认的请求方式，具体的代码如下：onLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    wx.request( {\r\n      url: 'http://sep9.cn/qt5wix',\r\n      data: {},\r\n      header: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function( res ) {\r\n        console.log( res.data )\r\n      }\r\n    })\r\n  }运行一下看看我们的请求是否有数据，结果如下图：可以看出我们的数据请求已经是成功的，是不是非常的简单啊？下面我们再来看看怎么给相应的UI赋值吧。首先在我们网络成功的地方加上以下代码: ``` success: function( res ) { console.log( res.data ) that.setData( {      })\r\n  } ```\r\nthat.setData( { })这个方法主要是用来赋值的然后我们得到的数据为res.data通过打印我们可以看出我们的数据结构和原来写死的数据结构是一样的，但是里面的字段确不一样，因此，我们需要把请求下来的值赋值给我们原来的数据源，然后把原有的数据源的字段改成网络请求下来的字段最终的代码如下： ``` //index.js //获取应用实例 var app = getApp() Page({ data: { newList:[] }, //事件处理函数 bindViewTap: function() { wx.navigateTo({ url: ‘../logs/logs’ }) }, onLoad: function () { console.log(‘onLoad’) var that = this wx.request( { url: ‘http://sep9.cn/qt5wix’, data: {}, header: { ‘Content-Type’: ‘application/json’ }, success: function( res ) { console.log( res.data ) that.setData( { newList: res.data }) } }) }}) ```再把index.wxml中赋值的字段改成服务器返回相应的字段，运行结果如下图：不知道什么原因，我这接口返回的图片url在微信小程序中无法显示，为了让效果更加的接近我们的效果图，在本地给我们的数据源加了些网络上的图片，代码如下：\r\ndata: {\r\n    newList:[{fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://a.hiphotos.baidu.com/image/pic/item/c8ea15ce36d3d539be4d77b83f87e950352ab05c.jpg\"} , \r\n             {fistImg:\"http://h.hiphotos.baidu.com/image/pic/item/8d5494eef01f3a2922e765c99b25bc315c607c8d.jpg\"} ,\r\n             {fistImg:\"http://c.hiphotos.baidu.com/image/pic/item/3b292df5e0fe9925ae23d95736a85edf8db1718d.jpg\"} ,\r\n             {fistImg:\"http://g.hiphotos.baidu.com/image/pic/item/faedab64034f78f099a529f47b310a55b3191c0e.jpg\"} ,\r\n             {fistImg:\"http://g.hiphotos.baidu.com/image/pic/item/bd315c6034a85edf9ba34e244b540923dd54758d.jpg\"} ,\r\n             {fistImg:\"http://f.hiphotos.baidu.com/image/pic/item/00e93901213fb80e0ee553d034d12f2eb9389484.jpg\"} ,\r\n             {fistImg:\"http://img1.imgtn.bdimg.com/it/u=2955244448,132069077&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://image.tianjimedia.com/uploadImages/2014/127/32/VP974HZ0AXL2.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} \r\n    ]\r\n  }\r\n\r\n随便弄几张图了，看看效果如何，本来还想做下详情页的，由于接口的详情是H5 ,貌似微信小程序不能直接加载H5，如有知道的朋友也可以给我留言告诉我，本人对于H5也是一窍不通。demo下载"}
{"title": "微信小程序开发常见问题分析 ", "author": "天下雪", "pub_time": "2016-10-19 14:43", "article_content": "距离微信小程序内测版发布已经有十几天的时间了，网上对微信小程序的讨论也异常火爆，从发布到现在微信小程序一直占领着各种技术论坛的头条，当然各种平台也对微信小程序有新闻报道，毕竟腾讯在国内影响力还是很大的。我们都知道微信小程序第一天发布内测版，并没有公开官方开发文档和开发工具，但是这阻止不了技术人的好奇心。因为自己对小程序也是很有兴趣的，感觉是很有意思的一个东西，所以立马做了一下小demo，水平有限，所以做的过程也就是一个学习的过程，一个提高的过程。这篇文章主要写我在写demo的过程中遇到的一些问题。如果阅读此文的你有一定帮助，很是欣慰。一：项目结构微信小程序项目结构主要有四个文件类型,如下WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，js 逻辑处理，网络请求json 小程序设置，如页面注册，页面标题及tabBar。注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。在根目录下用app来命名的这四中类型的文件，就是程序入口文件。app.json必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。app.js必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。app.wxss全局配置的样式文件，项目非必须。知道小程序基本文件结构，就可以开始研究官方demo了，研究过程中如果有不明白的地方可以去官方文档寻求答案，如果找不到答案或者有疑问，可再此博客留言，相互交流。下面介绍下出现概率较高的几个问题。二：常见问题rpx（responsive pixel）微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。这个项目我用的都是rpx尺寸单位，期间遇到一个很奇葩的问题。在相邻的两条信息直接都会有一个分割线，我将线的高度都设置成1rpx,但是不有个别分割线是不显示的，如下图看到没在第一条和第二条直接并没有现实这条线，但是其他的都展示了，分割线的属性是一样的，而且在不同的手机上（分辨率不同）不显示的分割线也是不同的，有的分辨率好几条分割线都不显示，不知道这是模拟器的bug还是rpx的bug。最后分割线的高度尺寸单位使用了px,解决了这个问题。40013错误在微信小程序刚出来的时候如果输入AppID提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，如下图，我们之间选择无AppID，即可解决此错误。建议安装官方开发工具。可去此处找下载链接。4058错误微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。Page注册错误这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯.Page route错误字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用组件，一种是调 wx.navigateTo。如下代码：wxml文件：搜索js文件事件处理函数：bindtap:function(event){wx.navigateTo({url: “search/search”})}如果你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码<navigator url=\"search/search\">\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\n</navigator>\r\n这种也是不允许的，也就是说组件内部不能再嵌套组件。它只能是单层存在的。Do not have * handler in current page.大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。bindtap:function(event){\r\n  wx.navigateTo({\r\n    url: \"search/search\"\r\n  })\r\n},\r\ntabBar设置不显示对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种注册页面即将页面写到app.json的pages字段中，如\"pages\":[\r\n   \"pages/message/message\",\r\n   \"pages/contact/contact\",\r\n   \"pages/dynamic/dynamic\",\r\n    \"pages/dynamic/music/music\",\r\n   \"pages/index/index\",\r\n   \"pages/logs/logs\"\r\n ]\r\ntabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。tabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册tabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是”pages”中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会电视tabBar了。tabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。navigationBarTitle显示问题通过这个动态图你应该发现问题了，当点击音乐进入音乐界面时，title先显示了WeChatForQQ然后显示的音乐，这个体验肯定是难以接受的，原因是音乐界面的title是在js文件中page的生命周期方法中设置的。若你不了解生命周期，可以点击查看Page({data:{// text:”这是一个页面”},onLoad:function(options){// 页面初始化 options为页面跳转所带来的参数  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //NavigationBarTitle如果此处和json文件都设置，最后展示此处的标题栏\r\nwx.setNavigationBarTitle({\r\n  title: '音乐'\r\n})\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})\r\n通过注释你应该明白了，设置标题写在了onReady方法中，也就是页面已经渲染完成了，在onReady之前显示的title就是json文件（覆盖关系，如果在子页面json文件设置title会覆盖app.json全局设置）中的title。可能你会说将wx.setNavigationBarTitle写在onLoad函数中，不过如果这样设置是不对的，因为onLoad执行过后才渲染页面，在渲染页面时title会从json文件中读取，导致onLoad设置的title会只在页面渲染之前展示，之后就显示json文件的tile，所以现在你应该明白ttle设置最优的地方就是给子文件写一个json文件，在文件中写入，如果想改变颜色直接在文件中添加就可以，该文件所写的属性值会覆盖app.json中设置的值。{“navigationBarTitleText”: “音乐”}wx.navigateTo无法打开页面一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo本地资源无法通过 css 获取background-image：可以使用网络图片，或者 base64，或者使用标签页面间数据传递微信小程序路由（页面跳转）是通过API wx.navigateTo或者wxml中组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在”?”后面，多个参数直接用”&”符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。<navigator url=\"/pages/dynamic/dynamic?title={{item.title}}&message={{item.message}}\">\r\n         <view class=\"item\" >\r\n            <view class=\"item-left\">\r\n                 <image src=\"{{item.url}}\" class=\"image\"/>\r\n            </view>\r\n            <view class=\"item-middle\">\r\n                 <view>\r\n                      <text class=\"title\">{{item.title}}</text>\r\n                 </view>\r\n                 <view>\r\n                     <text class=\"message\">{{item.message}}</text>\r\n                 </view>\r\n           </view>\r\n           <view class=\"item_right\">\r\n               <view><text class=\"time\">{{item.time}}</text></view>\r\n               <view class=\"mark\" wx:if=\"{{item.count>0}}\"><text class=\"text\">{{item.count}}</text></view>\r\n           </view>\r\n        </view>\r\n        <view  class=\"line\"></view>\r\n      </navigator>\r\n而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下/**  作者：dushao\r\n *   新浪微博：http://weibo.com/dushaoxiaoxiao\r\n *   博客  :    http://www.takozhang.cn\r\n * */\r\n * \r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    isHiddenToast:true\r\n  }\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    console.log(options.title)\r\n     console.log(options.message)\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  },\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"/pages/message/search/search\"\r\n})\r\n  },\r\n})\r\n这样就实现了页面间数据传递功能。"}
{"title": "微信小程序官方文档个人分析心得 ", "author": "天下雪", "pub_time": "2016-10-19 15:20", "article_content": "首先从官方文档给的框架说起,微信小程序官方文档给出了app.js, app.json, app.wxss. 先从这三个文件说起.  - app.js 这个文件是整个小程序的入口文件,开发者的逻辑代码在这里面实现,同时在这个文件夹里面可以定义全局变量. - app.json 这个文件可以对小程序进行全局配置,决定页面文件的路径,窗口表现,设置网络超时时间,设置多tab等. - app.wxss 是小程序的公共样式表.(为了适应广大的前端开发者，我们的 WXSS 具有 CSS 大部分特性。 同时为了更适合开发微信小程序，我们对 CSS 进行了扩充以及修改。)接着我们就结合官方给出的代码具体说一下上面提到的三个文件.首先说的是配置文件app.json.下面是官方给出的例子.{\"pages\": [ \"pages/index/index\", \"pages/logs/index\" ],\"window\": { \"navigationBarTitleText\": \"Demo\" },\"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\" }, { \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" }] }, \"networkTimeout\": { \"request\": 10000, \"downloadFile\": 10000 },\"debug\": true}官方给出了app.json五个配置项列表.(pages(Array), window(Object), tabBar(Object), networkTimeout(Object), debug(Boolean)),接着我们就详细的分下一下这几个配置项.pages它的作用是配置小程序的页面,这个配置项是必填的,它接受一个数组,里面的每一项都是字符串,从上面给出的代码: \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ] 可以看出,每一项分别对应的都是实现文件的路径以及他的文件名. 注意:这个配置里面的第一行配置是它的初始页面,例如上面代码的初始页面就是indexwindow这个配置项是用来设置小程序的状态栏、导航条、标题、窗口背景色。他给出了六个属性(navigationBarBackgroundColor(HexColor), navigationBarTextStyle(String-(black,white)), navigationBarTitleText(String), backgroundColor(HexColor), backgroundTextStyle(String-(dark,light)), enablePullDownRefresh(Boolean)),开发者可以根据自己的需求来进行配置.我们详细说一下这几个属性分别的功能: navigationBarBackgroundColor 它是用来设置导航栏背景颜色,这个属性要输入的是十六进制颜色值.navigationBarTextStyle 它是用来导航栏标题颜色的,它的输入类型是字符串(String),但是现在官网给出的文档目前仅支持(black和white)这两种颜色. navigationBarTitleText 这个属性是显示导航栏标题内容的,开发者可以根据自己的需要来进行设置. - backgroundColor 这个属性是设置窗口的背景色的,它需要输入的也是十六进制颜色值的. backgroundTextStyle 这个属性我的理解是设置窗口内容的样式的,官方给出的标准说明是下拉背景字体、loading 图的样式,这个属性同navigationBarTextStyle属性一样目前仅支持两种颜色(dark和light). enablePullDownRefresh 这个属性是设置是否开启下拉刷新,默认是开启的,注意: 在这个配置文件(app.json)中如果关闭了下拉刷新,当你在你自己开发的页面中想要设置下拉刷新也是行不通的,也就是说如果你想要在以后页面中使用下拉刷新这个功能,就必须保证这个配置文件中的这一项设置是打开的.上面给出的示例代码:{\"window\":{ \"navigationBarBackgroundColor\": \"#ffffff\",           \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\",\"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\"          }}显示出来的效果是这样的:tabBar这个配置项是用来配置页面底部的tab栏的,开发者可以根据自己的需求来进行配置.注意: tabBar是一个数组,只能配置最少2个,最多5个,而且tab栏的顺序是按照数组的排序来的.tabBar官方给出了一下五个属性(color(HexColor), selectedColor(HexColor), backgroundColor(HexColor), borderStyle(String), list(Array) ).接下来说说我对这五个属性的理解: color 设置tab上的文字默认颜色 selectedColor 设置tab上的文字选中的颜色 backgroundColor 设置tab的背景颜色 borderStyle 设置边框的颜色,现在仅支持(black和white)上面这四个属性就是按照官方给出的API来设置就可以,下面说一下list属性.list属性接受的是一个数组(Array),在list下面配置的每一项都是一个对象,他们都有以下这四个属性(pagePath(String), text(String), iconPath( String), selectedIconPath(String)).pagePath 这个定义的是页面的路径,但是这个属性定义的路径必须是在pages上定义过的.text 设置的是按钮上的文字iconPath 是定义icon图片的路径,这个属性定义的图片大小不超过40kb selectedIconPath 定义的是当选中按钮之后显示的图片,同样图片的大小不能超过40kb.下面是官方给出的效果图:networkTimeout它是用来设置各种网络请求的超时时间的,单位是毫秒,官方给出了四个属性(request, connectSocket, uploadFile, downloadFile)这四个属性分别定义的是wx.request, wx.connectSocket, wx.uploadFile, downloadFile 这四个API的超时时间.debug如果在app.json将debug配置为true,那么在开发者工具的控制台面板中可以输出详细的调试信息.以上就是根据官方给出的文档,我学习之后对app.json配置一些心得,下面我们在看一下app.js 这个文件.可以看到app.js这个文件的后缀是js,没错,微信小程序的开发框架在逻辑层用的语言就是JavaScript.但是微信小程序也在JavaScript的基础上做了一个修改,可以称之为一个新的轮子.这个框架可以使开发者更加方便的调用一些微信的功能,例如扫一扫,微信支付等一些微信特有的功能.我们接着回到app.js这个文件中来,其他的稍后再说.这个文件是整个小程序的入口文件,也可以说是控制整个小程序生命周期的文件,那么我们就不难想象,我们在这个文件中应该实现的几个功能,首先我们肯定需要对整个程序进行注册,正好微信给我们提供了一个app()来实现对整个程序的注册,同时app()里面还实现了对小程序生命周期的监控函数(onLaunch, onShow, onHide), 其中onLaunch是监听小程序初始化,当初始化完成时会触发onLaunch,当然这个函数是全局只触发一次.onShow是监听小程序的显示,在小程序启动时候,或者当你从后台进入到前台的时候就会触发这个函数.而onHide函数是监听小程序的隐藏的,当你从前台切换到后台的时候,会触发onHide.有了这些一个小程序的实例基本上算是完成了,当然为了让开发者加入更多自己的逻辑,微信还提供了让开发者在app()中加入自己的逻辑,开发者可以可以添加任意的函数或数据到 Object 参数中，用 this 可以访问.注意:app()只能定义在app.js中,而且不能注册多个.当在app.js中注册了实例之后,如果你想在自己的逻辑页面调用它,你可以用getApp()这个全局函数,这样你就可以全局调用app()里面的数据.微信给出的官方代码如下:var appInstance = getApp()console.log(appInstance.globalData) // I am global data注意:getApp()获取里实例之后,不要私自调用生命周期函数. 而且不要在app.js中用getApp()函数,用this就可以调用app()里面的东西. 基本上app.js就这些东西,还有一些API里面的内容会在后面一一介绍.下面我们就看一下app.wxss这个文件,一般来说做过网站开发的(我自己是用php来开发的,这是我个人的一点拙见,如有不对请见谅)相信对css写在单独的文件中应该不会陌生,这个app.wxss也是类似的,不过他的的配置是针对全局的,也就是说如果你在后面的page中没有重新配置他,那么他就会调用这个文件中的样式设置,但是如果你有个人需求,需要在每个页面重新写样式,那也没关系,他会自动覆盖宰割文件中的样式. 当你重新创建一个微信小程序他就会出现这几个文件,以上是我结合官方文档对他们的一些理解,接下来就是page的逻辑,视图,配置的一些心得.page这一块就是开发者自己的业务实现文件了. 每一个页面可以放在一个文件夹中,这个文件夹中一般包括.js, .json, .wxml, .wxss 这四个文件,微信官方还建议这四个文件的名字最好和文件夹的名字一致.这个便于框架自动查找,不需要做更多的配置. 当你开始做页面的功能的时候这个时候在.js,也需要注册,微信官方给出Page()这个函数来注册一个页面,他接受一个object参数,用其来指定页面的初始数据,生命周期函数,事件处理函数.需要注意的是当你在注册这个页面的时候要确定在最开始的app.json这个配置文件中已经配置过这个页面,而且当你对程序有所改变的时候也要确保app.json这个文件中的内容也随之相应改动.微信给Page()函数一下几个属性(data(Object), onLoad(function), onReady(Function), onShow(Function), onHide(Function), onUpload(Function), onPullDownRefresh(Function)),而且你也可以添加任意函数或者数据到object参数中,在这个页面用this即可访问.下面就简单的介绍一下这几个官方给出的属性: data - 实现页面的初始化数据 onLoad - 是生命周期函数,用来监听页面加载,一个页面只会调用一次,它的参数可以获取wx.navigateTo和wx.redirectTo及< navigator/>中的query. onReady - 同样是生命周期函数,用来监听页面初次渲染完成,一个页面只会调用一次,代表页面已经准备妥当,可以和视图层进行交互.对页面的设置请在onReady之后设置,如wx.setNavigationBarTitle. onShow - 生命周期函数,用来监听页面显示,每次页面打开都会调用一次. onHide - 生命周期函数,监听页面隐藏'',当wx.navigateTo或者底部tab切换之后调用. onUpload - 生命周期函数,用来监听页面卸载.当wx.navigateTo和 navigateBack的时候调用. onPullDownRefresh - 页面相关事件处理函数,用来监听用户的下拉动作.但是需要在config的window选项中开启enablePullDownRefresh,当数据刷新完成之后,可以用wx.stopPullDownRefresh停止当前页面的下拉刷新. 下面是微信给出的官方代码:Page({     data: {         text: \"This is page data.\"     },     onLoad: function(options) {     // Do some initialize when page load.     },     onReady: function() {       // Do something when page ready.     },     onShow: function() {     // Do something when page show.     },     onHide: function() {         // Do something when page hide.       },     onUnload: function() {         // Do something when page close.     },     onPullDownRefresh: function() {     // Do something when pull down       },     // Event handler.     viewTap: function() {       this.setData({ text: 'Set some data for updating view.'     })   }})上面说了用data属性来设置页面的初始化数据,但是如果我们想改变数据里面的值,怎么办??那么我们就介绍一个微信官方给我们提供的setData()函数,这个函数可以将数据从逻辑层发送到数据层,同时还可以改变this.data的值.setData()接受一个对象参数,让数据以key,value的形式表示将this.data中key对应的值改变成value.下面是微信官方给出的page的生命周期的图片:在小程序中的所有页面路由全部由框架进行管理,对于路由的触发方式以及页面的生命周期函数可以通过调用API来进行..下面我们就简单的介绍一下微信小程序的API.微信小程序框架给我们提供了丰富的微信原生API,可以方便的调用微信提供的能力,如获取用户信息,本地存储,支付功能等.下面是微信关于API提供的说明:wx.on 开头的API是监听某个事件发生的API接口,接受一个CALLBACK函数作为参数,当事件触发时,会调用CALLBACK函数. 如未有特殊约定,其他API接口都接受一个object作为参数. OBJECT 可以指定success,fail,complete来接受接口调用结果.OBJECT参数API的具体调用请看 微信小程序API文档因为现在微信小程序还在内测期间,我也没有内测号,所以具体的调用API代码需要在微信小程序开放之后,根据具体的逻辑进行实现.而且微信API文档已经给的非常清楚,相信调用不会太过困难.上面的这些就是微信小程序page的页面注册以及API功能实现，但是我们知道光有这些是不够的，在互联网发展到现在我们更加注重的是人机交互，让用户有一个更好的体验才算是 一个好的程序，那么接下来我们就讲讲微信小程序是如何对页面进行渲染的。在微信小程序中采用了微信自己原生的渲染方式。微信小程序的页面布局采用的是wxml，然后结合基础组件，事件系统构建出来页面的结构。wxml中有数据绑定，条件渲染，列表渲染， 模版，事件， 引用这几种方式，下面我们就具体说说这几种方式。数据绑定 在上面我们已经说过了在Page()注册页面的时候，里面会有一个data属性来定义初始化数据，现在页面渲染的数据绑定的时候就需要调用data里面的数据了。下面看一下官方给出的例子。<view> {{ message }} </view>Page({ data: { message: 'Hello MINA!' }})从上面的代码可以看出来在视图层接受逻辑层的代码的时候需要用2个大括号把数据的键值包起来就可以得到数据的值。当然在视图层还可以进行运算（三元运算，算术运算），逻辑判断，字符串运算，而且还可以在大括号里面进行组合（数组，对象（虽然可以随意组合，但是如果后面的变量名和前面的变量名相同的话，那么后面的会覆盖前面的））。条件渲染 顾名思义所谓的条件渲染，就是通过条件来判断是否需要渲染该代码块。条件渲染主要是用到wx:if 和 block wx:if 这两个，第一个相信好理解，第二个是在block里面进行条件渲染，这里我们特别说明一下< block/>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。和我们以前的逻辑编程类似，既然有了wx:if ，那么我们也会有wx:elseif和wx.else，这几个组合起来，可以使条件渲染更加灵活。在这里官方文档中提到了一个wx:if和hidden的对比，通过合理的运用这两种方法可以使你的程序更优。下面我们就是说说他们俩的区别：因为wx:if之中也可能包含数据绑定，所以当wx:if的条件值切换时，框架有一个局部渲染的过程，他会确保条件在切换是销毁或者重新渲染。同时wx:if也是有惰性的，如果初始渲染条件为false,框架什么也不会做，只有在条件第一次变为真的时候才会开始渲染。相比之下hidden就简单的多，组件始终都会被渲染，只是简单的控制显示和隐藏，一般来说，wx：if 有更高的切换消耗，而hidden有更高的初始渲染消耗，你可以根据自己的需求来调用。列表渲染 -- wx:for下面我们就说说wx:for的用法，wx:for绑定一个数组，就可使用数组中各项数据重复渲染该组件，注意默认数组的当前项的下标变量名默认为index，数组当前项的变量名为item，，当然你也可以根据自己的需要来重新定义这两个名字，使用wx:for-item可以指定数组当前元素的变量名，wx:for-index可以指定数组当前下标的变量名，wx:for也可以嵌套，这个时候就需要改变默认框架给定义的名字了。下面是官方给出的事例代码：<view wx:for=\"{{items}}\"> {{index}}: {{item.message}}</view>Page({ data: { items: [{ message: 'foo', }, { message: 'bar' }] }})<view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">   {{idx}}: {{itemName.message}}</view>模版WXML提供模版(template),可以在模版中定义代码片段,然后在不同的地方调用.微信小程序的模版可以用name来命名它的名字,在使用的时候用is来声明使用的模版,然后将模版所需要的data传入即可,下面我们用官方文档给的代码来看一下如何声明及调用模版.<!--  index: int  msg: string   time: string--><template name=\"msgItem\">   <view>     <text> {{index}}: {{msg}} </text>     <text> Time: {{time}} </text>   </view></template>上面这段代码可以看到模版的名字是\"msgItem\".<template is=\"msgItem\" data=\"{{...item}}\"/>在调用的时候使用方法如上,在is属性加上模版的名字即可.后面还有一个data属性,并且在里面还加入数据,下面我们就看一下下面这段代码.Page({ data: { item: { index: 0, msg: 'this is a template', time: '2016-09-15' } }})<template name=\"odd\">   <view> odd </view></template><template name=\"even\">   <view> even </view></template><block wx:for=\"{{[1, 2, 3, 4, 5]}}\">   <template is=\"{{item % 2 == 0 ? 'even' : 'odd'}}\"/></block>通过上面对条件渲染的介绍,我们可以看到在循环掉数组[1,2,3,4,5]之后item数组属性在三元运算中判断调用哪一个模版.在这儿再多说一句模版也有自己的作用域,只能使用data传入的数据,当然data传入的数据可以是你自己新建的数据,也可以是你在配置中写好的初始化数据.好了现在我们说完模版了,可能有的同学就该想了,我写好模版之后该如何调用它,如果他们是在一个页面那肯定没问题,但是这样的话可用性还是很差啊,如果我想把模版单独放在一个页面,在调用它的时候该怎么办啊?没关系,微信小程序早就考虑到了,那么我们接下来就说说引用.引用WXML提供两种引用方式import和include.接下来我们就先说说import这种方式,我们就结合代码来看,它调用在不同页面的模版消息如下:<!-- item.wxml --><template name=\"item\">   <text>{{text}}</text></template>在 index.wxml 中引用了 item.wxml，就可以使用item模板：<import src=\"item.wxml\"/><template is=\"item\" data=\"{{text: 'forbar'}}\"/>这里要注意一下,import引用也是有作用域这个概念存在的,它只会定义import目标文件中定义的template,而不会import目标文件import中的template.简而言之就是import只能引用template而不能引用import.上面说了import是如何引用的,那么我们接着看一下include是怎么引用的.include引用和import唯一不同点就是他的引用相当于复制,他会复制< template>里面的全部内容,但是不包含< template>,看一下代码相信你可以理解的更加明白.<!-- index.wxml --><include src=\"header.wxml\"/><view> body </view><include src=\"footer.wxml\"/><!-- header.wxml --><view> header </view><!-- footer.wxml --><view> footer </view>上面我们说的视图层这些方法已经可以构成一个静态的页面了,但我们现在是21世纪啊,一个没有人机交互的程序怎么能在这个世界生存下来了?在用户体验至上的今天,微信小程序不可能不考虑到这一点,接下来我们就说说视图层的事件方法.先来说说什么是事件,相信有的人看到这儿肯定是一脸懵逼,你这说的啥玩意儿,说的这么专业,我还不如看文档去.那么我们就说说什么是事件. 事件就是一种页面到逻辑层的通讯方式,比如说你的操作想得到机器的反馈,这时候就用到事件了.事件可以将用户的行为反馈到逻辑层进行处理. 说到这儿不禁又有一个问题,那他是怎么用的呢? 事件可以绑定到组件上,当触发事件,就会执行逻辑层对应的事件处理函数,当然为了更加方便人机交互,用户还可以携带额外的信息,如id,data等.可能有人看完刚才的一段就说了,好了,你刚才说的事件解释的差不多了,可是你为什么有冒出一个组件,这让我这么理解?既然说到组件了,我们就先简单的了解一下,在之后的组件板块再详说,先保证大家能看懂什么是事件就好了.为什么要有组件呢?组件是框架为了开发者进行快速的开发而设计的.那什么是组件呢? 组件是视图层的基本组成单元,在微信小程序中组件自带一些功能与微信风格的样式,一个组件通常包括开始标签和结束标签,属性是用来修饰这个组件,内容在两个标签之内.<tagname property=\"value\"> Content goes here ...</tagename>在这里需要注意一点,组件和属性都是小写,并且以\"-\"进行连接.简单的介绍一下组件,那我们继续说事件.事件分为冒泡事件和非冒泡事件,冒泡事件是当一个组件上的事件被触发后,该事件会向父节点传递,而非冒泡事件则不会.现在微信小程序给出的冒泡事件仅仅有6个(touchstart,touchmove, touchcancel,touchend,tap, longtap),下图是他们分别对应的触发条件.冒泡事件类型剩下的都属于非冒泡事件.接下来我们就说说事件怎么用?事件是通过事件绑定来实现的.它的写法是以key,value的形式来写的.key以bind 和catch 开头,然后跟上事件的类型. value 是一个字符串,需要在对应的page中定义同名的函数,不然当触发事件的时候会报错.(bind 事件绑定不会阻止冒泡事件向上冒泡,而catch 可以阻止冒泡事件向上冒泡).说完了如何进行事件绑定了,我们再说说,当事件触发是逻辑层的事件处理函数会收到什么? 事件处理函数会收到一个事件对象. 那么这个事件对象里面都有什么属性呢?? 里面的属性有(type, timeStamp, target, currentTarget, touches, detail),下面是他们的一些说明:事件对象属性type得到的是通用事件类型,例如tap. timeStamp是页面打开到事件触发所经过的毫秒数. target触发事件的源组件,它包括事件源组件的id,data-开头自定义属性的组成的集合(dataset),以及他在坐标系统中的偏移量. currentTarget 触发事件的当前事件,它包括的内容与target相同.其他的属性按照上面的说明简单了解即可,在这里我们说一下target和currentTarget中的dataset,我们知道在组件中可以定义数据,这些数据会通过事件传递给 SERVICE书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。用一段代码来说话相信大家就更清楚了.<view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindtap=\"bindViewTap\"> DataSet Test </view>\r\n\r\nPage({ \r\n  bindViewTap:function(event){ \r\n    event.target.dataset.alphaBeta == 1 // - 会转为驼峰写法 \r\n    event.target.dataset.alphabeta == 2 // 大写会转为小写 \r\n  }\r\n})我不知道大家感觉怎么样,要是我自己刚开始看我写的这一大段内容,我感觉我就该骂娘了,不是说么NO图NO BB,下面我就给大家上代码,相信看完之后事件这一块基本上就明白了.//视图层的事件绑定<view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view>//逻辑层的事件处理函数Page({ \r\n  tapName: function(event) { \r\n    console.log(event)\r\n }\r\n})//逻辑层的事件处理函数输出的信息//逻辑层的事件处理函数输出的信息\r\n{\r\n\"type\": \"tap\",\r\n\"timeStamp\": 1252,\r\n\"target\": { \r\n  \"id\": \"tapTest\", \r\n  \"offsetLeft\": 0, \r\n  \"offsetTop\": 0, \r\n  \"dataset\": { \"hi\": \"MINA\" }\r\n},\r\n\"currentTarget\": { \r\n  \"id\": \"tapTest\", \r\n  \"offsetLeft\": 0, \r\n  \"offsetTop\": 0, \r\n  \"dataset\": { \"hi\": \"MINA\" }\r\n},\r\n\"touches\": [{ \r\n  \"pageX\": 30, \r\n  \"pageY\": 12, \r\n  \"clientX\": 30,\r\n  \"clientY\": 12, \r\n  \"screenX\": 112, \"screenY\": 151\r\n}],\r\n\"detail\": { \"x\": 30, \"y\": 12}}到这儿WXML的页面结构就说完了,接着我们简单说说WXSS就基本说完了.在WXSS中引入了新的 尺寸单位rpx 它规定1rpx=0.5px = 1物理像素WXSS的样式导入使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束.剩下的内容基本上和css相差不大,有兴趣的可以看一下官方文档WXSS"}
{"title": "教你如何在微信小程序中使用 Hprose ", "author": "天下雪", "pub_time": "2016-10-19 18:20", "article_content": "微信小程序 SDK 刚刚出来，就已经有一堆入门教程了。然而并没有关于如何在微信小程序中进行网络通讯的教程，所以我们今天就来讲一下新鲜出炉的独门绝技——hprose 如何在微信小程序中实现通讯。\r\n首先下载微信小程序开发工具，之后安装。\r\n然后按照网上那一堆微信小程序 Hello World 教程创建一个小程序。\r\n接下来我们下载 hprose-html5 或者 hprose-js。推荐使用 hprose-html5 版本，这个版本更小，支持二进制数据传输，而且更快。\r\n可以用 git clone 下载，也可以只下载 dist 目录下的文件，以 hprose-html5 版本为例：\r\nhprose-html5.src.js 是源码版本 hprose-html5.js 是压缩版本\r\n这两个版本都可以用。调试阶段建议用源码版本。但不要使用 hprose-html5.min.js 版本，这个版本是压缩版本的，不支持在微信小程序中编译。\r\n之后，你可以把它们复制到你创建的那个微信小程序的 utils 目录下（复制其中一个就可以），然后将它改名为 hprose.js（这一步可选，只为后面引用的时候，名称统一）。\r\n接下来，打开 pages/index/index.js 文件。\r\n在开头加上：\r\nvar hprose = require('../../utils/hprose.js');\r\n然后在 onLoad 事件中加入以下代码：\r\nvar client = hprose.Client.create(\"http://www.hprose.com/example/\", [\"hello\"]);client.hello(\"world\", function(result) {  console.log(result);});\r\n总体看上去是这样的：\r\n//index.jsvar hprose = require('../../utils/hprose.js');//获取应用实例var app = getApp()Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //事件处理函数  bindViewTap: function() {    wx.navigateTo({      url: '../logs/logs'    })  },  onLoad: function () {    console.log('onLoad')    var client = hprose.Client.create(\"http://www.hprose.com/example/\", [\"hello\"]);    client.hello(\"world\", function(result) {      console.log(result);    });    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据      that.setData({        userInfo:userInfo      })    })  }})\r\n然后点编译，运行，如果你的网络没有问题的，你会在调试控制台中看到：\r\n这里写图片描述\r\n好了，就这么简单，接下来，你就可以用 hprose 来做微信小程序开发了。"}
{"title": "微信小程序开发工具安装指南及注意事项 ", "author": "天下雪", "pub_time": "2016-10-19 19:02", "article_content": "这两天闲来无事，也安装了 “微信折叠”的开发工具来玩一下。以下是一些小道消息及使用体验，过两天我会写一篇文章以开发者的角度来详细评价微信小程序:微信小程序不能开发游戏类、直播类功能，小程序每个人关注的上限是20个（还不确定，不过我相信这是真的，这次公布的API里并没有视频组件。微信太大，苹果要有所顾忌，但是微信也要做出相应的让步)微信目前有没有同苹果商谈好，还是个未知数，毕竟会对AppStore有一定的冲击。抛弃了大量的javascript组件后，这个生态体系变得相当的封闭，微信解释肯定是：为了更好的性能提升。那么我们拭目以待。小程序的入口是微信里的三级菜单，就是在“Tab栏发现里的游戏下面加入一个“小程序”。反正，这一栏里的购物和游戏我是从来没点进去过的。以腾讯的尿性，小程序同服务号一样，其关系链及重要功能的开放程度会因“人”而异。对，优质的接口只会开放给腾讯的儿子们（滴滴呀、京东呀）微信从来就是一眼不合就封杀，优步就是很好的案例。官方解释是优步涉嫌诱导，滴滴同样被禁过。利益面前还讲道理？反正我是不信的。腾讯的投资覆盖各个行业，一旦腾讯掌握了应用分发入口，给儿子们一些小小的甜头，应该不是什么大事儿吧。有人说AppStore也有很多限制，但至少苹果并没有像腾讯这样大量的投资消费级App，直接产生利益冲突的点并不多。话说回来，这点创业者是不用考虑的，暂时，你的产品和创意，在微信眼里还是个蝼蚁。。。你不用担心受到不公正的对待。如果真有一天你被微信封杀了，只要不是因为违规内容，那么你应该高兴，然后迅速炒作一波…….很多做Web的朋友尝试在小程序里写div、ul等标签，别试了，没效果，包括JQUERY在内的DOM操作库，小程序内是不能运行的。小程序本质是JS+ReactNative，对RN底层做了重构，已经和dom说拜拜了。 下面是详细的安装步骤。win10下测试通过以下是安装步骤：按操作系统下载相应开发工具版本 windows 64位 windows 32位 mac 小程序示例组件demo下载双击安装打开微信web开发者工具添加一个项目，如图填写项目信息 注意AppId这里选择“无AppId”,AppID只有内测用户才有，无AppId在目前有功能限制，比如不能发布项目到手机微信中预览。点击“添加项目”按钮后，将创建一个小程序项目, 工具已经为你创建了一个demo —– Hello World开发者工具功能区域介绍工具左侧分别有编辑、调试、项目调试区按钮，分别解释3个区域的作用.。编辑： 是你写代码的地方，左侧的文件目录是微信为你创建的一个项目基础骨架，你可以在这个骨架上编写自己的业务代码。当我们编写完代码后，点击编辑视图左下角的“编译”即可进行调试和运行（当点击“编译后”，工具视图会自动跳转到第二个“调试”视图）调试: 是你调试代码的地方。整个界面同Chrome的调试工具一模一样（应该是内嵌了WebKit内核），相信有Web开发经验的同学很快就能上手。F8 运行到下一个断点、F10 单步运行、Ctrl+/ 注释代码。解释一下“调试”视图下，顶部的六个Tab栏（Console、Sources、Network、Storage、AppData、Wxml）： Console： 工具的输出区域，在程序中调用 console.log(‘测试一下console’), 可在这里输出自定义调试信息。同时，这里也是工具遇到异常和发出警告的信息输出区域。见图：  Sources: 源代码显示区域，这里你可以打断点并调试代码。Sources Pannel 用于显示当前项目的脚本文件，同浏览器开发不同，微信小程序框架会对脚本文件进行编译的工作，所以在 Sources Pannel 中开发者看到的文件是经过处理之后的脚本文件，同编辑区域的代码有稍许的差异，比如开发者的代码都会被包裹在 define 函数中，并且对于 Page 代码，在尾部会有 require 的主动调用。  Network: 用于观察和显示 网络的request 和 socket 的请求情况   Storage: 如果你在程序中使用了 wx.setStorage 或者 wx.setStorageSync 后，在这里将会显示你的数据存储情况。是的，小程序支持本地缓存数据。   AppData: 用于显示当前项目当前时刻 appdata 具体数据。可以在这里管理应用程序中的各类变量（不同于Storage中的缓存变量，只有调用wx.setStorage 或者 wx.setStorageSync 的数据才会出现在Storage中）。在这，你可以随时修改变量，工具将把变量改变在左侧预览视图中实时显示。我们可以看到，AppData 以页面（pages/index/index）作为分组单位，每个页面只会显示自己的AppData，非常的清晰。 Wxml：将Wxml标签同预览界面实时关联，在这里可以看到真实的页面结构以及结构对应的 wxss 属性，同时可以通过修改对应 wxss 属性，在模拟器中实时看到修改的情况。通过调试模块左上角的选择器，还可以快速找到页面中组件对应的 wxml 代码。最后说下“项目”这个功能区块儿， 项目实际上是用来上传和预览项目的。微信要求所有发布的小程序都必须审核，所以需要在这里将小程序上传（应该是类似于AppStore，但肯定不是AppStore的发布模式，苹果应该不会允许。小程序目前同用户的接触方式还是未知数，而这恰恰是最重要的一块儿）。如果你没有被内测邀请，这里你是不可以上传和预览项目的，也不可以真机运行小程序，所以真正的体验相对于原生App还是未知数。目前阶段，你只能熟悉一下小程序的API，以便在公测后迅速拿出自己的产品，抢夺第一波红利。总体来说，小程序的大概开发模式和模型 已经暴露，其本质是JS+RN，很多人说JavaScript程序员的春天来了，其实小程序的体系和Web开发还是有很多区别的。微信言下之意是要抛弃你们熟悉的DOM采用他的组件体系，更熟悉这种组件式开发的不是传统的Web前端，而是iOS开发人员（更早点你可以追溯到Flex和SilverLight），我本人是不喜欢这种非JS原生的组件式开发的，自由度会受限。后续，我会持续更新小程序的开发例子和教程，尽快帮助大家上手开发业务和产品。你现在需要做的，就是静心想想，我应该开发一个什么样的产品？"}
{"title": "zhi_chao：小程序进阶实战进阶：豆瓣电影demo布局搭建 ", "author": "天下雪", "pub_time": "2016-10-20 10:44", "article_content": "我们创建起了小程序项目，并粗浅的了解了小程序的外部项目结构，了解了 js，wxml，wxss都最基本运用，现在我们在进行循序渐进的深入探究，如何制作真实项目。先看效果图： 分析步骤：1、讲头部的视图滑动，简单2、讲底部的导航栏，简单3、讲中间的内容显示，中等4、讲JS逻辑实现。复杂难度等级的划分只局限于本文，不联系实际开发。 1、头部视图滑动，实例图：  准备工作先做好，创建一个项目，把系统自带的都删了 只留外层目录，内层文件都删了。  然后在pages中添加一个movie目录作为首页，分别在创建，js  \\  wxml  \\  wxss. ,并在app.json中注册 好了，现在我们开始编写wxml与js文件，首先我们确定头部显示要用什么组件，先看官方文档中的swiper-view控件（滑块视图组件）就用它了 在文档中找到这段并代码复制到 wxml中去 （复制后别忘了 Ctrl+s 保存） 然后复制这段代码到 js 文件去  好了我们可以去调试页面看看变化，用鼠标可以滑动，但它的显示有瑕疵有留白，我们去wxml中做一点改动。 在wxml中把width和height 两个属性去掉 ，改为： style = \"width:100%\"  。  {{}}中的内容是什么，看后面注解。 现在我们在去js中，把视图改为自动跳转的。 仔细看注释！ 豁然开朗了吧，文档也理解了吧! 完成以上步骤后，一个滑动视图算是初步的做好了，以后要做深入也只是把视图改为动态获取图片，而不是像现在这样指定了静态的链接，是不正确的， 当然你也可以做一些稀奇古怪的滑动视图没人拦你。从这里我们可以发现微信小程序开发，给我们带来的方便与高效，只要摸清楚文档，一个程序还是挺容易搭建的。  2、底部导航栏：打开官方开发文档文档配置篇 把这段复杂过来，要注意我们要把路径改为刚刚创建的movie文件目录，然后去网上找一下log资源放到image文件中去.在文档配置篇中找一下iconPath和selectedIconPath看看他们是干嘛的！底部导航栏就完成了，看下面的代码也能不难。 完成后的效果：  现在开始进入下一个阶段，先看效果图  简单的分析下，一个图片控件image，在加一个文字控件text，接下来的排版就需要交给wxss和<view>进行配合搭建，而不是单纯的只使用image和text，使用<view包裹，在利用wxss进行编排在刚刚的，image目录中，放一张图片进去先，我放了 “我老婆的照片”MD美死了！！！ 然后在wxss中做一些准备 ，其实这步骤是不对的，但如果联系wxml边写边做wxss的样式，要截的图就多的离谱了，所以我想，直接给wxml和wxss写好的布局，让你自己去琢磨分析也有相同的效果，毕竟我已经给出很详细的注解了，不至于看晕。/** 占满全屏**/.content{height: 100%;}/** 将图片与文字左右分开 **/.movie{display: flex;flex-direction: row;}/** 设置图片大小 **/.pic image{width: 100px;height: 150px;}/** 设置与左边图片的间距**/.movie-info{padding-left: 20px ;}/** 文字大小与行高 **/.base-info{font-size: 12px;padding-top: 20px;line-height: 20px;}/** 分割线 **/.hr{height: 2px;width: 100%; border-top: wheat solid 1px;border-bottom: wheat solid 1px;opacity: 0.2;}wxml中的布局，就让您自己去打吧，不然学习就失去效果了，要注意的是我的<view> 是上下呼应的为了能让你看清楚，它的结束语句在哪里，占满全屏的view它的结束语句必须包裹所有内容。我把要讲的内容放在注解里了，写完保存直接去调试页面看效果。 粗略的布局总算是搭建好了，后面就是联系API获取数据，在js中做一些逻辑操作了。 以上归纳概述：<view> 用来做排版， 组件负责接收数据并显示。现在要开始编写JS文件了，这里就有点麻烦，毕竟代码量还挺多的，你可以先休息一会儿，把wxml和wxss先消化一下"}
{"title": "zhi_chao：小程序进阶实战进阶：豆瓣电影demoJS逻辑篇 ", "author": "天下雪", "pub_time": "2016-10-20 11:08", "article_content": "双大括号是{{}}用来JS和wxml绑定事件的，比如，数据更新，显示规则，等等的一些有规则有章法的操作。那么我们就需要引用这种机制，为我们的image和text控件做数据更新的操作。很好知道这点，后面的事情都交给JS去完成。现在开始，分析步骤，（前面三步为一体，第四步则分出来讲。）1、首先要有一个函数用来向网络发送请求这一步看官方文档发送请求2、关注文档中的三个关键字，url、header、success,url，就不多说了网络请求，不了解的必须先了解一下header，不熟悉HTTP协议的朋友，在看到文档中这个属性时一定会迷惑看的云里雾里的，他是将网页中的内容进行解析比如文档中的 header 方法中的代码：'Content-Type':'application/json' 是把内容解析为json格式的，如果把它换成'Content-Type':'application/xml' 那么它就会将网页的内容解析为xml格式的，现在你应该明白了，json是微信自己指定的文件格式，我们按照它的写法就可以了，so等会直接复制过来使用。success，读取数数据用的函数、（看文档时看他的类型Function）3、（这一步的操作对后面的理解有些许帮助）豆瓣电影API 我们分别要使用到他的 ， 正在热映 ，Top250 , 电影搜索，三个接口。https://api.douban.com/v2/movie/in_theaters 查看接口 以正在热映为列 由于此页面的内容太复杂，我们可以做一些简化打开此链接，按F12出现调试框，将页面中的所有内容复制，而后在调试框中输入 var a = 将复制的内容粘贴在等号后面，回车，然后输入 a 回车，现在此页面的内容就有条理了。4、有了以上步骤思路，最后要想到，数据的读取，以及数据格式处理（这里的格式化与header不同，我们是将数据格式化编排给用户看的）。so：我们需要两个函数，一个用来循环遍历读取网络数据，另一个则把数据格式化。由于这两个函数的也可以为后面top250的页面使用，所以我使用封装把他们俩封装起来供后面的逻辑使用。5、把数据在wxml中进行关联。有了这四步的思路，我们开始看JS代码的实现。（我怕你已经晕了！别急有了前面的步骤做铺垫我想你看起代码来会更得心应手。）由于前三步相对简单所以先从第四步的两个函数开始说 ：在Utils中创建subjectUtills.js (文件名不是固定的。)  接下来在 写第一个循环获取数据的函数。  现在来写数据格式的函数，由于代码有点多就想着给你节约点时间下面给出可复制的文字。// 获取数据并格式function provessSubject( subject ) {//电影名var title = subject.title;//导演信息var directors = subject.directors;var directorStr = \"\";for( var index in directors ) {directorStr = directorStr + directors[ index ].name + \" / \";}if( directorStr != \"\" ) {directorStr = directorStr.substring( 0, directorStr.length - 2 );}//演员信息var casts = subject.casts;var castStr = \"\";for( var index in casts ) {castStr = castStr + casts[ index ].name + \" / \";}if( castStr != \"\" ) {castStr = castStr.substring( 0, castStr.length - 2 );}//类型信息var genres = subject.genres;var genreStr = \"\";for( var index in genres ) {genreStr = genreStr + genres[ index ] + \" / \";}if( genreStr != \"\" ) {genreStr = genreStr.substring( 0, genreStr.length - 2 );}//发行的年份var year = subject.year;//将数据格式化var text = \"名称：\" + title + \"\\n导演:\" + directorStr + \"\\n演员:\" + castStr + \"\\n类型:\" + genreStr + \"\\n上映年份:\" + year + \"(中国大陆)\"//拿到格式化的数据subject.text = text;}模块化（封装） 最后不要忘记封装 完成了这两个函数，现在我们来写网络请求的逻辑代码 第五步，完成wxml中的数据关联。注意 {{item.images.medium}} 这串代码 和  {{item.text}} 后面细讲。这里添加了block循环和loading组件。 讲一下{{item.images.medium}} ， 而 {{item.text}}应该不用多讲就是我们格式化的数据。使用第三步的操作 你会得到这样的页面，看了之后你应该就不明觉厉了， 首页差不多就写好了现在看一下效果怎么样。 写到这里一个展示区差不多就写好了，后面还要继续深入。"}
{"title": "新手入手教程微信小程序上手开发和使用总结 ", "author": "天下雪", "pub_time": "2016-10-18 10:23", "article_content": "一、模板　　WXML提供模板组件给我们使用，可以在模板定义公用的代码片段，然后在需要引用的地方进行调用。定义模板　　定义模板使用name属性作为模板的名字，然后在template标签中定义代码片段：123456789101112<template name=\"mytemplate1\">  <view>    <text>firstName:{{firstName}}</text>    <text>lastName: {{lastName}}</text>  </view></template><template name=\"mytemplate2\">  <view wx:for=\"{{persons}}\">  \t<text>firstName:{{item.firstName}}</text>    <text>lastName: {{item.lastName}}</text>  </view></template>使用模板　　使用模板我们用is属性引用定义好的模板，然后把模板所需要的值通过data属性传给模板。比如需要遍历persons数组，我们可以将整个persons作为对象传给模板，也可以遍历persons后将每个对象传给模板，具体取决于所应用的场景。1234<view wx:for=\"{{persons}}\">  <template is=\"mytemplate1\" data=\"{{...item}}\"></template></view><template is=\"mytemplate2\" data=\"{{persons}}\"></template>　　需要的数据结构如下123456789Page({\tdata:{\t\tpersons:[\t\t\t{firstName: 'Hulk', lastName: 'Hu'},\t    \t{firstName: 'Shang', lastName: 'You'},\t    \t{firstName: 'Gideon', lastName: 'Lin'}\t\t]\t}})注意：is属性也可以使用Mustache语法进行动态渲染，决定使用哪个模板data如果传的是对象类型的数据，需要用“…”进行“解构”，在模板中可以直接调用对象的属性；如果是其他数据类型则不需要用“…”二、事件　　什么是事件呢，简单来说，事件就是逻辑层到逻辑层的通讯方式。就是在页面上通过触发某个操作（就是我们说的事件），在逻辑层进行一系列的操作，最终来改变数据。　　比如在一个输入框中用户输入了一段文字，但是data中的数据并没有随之改变，因此我们需要在输入框上绑定对应的输入事件来更改数据。事件分类　　事件也有分类，可以分为冒泡事件和非冒泡事件。“冒泡”这个词很形象的表现了事件向上传递的过程，这两种事件的区别也在于是否会向父节点进行传递。　　一些常用的冒泡事件，除以下的事件外都是非冒泡事件：名称触发touchstart手指开始触摸touchmove手指触摸后移动touchend手指触摸动作结束touchcancel触摸被打断，比如来点，弹框等tap触摸后离开，有点像点击clicklongtap长按，超过350ms才离开事件对象　　当事件函数被调用时，从逻辑层有一个默认的事件对象传到函数中，不同的事件所包含的事件对象的属性有所区别，一些常用的事件对象的属性如下：属性类型说明typeString事件类型timeStampInt从页面加载到事件触发的时间戳targetObject触发事件的组件的一些属性值集合currentTargetObject当前组件的属性值集合touchesArray触摸点信息的数组detailObject额外的信息target和currentTarget区别　　当不存在嵌套时，target和currentTarget没有区别。但是当嵌套触发事件是，current和currentTarget的区别就体现出来了。123456<view class=\"A\" bindtap=\"handle1\">  outer    <view class=\"B\" bindtap=\"handle2\">    inner    </view>  </view>　　点击组件B，当触发handle2事件时，收到target和currentTarget对象是一样，都指向组件B；而当点击组件B触发handle1事件时，target对象指向了组件B，currentTarget对象则组件A。总结一下：target对象指向了所触发事件的对象currentTarget对象指向了绑定事件所在的对象向detail中添加内容　　在组件中定义数据，当触发事件时，这些数据通过事件对象传给逻辑层。书写规则：以“data-”开头，多个字符用“-”连接，不能含有大写，可以绑定多个data值。例如data-element-name，最终会在event.currentTarget.dataset中转为elementName属性，属性的值就是定义的数据。三、异步数据　　小程序还提供发送异步的方法request(object)，发起的是https请求。一个小程序，同时只有有5个网络请求链接。object的参数如下：参数命类型说明urlSring服务器接口地址dataObject请求的参数headerObject设置请求头header，header不能设置ReferermethodString请求方式，默认GETsuccessFunction请求成功的回调方法failFunction请求失败的回调方法completeFunction请求完成的回调方法(请求成功、失败都会调用)　　跟jQuery不同的是，小程序请求的数据不是直接在success方法的res中(res是一个对象，还包括请求成功的状态码等)，而是在res.data中。示例代码如下：12345678910111213wx.request({  url: '/url',  data: {     x: '',     y: ''  },  header: {      'Content-Type': 'application/json'  },  success: function(res) {    console.log(res.data) //接收到的数据  }})"}
{"title": "微信小程序把玩《十二》：Video API，Storage API，location API ", "author": "天下雪", "pub_time": "2016-10-28 13:31", "article_content": "一：Video API电脑端不能测试拍摄功能只能测试选择视频功能，好像只支持mp4格式，值得注意的是成功之后返回的临时文件路径是个列表tempFilePaths而不是tempFilePath文档写的有点问题。主要属性：wx.chooseVideo(object)成功之后返回参数wxml<button type=\"primary\" bindtap=\"listenerBtnOpenVideo\">打开视频</button>\r\n<!--默认视频组件是隐藏的-->\r\n<video src=\"{{videoSource}}\" hidden=\"{{videoHidden}}\" style=\"width: 100%; height: 100%\"/>123123jsPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    videoSource: '',\r\n    videoHidden: true\r\n  },\r\n\r\n listenerBtnOpenVideo: function() {\r\n     var that = this;\r\n     wx.chooseVideo({\r\n         //相机和相册\r\n         sourceType: ['album', 'camera'],\r\n         //录制视频最大时长\r\n         maxDuration: 60,\r\n         //摄像头\r\n         camera: ['front', 'back'],\r\n         //这里返回的是tempFilePaths并不是tempFilePath\r\n         success: function(res){\r\n           console.log(res.tempFilePaths[0])\r\n             that.setData({\r\n                 videoSource: res.tempFilePaths[0],\r\n                 videoHidden: false\r\n             })\r\n         },\r\n         fail: function(e) {\r\n           console.log(e)\r\n         }\r\n     })\r\n },\r\n\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})二：Storage API其实这个存储在新建Demo的时候就已经用到了就是存储就是那个logs日志，数据存储主要分为同步和异步异步存储方法：存数据 wx.setStorage(object) 相同key会覆盖，可写回调方法获取方法：wx.getStorage(object)清除方法：wx.clearStorage()里面可以写回调函数 成功，失败，完成同步存储方法：存数据 相同key会覆盖wx.setStorageSync(key,data)读数据wx.getStorageSync(key) 存储是指定的key清除数据wx.clearStorageSync() 不可写回调方法wxml<!--动态获取数据-->\r\n<text>{{storageContent}}</text>\r\n<!--存-->\r\n<button type=\"primary\" bindtap=\"listenerStorageSave\">storage存储信息会在text上显示</button>\r\n<!--取-->\r\n<button type=\"primary\" bindtap=\"listenerStorageGet\">获取storage存储的信息</button>\r\n<!--清-->\r\n<button type=\"warn\" bindtap=\"listenerStorageClear\">清楚异步存储数据</button>\r\n\r\n\r\n<text>{{storageSyncContent}}</text>\r\n<button type=\"primary\" bindtap=\"listenerStorageSyncSave\">storageSync存储信息会在text上显示</button>\r\n<button type=\"primary\" bindtap=\"listenerStorageSyncGet\">获取storageSync存储信息</button>\r\n<button type=\"warn\" bindtap=\"listenerStorageSyncClear\">清除同步存储数据</button>12345678910111213141234567891011121314jsPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    storageContent: '',\r\n    storageSyncContent: ''\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  /**\r\n   * 异步存储\r\n   */\r\n  listenerStorageSave: function() {\r\n    //以键值对的形式存储 传进去的是个对象\r\n    wx.setStorage({\r\n      key: 'key',\r\n      data: '我是storeage异步存储的信息',\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   * 异步取信息\r\n   */\r\n  listenerStorageGet: function() {\r\n    var that = this;\r\n    wx.getStorage({\r\n      //获取数据的key\r\n      key: 'key',\r\n      success: function(res) {\r\n        console.log(res)\r\n        that.setData({\r\n          //\r\n          storageContent: res.data\r\n        })\r\n      },\r\n      /**\r\n       * 失败会调用\r\n       */\r\n      fail: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 清除数据\r\n   */\r\n  listenerStorageClear: function() {\r\n    var that = this;\r\n    wx.clearStorage({\r\n      success: function(res) {\r\n        that.setData({\r\n          storageContent: ''\r\n        })\r\n      }\r\n    })\r\n  },\r\n\r\n\r\n  /**\r\n   * 数据同步存储\r\n   */\r\n  listenerStorageSyncSave: function() {\r\n    wx.setStorageSync('key', '我是同步存储的数据')\r\n  },\r\n\r\n  /**\r\n   * 数据同步获取\r\n   */\r\n  listenerStorageSyncGet: function() {\r\n    // var that = this;\r\n    var value = wx.getStorageSync('key')\r\n    this.setData({\r\n      storageSyncContent: value\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 清除同步存储数据\r\n   */\r\n  listenerStorageSyncClear: function() {\r\n    wx.clearStorageSync()\r\n  },\r\n\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})三：location APIlocation API也就分这里分两种wx.getLocation(object)获取当前位置和wx.openLocation(object)通过经纬度打开内置地图。其中定位获取位置信息返回参数是有问题的speed，accuracy这两个是没有的。还有一个就是打开内置地图之后再返回会报一个错误(Page route错误—WAService.js:2 navigateBack 一个不存在的webviewId0)如果有知道的可告知，我找到解决方式也会补充下！主要属性：wx.getLocation(object)获取当前位置成功之后返回参数wx.openLocation(object)打开微信内置地图这里直接进入微信内置应用，当使用导航返回键时是内部写的外界无法干预所以WAService.js:2 navigateBack 一个不存在的webviewId0这个错估计也带等小程序修复吧！！wxml<button id=\"0\" type=\"primary\" bindtap=\"listenerBtnGetLocation\">定位当前位置并打开内置地图</button>11jsPage({\r\n  data:{\r\n    text:\"Page location\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n\r\n  /**\r\n   * 监听定位到当前位置\r\n   */\r\n  listenerBtnGetLocation: function() {\r\n    wx.getLocation({\r\n      //定位类型 wgs84, gcj02\r\n      type: 'gcj02',\r\n      success: function(res) {\r\n        console.log(res)\r\n        wx.openLocation({\r\n          //当前经纬度\r\n          latitude: res.latutude,\r\n          longitude: res.longitude,\r\n          //缩放级别默认28\r\n          scale: 28,\r\n          //位置名\r\n          name: '测试地址',\r\n          //详细地址\r\n          address: '火星路24号',\r\n          //成功打印信息\r\n          success: function(res) {\r\n            console.log(res)\r\n          },\r\n          //失败打印信息\r\n          fail: function(err) {\r\n            console.log(err)\r\n          },\r\n          //完成打印信息\r\n          complete: function(info){\r\n            console.log(info)\r\n          },\r\n        })\r\n\r\n      },\r\n      fail: function(err) {\r\n        console.log(err)\r\n      },\r\n      complete: function(info) {\r\n        console.log(info)\r\n      },\r\n    })\r\n  },\r\n\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})"}
{"title": "微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ... ", "author": "天下雪", "pub_time": "2016-10-28 13:39", "article_content": "一：获取设备信息 API获取设备信息这里分为四种，主要属性：网络信息wx.getNetWorkType, 系统信息wx.getSystemInfo,重力感应数据wx.onAccelerometerChange,罗盘数据wx.onCompassChangewxml<button type=\"primary\" bindtap=\"getNetWorkType\">获取网络类型</button>\r\n<button type=\"primary\" bindtap=\"getSystemInfo\">获取设备信息</button>\r\n<button type=\"primary\" bindtap=\"onAccelerometerChange\">监听重力感应数据</button>\r\n<button type=\"primary\" bindtap=\"onCompassChange\">监听罗盘数据</button>12341234jsPage({\r\n  data:{\r\n    text:\"Page system\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  /**\r\n   * 获取当前网络状态\r\n   */\r\n  getNetWorkType: function() {\r\n    wx.getNetworkType({\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   *  获取系统信息\r\n   */\r\n  getSystemInfo: function() {\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   *  监听重力感应数据     \r\n   *      - 带on开头的都是监听接收一个callback\r\n   */\r\n  onAccelerometerChange: function() {\r\n    wx.onAccelerometerChange(function(res) {\r\n      console.log(res)\r\n    })\r\n  },\r\n    /**\r\n   *  监听罗盘数据\r\n   */\r\n  onCompassChange: function() {\r\n    wx.onCompassChange(function(res) {\r\n      console.log(res)\r\n    })\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})二：navigation API小程序也就提供这几个处理导航控制值得注意的是只能同时导航五个页面\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(51, 51, 51); font-family: 'microsoft yahei'; line-height: 26px; background-color: rgb(255, 255, 255);\">演示效果也看到了小程序也就提供这几个处理导航控制。值得注意的是只能同时导航五个页面主要属性：导航条一些方法wx.setNavigationBarTitle(object) 设置导航条的Title导航标题可以通过三种方式设置，第一种是通过全局配置名字统一，第二种就是在page中新建个json文件配置它会覆盖全局配置的title，第三种就是通过API设置。wx.showNavigationBarLoading()设置在导航条上显示Loading加载状态wx.hideNavigationBarLoading() 隐藏Loading加载状态导航视图的一些方法wx.navigateTo() 保留当前页面进行跳转，传参时就像拼接GET参数一样即可，代码中会有体现wx.redirectTo() 销毁当前页面进行跳转，wx.navigateBack() 返回上一个页面wxml<button type=\"primary\" bindtap=\"setNavigationBarTitle\">设置navigationBarTitle</button>\r\n<button type=\"primary\" bindtap=\"showNavigationBarLoading\">设置navigationBarLoading加载状态</button>\r\n<button type=\"primary\" bindtap=\"hiddenNavigationBarLoading\">隐藏navigationBarLoading加载状态</button>\r\n<button type=\"warn\" bindtap=\"navigateTo\"> 保留当前页跳转</button>\r\n<button type=\"warn\" bindtap=\"redirectTo\"> 不保留当前页面跳转</button>\r\n<button type=\"warn\" bindtap=\"navigateBack\">退回到上一个页面</button>123456123456json{\r\n    \"navigationBarTitleText\": \"我是通过json配置的title\"\r\n}123123js//导入另一个页面\r\nvar file = '../audio/audio'\r\nPage({\r\n  data:{\r\n    text:\"Page navigation\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  /**\r\n   * 设置NavigationTitle\r\n   */\r\n  setNavigationBarTitle: function() {\r\n    wx.setNavigationBarTitle({\r\n      title: '我是通过API设置的NavigationBarTitle'\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 设置加载状态\r\n   */\r\n  showNavigationBarLoading: function() {\r\n    wx.showNavigationBarLoading()\r\n  },\r\n\r\n  /**\r\n   * 隐藏加载状态\r\n   */\r\n  hiddenNavigationBarLoading: function() {\r\n    wx.hideNavigationBarLoading()\r\n  },\r\n\r\n  /**\r\n   * 保留当前Page跳转\r\n   */\r\n  navigateTo: function() {\r\n    wx.navigateTo({\r\n      //传递参数方式向get请求拼接参数一样\r\n      url: file + '?phone=18939571&password=1992',\r\n      success: function(res) {\r\n        console.log(res)\r\n      },\r\n      fail: function(err) {\r\n        console.log(err)\r\n      }\r\n\r\n    })\r\n  },\r\n  /**\r\n   * 关闭当前页面进行跳转当前页面会销毁\r\n   */\r\n  redirectTo: function() {\r\n    wx.redirectTo({\r\n       //传递参数方式向get请求拼接参数一样\r\n      url: file + '?phone=189395719&password=1992'\r\n    })\r\n  },\r\n  /**\r\n   * 退回到上一个页面\r\n   */\r\n  navigateBack: function() {\r\n    wx.navigateBack()\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})三：animation API动画水还是比较深的，这里只是简单介绍下小程序中动画的一些属性和注意事项，做动画前一定要整理好思路将动画一步步分解，再进行组合！这里只做引入。wx.createAnimation(object)看官方介绍1.创建一个动画实例animation。调用实例的方法来描述动画。最后通过动画实例的export方法导出动画数据传递给组件的animation属性。2.调用动画操作方法后要调用 step() 来表示一组动画完成，可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。step 可以传入一个跟 wx.createAnimation() 一样的配置参数用于指定当前组动画的属性这还是比较好理解的比如第一条对应代码animation: this.animation.export() 第二条比如缩放动画，也就说是一组scale，scaleX, scaleY…为一缩放动画组的一个动画方法，缩放动画组和旋转动画组通过step()链接，按顺序执行。代码中体验吧！看效果反过来看会更容易理解主要属性：这里主要树下timingFunction和transformOrigintimingFunction 设置动画效果linear 默认为linear 动画一直较为均匀ease 开始时缓慢中间加速到快结束时减速ease-in 开始的时候缓慢ease-in-out 开始和结束时减速ease-out 结束时减速step-start 动画一开始就跳到 100% 直到动画持续时间结束 一闪而过step-end 保持 0% 的样式直到动画持续时间结束 一闪而过transformOrigin 设置动画的基点 默认%50 %50 0left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100%top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100%动画组及动画方法样式：旋转：缩放：偏移：倾斜：矩阵变形：演示单个动画组效果wxml\r\n<view class=\"container\">\r\n  <view animation=\"{{animation}}\" class=\"view\">我在做动画</view>\r\n</view>\r\n<button type=\"primary\" bindtap=\"rotate\">旋转</button>1234512345jsPage({\r\n  data:{\r\n    text:\"Page animation\",\r\n    animation: ''\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //实例化一个动画\r\n    this.animation = wx.createAnimation({\r\n      // 动画持续时间，单位ms，默认值 400\r\n      duration: 1000, \r\n      /**\r\n       * http://cubic-bezier.com/#0,0,.58,1  \r\n       *  linear  动画一直较为均匀\r\n       *  ease    从匀速到加速在到匀速\r\n       *  ease-in 缓慢到匀速\r\n       *  ease-in-out 从缓慢到匀速再到缓慢\r\n       * \r\n       *  http://www.tuicool.com/articles/neqMVr\r\n       *  step-start 动画一开始就跳到 100% 直到动画持续时间结束 一闪而过\r\n       *  step-end   保持 0% 的样式直到动画持续时间结束        一闪而过\r\n       */\r\n      timingFunction: 'linear',\r\n      // 延迟多长时间开始\r\n      delay: 100,\r\n      /**\r\n       * 以什么为基点做动画  效果自己演示\r\n       * left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100%\r\n       * top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100%\r\n       */\r\n      transformOrigin: 'left top 0',\r\n      success: function(res) {\r\n        console.log(res)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 旋转\r\n   */\r\n  rotate: function() {\r\n    //顺时针旋转10度\r\n    //\r\n    this.animation.rotate(150).step()\r\n    this.setData({\r\n      //输出动画\r\n      animation: this.animation.export()\r\n    })\r\n  },\r\n\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263演示多个动画组效果这里我们只需要更改以下代码即可  /**\r\n   * 旋转\r\n   */\r\n  rotate: function() {\r\n    //两个动画组 一定要以step()结尾\r\n    /**\r\n     * 动画顺序 顺时针旋转150度>x,y 放大二倍>x，y平移10px>x,y顺时针倾斜>改变样式和设置宽度宽度\r\n     */\r\n    this.animation.rotate(150).step().scale(2).step().translate(10).step().skew(10).step().opacity(0.5).width(10).step({ducation: 8000})\r\n    this.setData({\r\n      //输出动画\r\n      animation: this.animation.export()\r\n    })\r\n  }"}
{"title": "微信小程序把玩《十四》：canvas API ", "author": "天下雪", "pub_time": "2016-10-28 13:41", "article_content": "绘图是每个移动应用必备的技术，基本上和Android，IOS，等移动开发都是相同的，创建个上下文，给你个画布再上画，官网给的小例子都比较全了自己去看吧，drawImage时没有反应不知道是BUG还是电脑不能测试待定，http://wxopen.notedown.cn/api/api-canvas.html屏幕就像是数学上的坐标轴，且在第四象限，以屏幕左上角为圆点，X轴向右为正向左为负，Y轴向下为正向上为负（这点和数学上相反的）以圆点为基点画个距离圆点上下50宽高100的矩形来演示canvas基本用法微信小程序这里提供了两个APIwx.createContext() 创建并返回绘图上下文context对象getActions 获取当前context上存储的绘图动作，对应wx.drawCanvas(object)中的actionsclearActions 清空当前的存储绘图动作wx.drawCanvas(object) 绘制canvasId 画布标识，传入的cavas-id，这里的标识可以为Number，也可以是Stringactions 绘图动作数组，由wx.createContext创建的context，调用getActions方法导出绘图动作数组。绘图中可以进行变形，绘制，路径，样式，这些个东西有点多官网有例子，这里通过一个例子引入wxml<!--画布\r\n  canvas-id 为画布标识，当绘制时通过canvas-id找到画布\r\n-->\r\n<canvas canvas-id=\"identify\"/>12341234jsPage({\r\n  data:{\r\n    text:\"Page canvas\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //第一步创建个上下文容器\r\n    var context = wx.createContext();\r\n\r\n    //第二步绘制这里我们绘制个矩形 \r\n    //x, y, widht, height\r\n    context.rect(50, 50, 100, 100);\r\n    //绘制的样式进行描边绘制，fill为填充位置\r\n    context.stroke();\r\n    /**\r\n     *  调用wx.drawCanvas，通过canvasId指定在哪张画布上绘制，通过actions指定绘制行为\r\n     * \r\n     *    注意convasId可以为数字表示也可以用字符串表示，就是一个绘制对象的标识，并且可以指定多个\r\n     *    actions 是从context上下文中获取的绘制行为，即为第二步操作\r\n     */\r\n\r\n    wx.drawCanvas({\r\n      //画布标识，传入<canvas/>的cavas-id\r\n      canvasId: 'identify',\r\n      //获取绘制行为， 就相当于你想做到菜context.getActions()就是食材\r\n      actions: context.getActions(),\r\n    })\r\n\r\n\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})"}
{"title": "小程序微信支付不完全接入指南 ", "author": "天下雪", "pub_time": "2016-10-28 13:51", "article_content": "微信支付在 2013 年发布，作为内测开发者一路走来，可以感觉到微信支付接口稳定程度、文档的准确性都有质的提升。围绕支付相关的场景也配备对应的接口。本次小程序的发布，随机附送了一个微信支付模块，该模块使用起来的情况如何，就由我来告诉你吧。业务流抛开小程序的微信支付模块，我们总览微信支付的一些基本情况。微信支付有以下支付模式:微信客户端内的网页支付 (JSAPI)扫码支付 (PC 端，移动支付终端)刷卡支付 (支付终端扫描)app 支付 (iOS, Android)各种支付交互流程可通过微信文档进行查看，在此不赘述。支付发起所有支付方式都需要通过 『统一下单』的 API 来进行获取一个支付凭证，在内测以及刚发布的微信支付，是没有『统一下单』的概念，HTML 5 应用发起支付可以直接通过前端构造参数来进行发起。此时微信支付开发者很容易就造成支付凭证泄露等安全问题。为此，微信支付将其流程做了优化，在所有支付场景中插入『统一下单』，推荐开发者在后端完成支付参数的构建等行为。该优化带来以下好处:尽可能让开发者不犯低级错误，造成财务损失。简化构造支付参数的复杂度，所有支付方式可共享一个支付后端接口通过『统一下单』获取到相对应 prepay_id 或者 code_url 等参数，即可通过各种支付模式的 SDK 来进行微信支付的发起。支付结果接收微信支付发起完成后，微信还需要提供一个通知系统，以便及时让应用知道用户已经完成支付，可以进行下一步的业务操作。通知方式为一个 POST 请求，payload 为支付的状态信息，以及支付订单信息。注意必须对通知参数进行签名验证，以确保安全。进行签名验证时，除去签名字段，一般参数名为: sign，不需要参与签名外，其余所有接收到的参数均需要参与签名。周边接口通过 『支付发起』，『支付结果接收』，即可完成一个简单的微信支付系统。当然，微信还提供一下接口:查询订单取消订单申请退款查询退款下载对账单具体使用可以参考微信文档，根据自身业务情况适当的进行采用。绊脚石嗯，没错，我们吃了一次螃蟹，小程序刚内测，我们就决定使用微信支付模块，毕竟我们要实现的是一个电商应用 (电商没支付算什么嘛。开发过程中，我们掉了一些坑。支付凭证小程序的微信支付需要单独去申请，因为小程序是有独立的 appid，不能使用以前的支付账户，即使是全网发布也不能，因为小程序不是一个 HTML 5 应用。签名方式MD5! MD5! MD5!微信公众文档有很多 SHA1, MD5 的签名要求，微信支付相关的签名，暂时暂时暂时都是使用 MD5。小程序端在发起微信支付的时候是通过以下方式来进行发起:按照微信文档签名的要求，参与签名的字段应该为timeStampnonceStrpackagesignTypeok，按照签名算法得到的签名，去发起支付，居然提示失败了，经过与微信对接人员沟通后，参与签名的字段还需要加上 appid, 哦，不对，是 appId（请严重区分驼峰命名的大小写）。对这样的结果我表示不服，随即我翻阅了微信支付所有文档，终于在微信 JSSDK 的文档中找到一行备注。备注：prepay_id 通过微信支付统一下单接口拿到，paySign 采用统一的微信支付 Sign 签名生成方法，注意这里 appId 也要参与签名，appId 与 config 中传入的 appId 一致，即最后参与签名的参数有appId, timeStamp, nonceStr, package, signType。怪我咯(黑人问号) 点我去取笑!timestamp 类型小程序端发起微信支付的方式已经贴在上面了，但没那么简单，继续贴文档说明。timeStamp DateInt 时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间文档告诉我们 timeStamp 应该带着 int 类型传入。我们前端的同学照做了，然后就过来骂我。你们后端参数是不是有问题!!! 提示 timeStamp 不存在了都经过排查，传入的 timeStamp 的值类型应该为 String结尾语总体上小程序接入微信支付还是比较简单的，没有过多复杂的设置，如果之前开发过微信支付后端的开发者，还可以复用同一个支付模块。文档的编写不严谨，使得开发舒爽度严重被削减。相信随着时间推进，文档会慢慢完善，毕竟以前也是这么过来的。"}
{"title": "微信小程序组件默认样式优先级 bug 解析 ", "author": "天下雪", "pub_time": "2016-10-28 13:54", "article_content": "在当前版本（iOS 客户端 6.3.27，开发工具 0.10.101400）中，微信小程序在 wxss 中存在一个优先级导致的 bug。官方文档中提到可以使用标签选择器，控制同一类组件的样式。如：使用 input 标签选择器控制<input/> 的默认样式此处存在一个比较明显的 bug，小程序中的组件大部分都是有默认的样式的，例如 image 组件就存在四个默认样式，其中一个默认样式为 display: inline-block。如果试图使用上述的标签选择器设置 image 的 display 属性，会发现并没有生效。而通过开发者工具可以查看到，设置没有生效的原因是 image 组件默认的样式优先级高于我们通过标签选择器设置的样式。经过测试，基本上所有组件的默认样式的优先级都会高于通过标签选择器设置的样式，而 class 选择器和 id 选择器的优先级还是高于默认样式。因此，目前如果想改变组件默认的样式，不能标签选择器直接设置，而是应该给需要改变默认样式的组件赋予同样的 class，再通过此 class 来改变默认样式。这个优先级的 bug，除了上述的所有组件默认样式的问题之外，针对某些特殊组件，如 button，还有更进一步的问题。button 组件可以分别设置 size、type 和 plain 三种属性，从而显示不同的按钮样式。测试中发现，如果着三种属性使用了非默认值之外的值，例如 type=“primary”，除了 button 组件默认的样式之外，type 为 primary 的 button 还会有额外的两个默认样式color: #FFFFFF 和 background-color: #1AAD19。此时如果通过 class 选择器设置 color 为其它值，会发现并没有生效。同样，通过开发者工具可以看到，type 为 primary 时的 button 的两个“额外”默认样式的优先级高于 class 选择器。因此在此种情况下，只能通过 id 选择器才能改变上述的两个“额外”默认样式。此外，有一点值得提醒的是。实际开发（真机及模拟器）中会发现目前 wxss 中是可以使用级联选择器的，及类似.parent .child { width: 100%; }由此则衍生出来一个比较优雅的解决上述 bug 的方法：修改 container 下 所有 image 组件的默认样式.container image { display: block; }改变 button[type=”primary”] 的“额外”默认样式.container .btn { color: red; }由此也可猜测上述 bug 出现的原因，可能是由于小程序的组件默认样式的实现过程中使用了类似标签选择器和类选择器，但没有控制好优先级导致。但是，请注意：不要使用此方法！不要使用此方法！不要使用此方法！官方文档中明确说明样式表不支持级联选择器不推荐使用官方文档中明确表明不能使用的方法。目前小程序还是处于内测阶段，此方法还能使用，只是官方的疏忽，很有可能此方法会突然无法使用。此外根据微信小程序内测群中的消息：目前还能用级联选择器是由于还没有过滤掉级联选择器。而级联选择有可能会破坏掉基础组件的一些样式，因此后续有时间了就会加上过滤。推荐使用 BEM，同时，后续也可能会加上不会破坏基础组件的级联方法，不过此需求的优先级会低一些。"}
{"title": "微信小程序之运维小项目 ", "author": "天下雪", "pub_time": "2016-10-28 15:13", "article_content": "自从微信推出小程序以来，现在业界炒的非常的火，具说叫微信小程序是因为某公司不让叫应用号，我在朋友圈也看过pony的和张小龙朋友圈关于名字的讨论截图，不知道是真是假，反正名字是定了，叫啥无所谓，还是知道它是干啥的比较重要， 像网上说什么新风口了，原生APP以后没活路了等相关文章喜欢的可以多看看， 我们今天不会在产品层面上去介绍小程序，因为我们是搞运维的，所以我还是在运维层面怎么使用小程序， 今天我们用实际例子来讲解和普及小小程序如何使用，来实现类似IP138的功能，输入IP可以查看IP的详细信息，包括归属，地点等，我们先看下完成后的效果：基本功能就是做一个IP查询的页面，输入ip，能够查询IP的详细信息，后台调用的淘宝的IP库，OK，界面和功能就是这样了，比较简单，接下来我们来介绍小程序的基本概念和使用。第一步，先下载微信小程序开发者工具，这个是必须的，因为只能在这个工具里去调试你的代码，但写代码不一定要在这个工具里去写，在Sublime 里写也可以，但调试你必须在这工具里，关于怎么下怎么装这我就不多说了，如果这步都没搞定我觉得往下看也没啥意义了，当然是开个玩笑，如果有问题的，可以给我留言。安装后，第一次运行需要用微信扫描，来识别开发者，然后添加项目，微信开发者工具可以帮你生成一个简单的demo项目，生成项目后如图： 我们先看app.js、app.json、app.wxss 这三个，其中app.js 是小程序的脚本代码,可以定义全局变量， 指定小程序的生命周期函数（onLaunch，onShow，onHide，其它），app.json文件是配置文件，主要配置小程序的页面，所有的页面设置都要写在这个文件里app.wxss 是公共样式表文件。除了这些文件，我们还有两个目录，这2个目录展示的是index 页面和 logs 页面，每个目录下如果完整的情况下都会有4个文件：如上图所示，现在每个目录下分别是index.js、index.wxml、index.wxss，其中.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件（非必须），.wxss 后缀的是样式表文件（非必须），.wxml 后缀的文件是页面结构文件。以上就是小程序的基本概念了，了解了这些，就可以开始我们的小项目开发了。首先我们先写index.wxml。代码如下： 因为界面我加了一部分样式，所以要写index.wxss样式文件，代码如下： 有了这些只是个壳子，输入IP点击查询时没有效果的， 因为我们还需要从后台获取数据，现在开始写我们的index.js文件，因为js文件内容比较多，我们分开介绍，先说下下初始化部分，刚开始都是空，然后是我们的核心函数，先判断IP是否为空，如果是就提示IP不能为空，如果有IP，就调用wx.request发请求,将获得的数据然后通过setData来赋值，如网络有问题，就报网络请求失败，代码如下：最后，查询完后需要重新输入，当用户点重置时清空所有的内容，包括刚获取的值，代码如下：完成以上代码就可以在开发者工具里调试下了，如果都正常，这个小项目就算完成了，等微信开发公测的时候就可以传到微信小程序市场里，然后每个人就可以下载去使用了。关于小程序的内容我就介绍到这里，我这里就算是抛砖引玉了，喜欢的小伙伴可以帮忙转发下，让更多的小伙伴可以学习到新的知识，另外因为小程序是非常新的东西，想更深入了解的可以去看小程序的官方文档。"}
{"title": "最新微信小程序开发工具破解v0.10.102800 ", "author": "天下雪", "pub_time": "2016-10-29 00:54", "article_content": "项目地址：https://github.com/jsongo/weApp-ide 项目下载：weApp-ide-master.zip最新版本v0.10.102800的破解文件，欢迎试用。这一次的更新很大，主要变化摘录如下：A 增加 四个文件管理 API wx.getSavedFileList、wx.getSavedFileInfo、wx.removeSavedFile、wx.openDocument 详情A 增加 四个数据管理 API wx.removeStorage、wx.removeStorageSync、wx.getStorageInfo、wx.getStorageInfoSync 详情A 新增 四个交互反馈 API wx.showToast、wx.showModal、wx.hideModal、wx.showActionSheet 详情A 新增 选择地理位置 API wx.chooseLocation 详情A 新增 获取图片信息 API wx.getImageInfo 详情A 新增 两个设备 API wx.getSystemInfoSync、wx.makePhoneCall 详情A 新增 绘图 API wx.canvasToTempFilePath 详情A 新增 音频媒体 API wx.createAudioContext 详情A 新增 开放能力 API wx.checkSession 详情A 新增 wx.navigateBack delta 参数，支持多层级返回 详情A 新增 wx.sendSocketMessage、wx.onSocketMessage 支持收发 ArrayBuffer 数据类型A 新增 getCurrentPages() 方法， 获取页面栈 详情A 新增 Page.onReachBottom() 方法，监听页面到达底部 详情A 新增 事件对象增加 changedTouches 列表，反应手指触摸位置的变化 详情A 新增 <textarea/> 组件 详情A 新增 <canvas/> 多点触摸 详情A 新增 <canvas/> disable-scroll 属性 详情A 新增 <image/> bindload 事件返回图片宽高 详情A 新增 <text/> 嵌套 <text/> 功能 详情A 新增 <video/> controls autoplay 属性 详情A 新增 <video/> 支持设置弹幕、发送弹幕 详情A 新增 <video/> 播放类事件和接口 详情A 新增 WXML wx:key 支持，提升列表渲染时性能 详情A 新增 WXML 关键字、数据路径计算 详情U 新增 app.json tabBar 属性 position 用于指定显示位置 详情F 修复 wx.navigateTo api 超过 5 个页面，调用失败无返回的问题U 修复 <navigator/> 设置 display: flex 失效的问题F 修复 <input/> text-align:center、text-align:right 不支持的问题F 修复 <input/> 聚焦时异常的问题F 修复 <image/> base64 图片显示的问题F 修复 动态节点更新导致表单组件重置问题F 修复 使用 rpx 单位部分手机出现边框显示不全的问题F 修复 不同页面中相同的 canvas-id 共享同一个绘图上下文的问题F 修复 page 里面的属性对象内的 function 失效的问题F 修复 wx.drawCanvas 在 canvas 宽高为 0 的情况下画不出来的问题F 修复 wx.request header 设置 'Content-Type' 异常的问题D 即将移除 App.prototype.getCurrentPage 详情D 即将移除组件： <toast/> <loading/> <action-sheet/> <modal/>D 即将移除 <audio/> action 属性1可以分析它的源码学习这套框架破解方式：把相应的文件做个替换就行。当前文件可破解版本：v0.10.102800mac上：找到开发工具的程序，右击“显示包内容”：Resources/app.nw/app/dist/components/create/createstep.jsResources/app.nw/app/dist/stores/projectStores.jsResources/app.nw/app/dist/weapp/appservice/asdebug.jsResources/app.nw/app/dist/common/assdk/storageSdk.jswindow上：安装完后，一般是放在这个目录里：C:\\Program Files (x86)\\Tencent\\微信web开发者工具找到相应文件再替换：package.nw/app/dist/components/create/createstep.jspackage.nw/app/dist/stores/projectStores.jspackage.nw/app/dist/weapp/appservice/asdebug.js破解的时候，把整个代码大概浏览了一遍，自己折腾了下。（因为之前写过react + flux的代码，所以对这个项目的结构非常熟悉。）主要的修改，如果你有兴趣可以浏览下：1、asdebug.js修改（1）搜索“域名”两个字，找到类似域名校验出错等字眼的那一个function 把整个function内部的内容都注释掉，直接return true;这个主要是为了去掉安全域名的限制（2）搜索“URL 域名不合法，请在 mp 后台配置后，重启项目继续测试” 跟上面一样，把前面if改成if(false)这个修改主要是为了去掉websocket的安全名限制（3）搜索“__wxConfig.isTourist”，把它改成false这个修改是为了去掉游客身份。2、projectStores.js（1）搜索“setProjectConfig: function” 这个函数的定义把“i = e.isTourist”（不一定是i和e，不同的js格式化工具可能会有不一样的结果）这一小段注释掉，把下方的第一个if(i) { ... }整块注释掉。这一个用来判断是否是游客身份，是的话直接返回。但我们不想只是游客身份，所以这里我们不能让它返回，整个注释掉就行了。（2）在上面这个函数从上往下找try catch，把找到的第一个整块注释掉 然后把它下方的第一个if改成if(true)，if里的第一行var赋值语句的等号后面直接改成{Setting: {MaxLocalstorageSize: 10}}，因为在dist/common/assdk/storageSdk.js里有对这个值的引用，如果这里没有设置这个MaxLocalstorageSize的话，wx.setStorage会保存失败，wx.setStorageSync会报错。另外这里设置成if(true)是因为我们在创建项目时随便填appid，所以网络请求返回肯定是error，这里的JSON.parse结果在if里是通不过的。我们把这一整段注释掉，不去管网络返回的error。进if后会在本地存储新建项目的信息。这个地方的修改比较复杂，截图如下：3、createstep.js（1）搜索“当前开发者未绑定此 appid”把第一个if及周边的东西都注释掉，只执行下一个if。这个地方是创建的时候，返回用户信息的地方，上面说过我们创建时返回的肯定是error，所以这里自然也拿不到用户信息，反而是一个用户appId错误提示，所以这里我们动点手脚，把这个判断都注释掉，让它只执行用户信息返回的成功代码，同时我们创建一个假的用户信息object。这个修改比较复杂，截图如下：网络请求的接口，微信做了一些安全限制，要破解才能给任意地址发请求。websocket的接口也是一样。本项目的破解文件已经解决了这些问题。另外，创建出来的demo项目中，调用wx.login是不能成功的，所以改了demo的代码，在app.js里直接给globalData.userInfo赋值即可。init: function() {\r\n  this.globalData.userInfo = {\r\n    \"nickName\": \"jason\",\r\n    \"avatarUrl\": \"http://wx.qlogo.cn/mmopen/icSHGibMIMB82jDEHibGFA1s6dhwMibWrQAPeRvT2w2y2rpZVM5l3BftVEr3rTgX4fXDlznnMmZY0zYtgkfFw7L3o9r0tTblGTxB/0\",\r\n    \"gender\": 1,\r\n    \"province\": \"广东\",\r\n    \"city\": \"深圳\",\r\n    \"country\": \"中国\",\r\n  };\r\n},\r\n然后在onLaunch里调用一下init()就ok几个问题说明MaxRequestConcurrent报错的问题这个在本项目的破解文件里已经直接覆盖了，不会报这个错了。（修改：asdebug.js里，搜MaxRequestConcurrent，很简单，直接把它设置成固定数字即可）页面切换时会出现route错误的问题这个可能是开发工作自身的bug，用一段时间后就会这样，目前还没发现原因，不过解决这个问题很简单，关掉，重新再开就好了。Failed to load resource: net::ERR_NAME_NOT_RESOLVED这个问题gavinkwoe的项目中也说明了，主要是由于代理导致的，打开ide，菜单上选“动作”->“设置”，选直连就行"}
{"title": "微信小程序二三级菜单（navigateTo传递数据的应用） ", "author": "天下雪", "pub_time": "2016-10-29 01:03", "article_content": "今早来之后稍微写了下今天的工作目标然后就是自己犯蠢到现在的过程，所幸最后还是走回了正轨，记录一下我在过程中的内心弹幕，并把最后结果记录一下微信小程序-估价系统-车辆品牌款式等-三级菜单车标省份-城市-二级菜单（二三级菜单首先考虑使用微信小程序的数据缓存，但在不刷新的情况下缓存数据永远是上一次保存的。今天更新了微信小程序开发工具版本，发现写了数据缓存的代码之后后面的跳转语句不能执行无法跳转。打算放弃数据缓存的方式，想到另一种是在数组中加上跳转的目标地址然后直接跳过去，这样的弊端在于需要加上许多的页面比如一个省下的城市页面几十个省要几十个页面，忽然灵光一闪，考虑是否可以跳转中携带数据？马上进行尝试。！！！！我的天，我之前看官方文档都是睡觉去了吗。。。navigateTo的url里是可以带参数的，我没看到！！！！！！！！！！！！！！！！就算没看到以前写过的js都是做梦去了吗！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！我成功了，喜极而泣。）最终代码：toCity:function(e){    var index=e.currentTarget.dataset.hi;    var arr=this.data.provinceList[index].city;     wx.navigateTo({         url:\"../city/city?cityList=\"+arr     })   }跳转的时候url链接里把要传的数据加上就可以，我想传的数据是数组arr在跳转目标的js文件里用以下代码获得数据Page({    onLoad:function(options){        this.setData({            cityList:options.cityList.split(\",\")        })    }})因为直接用options.cityList得到的是字符串我用split转换成了数组。完美有木有。/(ㄒoㄒ)/~~所以当初为什么没有仔细看官方文档效果图如下，点山东跳转到山东的城市"}
{"title": "半桶水技术分享：微信小程序实现跳转传参 ", "author": "天下雪", "pub_time": "2016-10-29 23:20", "article_content": "刚接触微信小程序，多里面的语法和属性还不怎么聊解，如有不多的地方希望各位大神多多指教。今天来说下微信小程序怎么跳转和传参，话不多说直接上代码。实现的功能是给列表增加点击功能传参到下一页；    代码如下：<import src=\"../WXtemplate/headerTemplate.wxml\"/>  <view>      <!--滚动图-->      <view>       <swiper  indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoPlay}}\" interval=\"{{intervalTime}}\" duration=\"{{Time}}\">          <block wx:for=\"{{imageURl}}\">              <swiper-item>                   <image src=\"{{item}}\" class=\"imagePX\"></image>              </swiper-item>          </block>      </swiper>      </view>      <!--功能按钮-->      <view class=\"section-bg\">          <block wx:for=\"{{buttonNum}}\">           <!--模版-->              <template is=\"buttonList\" data=\"{{item}}\"/>              <!--<view class=\"section-item\">            <image class=\"section-img\" src=\"{{item.image}}\"></image>              <text class=\"section-text\">{{item.text}}</text>          </view>-->          </block>      </view>      <!--资讯列表-->      <view>          <block wx:for=\"{{listNum}}\">              <template is=\"newList\" data=\"{{item,index}}\"/>          </block>      </view>   </view>  其中<template is=\"buttonList\" data=\"{{item}}\"/> 为模版代码如下<template name=\"buttonList\">       <view class=\"section-item\">            <image class=\"section-img\" src=\"{{item.image}}\" bindtap=\"buttonClick\"></image>              <text class=\"section-text\">{{item.text}}</text>          </view>  </template>  <!--list-->  <template name=\"newList\">       <view class=\"section-list\" bindtap=\"listClick\" id=\"{{index}}\">          <view>              <image class=\"list-img\" src=\"{{item.image}}\"></image>          </view>           <view class=\"section-textt\">               <view class=\"title\"><text>{{item.title}}</text></view>               <view class=\"subTitle\"><text>{{item.subTitle}}</text></view>          </view>      </view>  </template>  这里只为下面的列表增加了点击方法点击列表js代码listClick:function(event){      console.log(event);     var p = event.currentTarget.id      wx.navigateTo({url:'/pages/xiangqing/xiangqing?id=上一页的参数'})    }  其中wx.navigateTo({url:'/pages/xiangqing/xiangqing?id=上一页的参数'}) 为跳转方法，id为需要传的参数 如果参数为动态参数代码如下： <pre name=\"code\" class=\"javascript\"> listClick:function(event){        console.log(event);       var p = event.currentTarget.id        wx.navigateTo({url:'/pages/xiangqing/xiangqing?id='+p})      } 其中p为上面为每一行设置的id值在下一页取值代码如下：<pre name=\"code\" class=\"javascript\">  data:{      // text:\"这是一个页面\"      title:''    },    onLoad:function(options){      // 页面初始化 options为页面跳转所带来的参数    this.setData({      title:options.id    })  然后在页面上显示代码如下：<pre name=\"code\" class=\"html\"><view>{{title}}</view> 最终实现效果："}
{"title": "半桶水技术分享《二》：js实现单选功能 ", "author": "天下雪", "pub_time": "2016-10-29 23:25", "article_content": "初次接触js弄了好长时间才出来效果，但是还是觉的不做梦完美，希望有更好的方式进行交流；实现效果如下：虽说这个小功能但是对于我这个新手来说还是有点难；具体代码如下：WXML：[html] view plain copy<span style=\"color:#333333;\"><view class=\"backgrout-bj\">      <view class=\"header\">          最多可增加4个功能入口      </view>      <view>          <block wx:for=\"{{model}}\">               <view class=\"model-list\" bindtap=\"selectClick\" id=\"{{index}}\">                   <view>                      <image class=\"middle-img\" src=\"{{item.image}}\"></image>                  </view>                   <view class=\"middle-title\">                      <view><text>{{item.title}}</text></view>                       <view class=\"middle-sub\"><text>{{item.sub_title}}</text></view>                    </view>                    <!--<view  hidden=\"{{item.selectImage}}\">                      <image src=\"../image/xuanze.png\" class=\"seletedImage\"></image>                    </view>-->                    <view  wx:if=\"{{item.selectImage==true}}\">                      <image src=\"../image/xuanze.png\" class=\"seletedImage\"></image>                    </view>              </view>                     </block>      </view>  </view></span>  从大的分科分为两个大块一个是上面的header  剩下的列表是另外一个部分，列表中又分为若干个小块，本打算写个模版，但是感觉这样更清晰 WXSS：[css] view plain copy.backgrout-bj{ &n"}
